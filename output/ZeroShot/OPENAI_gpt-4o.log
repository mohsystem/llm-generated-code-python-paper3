D:\Programs\Python312\python.exe D:\sourceCode\PhD\paper2\code_generation\main_ZeroShot.py
Task100_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task100, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that retrieves a regular expression pattern and a file name from command line arguments. The program should compile the regular expression pattern and use it to search the content of the specified file.
```java
import java.io.*;
import java.util.regex.*;

public class Task100 {
    public static boolean searchFile(String pattern, String filename) {
        try {
            Pattern compiledPattern = Pattern.compile(pattern);
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            String line;
            while ((line = reader.readLine()) != null) {
                Matcher matcher = compiledPattern.matcher(line);
                if (matcher.find()) {
                    reader.close();
                    return true;
                }
            }
            reader.close();
        } catch (IOException | PatternSyntaxException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println("Usage: java Task100 <pattern> <filename>");
            return;
        }
        System.out.println(searchFile(args[0], args[1]));
    }
}
```
```python
import re
import sys

def search_file(pattern, filename):
    try:
        with open(filename, 'r') as file:
            content = file.read()
            if re.search(pattern, content):
                return True
    except (IOError, re.error) as e:
        print(e)
    return False

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python <script> <pattern> <filename>")
    else:
        print(search_file(sys.argv[1], sys.argv[2]))
```
```cpp
#include <iostream>
#include <fstream>
#include <regex>
#include <string>

class Task100 {
public:
    static bool searchFile(const std::string& pattern, const std::string& filename) {
        try {
            std::regex compiledPattern(pattern);
            std::ifstream file(filename);
            std::string line;
            while (std::getline(file, line)) {
                if (std::regex_search(line, compiledPattern)) {
                    file.close();
                    return true;
                }
            }
            file.close();
        } catch (const std::ifstream::failure& e) {
            std::cerr << e.what() << std::endl;
        } catch (const std::regex_error& e) {
            std::cerr << e.what() << std::endl;
        }
        return false;
    }

    static void testCases() {
        std::cout << searchFile("test", "example.txt") << std::endl;
    }
};

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cout << "Usage: <program> <pattern> <filename>" << std::endl;
    } else {
        std::cout << Task100::searchFile(argv[1], argv[2]) << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <regex.h>

int searchFile(const char *pattern, const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("File opening failed");
        return 0;
    }

    regex_t regex;
    int reti;
    char msgbuf[100];

    /* Compile regular expression */
    reti = regcomp(&regex, pattern, REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Could not compile regex\n");
        return 0;
    }

    char line[256];
    while (fgets(line, sizeof(line), file)) {
        /* Execute regular expression */
        reti = regexec(&regex, line, 0, NULL, 0);
        if (!reti) {
            regfree(&regex);
            fclose(file);
            return 1;
        }
    }
    fclose(file);
    regfree(&regex);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: <program> <pattern> <filename>\n");
    } else {
        printf("%d\n", searchFile(argv[1], argv[2]));
    }
    return 0;
}
```
Created file: Task100.java
Created file: Task100.py
Created file: Task100.cpp
Created file: Task100.c
Task101_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task101, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a file named script.sh and makes it executable.
```java
import java.io.File;
import java.io.IOException;

public class Task101 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            createExecutableFile("script" + i + ".sh");
        }
    }

    public static boolean createExecutableFile(String fileName) {
        File file = new File(fileName);
        try {
            if (file.createNewFile()) {
                if (file.setExecutable(true)) {
                    System.out.println(fileName + " is created and set as executable.");
                    return true;
                } else {
                    System.out.println("Failed to set " + fileName + " as executable.");
                }
            } else {
                System.out.println(fileName + " already exists.");
            }
        } catch (IOException e) {
            System.out.println("An error occurred while creating the file.");
            e.printStackTrace();
        }
        return false;
    }
}
```
```python
import os

def create_executable_file(file_name):
    try:
        with open(file_name, 'w') as file:
            pass
        os.chmod(file_name, 0o755)
        print(f"{file_name} is created and set as executable.")
        return True
    except Exception as e:
        print(f"An error occurred: {e}")
        return False

if __name__ == "__main__":
    for i in range(5):
        create_executable_file(f"script{i}.sh")
```
```cpp
#include <iostream>
#include <fstream>
#include <sys/stat.h>

bool createExecutableFile(const std::string& fileName) {
    std::ofstream file(fileName);
    if (file.is_open()) {
        file.close();
        if (chmod(fileName.c_str(), 0755) == 0) {
            std::cout << fileName << " is created and set as executable." << std::endl;
            return true;
        } else {
            std::cout << "Failed to set " << fileName << " as executable." << std::endl;
        }
    } else {
        std::cout << "An error occurred while creating the file." << std::endl;
    }
    return false;
}

int main() {
    for (int i = 0; i < 5; i++) {
        createExecutableFile("script" + std::to_string(i) + ".sh");
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int createExecutableFile(const char* fileName) {
    FILE* file = fopen(fileName, "w");
    if (file) {
        fclose(file);
        if (chmod(fileName, 0755) == 0) {
            printf("%s is created and set as executable.\n", fileName);
            return 1;
        } else {
            printf("Failed to set %s as executable.\n", fileName);
        }
    } else {
        printf("An error occurred while creating the file.\n");
    }
    return 0;
}

int main() {
    for (int i = 0; i < 5; i++) {
        char fileName[12];
        snprintf(fileName, sizeof(fileName), "script%d.sh", i);
        createExecutableFile(fileName);
    }
    return 0;
}
```
Created file: Task101.java
Created file: Task101.py
Created file: Task101.cpp
Created file: Task101.c
Task102_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task102, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that accept the the username and new password. The program should hash the password and update the user password in database.
```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class Task102 {

    public static String hashPassword(String password) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hash = md.digest(password.getBytes());
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public static void updatePassword(String username, String newPassword) {
        String hashedPassword;
        try {
            hashedPassword = hashPassword(newPassword);
        } catch (NoSuchAlgorithmException e) {
            System.err.println("Hashing algorithm not found.");
            return;
        }

        String url = "jdbc:mysql://localhost:3306/mydatabase"; // Change this to your database URL
        String user = "root"; // Change this to your database username
        String password = "root"; // Change this to your database password

        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            String query = "UPDATE users SET password = ? WHERE username = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(query)) {
                pstmt.setString(1, hashedPassword);
                pstmt.setString(2, username);
                pstmt.executeUpdate();
                System.out.println("Password updated successfully for user: " + username);
            }
        } catch (SQLException e) {
            System.err.println("Database connection or query failed.");
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        updatePassword("user1", "newPassword1");
        updatePassword("user2", "newPassword2");
        updatePassword("user3", "newPassword3");
        updatePassword("user4", "newPassword4");
        updatePassword("user5", "newPassword5");
    }
}
```
```python
import hashlib
import sqlite3

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def update_password(username, new_password):
    hashed_password = hash_password(new_password)
    conn = sqlite3.connect('mydatabase.db')  # Change this to your database file
    try:
        cursor = conn.cursor()
        cursor.execute('UPDATE users SET password = ? WHERE username = ?', (hashed_password, username))
        conn.commit()
        print(f"Password updated successfully for user: {username}")
    except sqlite3.Error as e:
        print(f"Database error: {e}")
    finally:
        conn.close()

def main():
    update_password("user1", "newPassword1")
    update_password("user2", "newPassword2")
    update_password("user3", "newPassword3")
    update_password("user4", "newPassword4")
    update_password("user5", "newPassword5")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <openssl/sha.h>
#include <mysql/mysql.h>

std::string hashPassword(const std::string& password) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, password.c_str(), password.size());
    SHA256_Final(hash, &sha256);
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }
    return ss.str();
}

void updatePassword(const std::string& username, const std::string& newPassword) {
    std::string hashedPassword = hashPassword(newPassword);

    MYSQL *conn;
    conn = mysql_init(NULL);
    if (conn == NULL) {
        std::cerr << "mysql_init() failed\n";
        return;
    }

    if (mysql_real_connect(conn, "localhost", "root", "root", "mydatabase", 0, NULL, 0) == NULL) {
        std::cerr << "mysql_real_connect() failed\n";
        mysql_close(conn);
        return;
    }

    std::string query = "UPDATE users SET password = '" + hashedPassword + "' WHERE username = '" + username + "'";
    if (mysql_query(conn, query.c_str())) {
        std::cerr << "UPDATE failed. Error: " << mysql_error(conn) << "\n";
    } else {
        std::cout << "Password updated successfully for user: " << username << "\n";
    }

    mysql_close(conn);
}

int main() {
    updatePassword("user1", "newPassword1");
    updatePassword("user2", "newPassword2");
    updatePassword("user3", "newPassword3");
    updatePassword("user4", "newPassword4");
    updatePassword("user5", "newPassword5");

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>
#include <mysql/mysql.h>

void hashPassword(const char *password, char *outputBuffer) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, password, strlen(password));
    SHA256_Final(hash, &sha256);
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(outputBuffer + (i * 2), "%02x", hash[i]);
    }
    outputBuffer[64] = 0;
}

void updatePassword(const char *username, const char *newPassword) {
    char hashedPassword[65];
    hashPassword(newPassword, hashedPassword);

    MYSQL *conn;
    conn = mysql_init(NULL);
    if (conn == NULL) {
        fprintf(stderr, "mysql_init() failed\n");
        return;
    }

    if (mysql_real_connect(conn, "localhost", "root", "root", "mydatabase", 0, NULL, 0) == NULL) {
        fprintf(stderr, "mysql_real_connect() failed\n");
        mysql_close(conn);
        return;
    }

    char query[256];
    snprintf(query, sizeof(query), "UPDATE users SET password = '%s' WHERE username = '%s'", hashedPassword, username);
    if (mysql_query(conn, query)) {
        fprintf(stderr, "UPDATE failed. Error: %s\n", mysql_error(conn));
    } else {
        printf("Password updated successfully for user: %s\n", username);
    }

    mysql_close(conn);
}

int main() {
    updatePassword("user1", "newPassword1");
    updatePassword("user2", "newPassword2");
    updatePassword("user3", "newPassword3");
    updatePassword("user4", "newPassword4");
    updatePassword("user5", "newPassword5");

    return 0;
}
```
Created file: Task102.java
Created file: Task102.py
Created file: Task102.cpp
Created file: Task102.c
Task103_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task103, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that checks the strength of a given password. The program should validate the password against the following criteria:

At least 8 characters long
Contains both uppercase and lowercase letters
Contains at least one digit
```java
public class Task103 {
    public static boolean isStrongPassword(String password) {
        if (password.length() < 8) {
            return false;
        }
        boolean hasUpper = false;
        boolean hasLower = false;
        boolean hasDigit = false;

        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUpper = true;
            }
            if (Character.isLowerCase(c)) {
                hasLower = true;
            }
            if (Character.isDigit(c)) {
                hasDigit = true;
            }
        }
        return hasUpper && hasLower && hasDigit;
    }

    public static void main(String[] args) {
        System.out.println(isStrongPassword("Password123")); // true
        System.out.println(isStrongPassword("password123")); // false
        System.out.println(isStrongPassword("PASSWORD123")); // false
        System.out.println(isStrongPassword("Pass12"));      // false
        System.out.println(isStrongPassword("Passw0rd"));    // true
    }
}
```
```python
def is_strong_password(password):
    if len(password) < 8:
        return False
    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password)
    has_digit = any(c.isdigit() for c in password)

    return has_upper and has_lower and has_digit

if __name__ == "__main__":
    print(is_strong_password("Password123"))  # True
    print(is_strong_password("password123"))  # False
    print(is_strong_password("PASSWORD123"))  # False
    print(is_strong_password("Pass12"))       # False
    print(is_strong_password("Passw0rd"))     # True
```
```cpp
#include <iostream>
#include <string>
#include <cctype>

bool isStrongPassword(const std::string& password) {
    if (password.length() < 8) {
        return false;
    }
    bool hasUpper = false, hasLower = false, hasDigit = false;

    for (char c : password) {
        if (std::isupper(c)) {
            hasUpper = true;
        }
        if (std::islower(c)) {
            hasLower = true;
        }
        if (std::isdigit(c)) {
            hasDigit = true;
        }
    }
    return hasUpper && hasLower && hasDigit;
}

int main() {
    std::cout << isStrongPassword("Password123") << std::endl; // 1
    std::cout << isStrongPassword("password123") << std::endl; // 0
    std::cout << isStrongPassword("PASSWORD123") << std::endl; // 0
    std::cout << isStrongPassword("Pass12") << std::endl;      // 0
    std::cout << isStrongPassword("Passw0rd") << std::endl;    // 1
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

bool isStrongPassword(const char* password) {
    if (strlen(password) < 8) {
        return false;
    }
    bool hasUpper = false, hasLower = false, hasDigit = false;

    for (int i = 0; password[i] != '\0'; i++) {
        if (isupper(password[i])) {
            hasUpper = true;
        }
        if (islower(password[i])) {
            hasLower = true;
        }
        if (isdigit(password[i])) {
            hasDigit = true;
        }
    }
    return hasUpper && hasLower && hasDigit;
}

int main() {
    printf("%d\n", isStrongPassword("Password123")); // 1
    printf("%d\n", isStrongPassword("password123")); // 0
    printf("%d\n", isStrongPassword("PASSWORD123")); // 0
    printf("%d\n", isStrongPassword("Pass12"));      // 0
    printf("%d\n", isStrongPassword("Passw0rd"));    // 1
    return 0;
}
```
Created file: Task103.java
Created file: Task103.py
Created file: Task103.cpp
Created file: Task103.c
Task104_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task104, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that handles user input into a fixed-size buffer.
```java
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class Task104 {
    private static final int BUFFER_SIZE = 256;

    public static String handleInput(String input) {
        byte[] buffer = new byte[BUFFER_SIZE];
        byte[] inputData = input.getBytes(StandardCharsets.UTF_8);

        int length = Math.min(inputData.length, BUFFER_SIZE);
        System.arraycopy(inputData, 0, buffer, 0, length);

        return new String(buffer, 0, length, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter text:");
        String userInput = scanner.nextLine();

        // Test cases
        System.out.println(handleInput(userInput));
        System.out.println(handleInput("Short input"));
        System.out.println(handleInput("This is a longer input that will be truncated to fit into the buffer size."));
        System.out.println(handleInput(""));
        System.out.println(handleInput("Exactly 256 characters: " + "A".repeat(256)));

        scanner.close();
    }
}
```
```python
def handle_input(user_input):
    BUFFER_SIZE = 256
    buffer = bytearray(BUFFER_SIZE)

    input_bytes = user_input.encode('utf-8')
    length = min(len(input_bytes), BUFFER_SIZE)
    buffer[:length] = input_bytes[:length]

    return buffer[:length].decode('utf-8')


if __name__ == "__main__":
    test_cases = [
        "User input",
        "Short input",
        "This is a longer input that will be truncated to fit into the buffer size.",
        "",
        "Exactly 256 characters: " + "A" * 232
    ]
    for test in test_cases:
        print(handle_input(test))
```
```cpp
#include <iostream>
#include <cstring>

class Task104 {
public:
    static std::string handleInput(const std::string &input) {
        const size_t BUFFER_SIZE = 256;
        char buffer[BUFFER_SIZE];

        size_t length = std::min(input.size(), BUFFER_SIZE);
        strncpy(buffer, input.c_str(), length);

        return std::string(buffer, length);
    }
};

int main() {
    std::string inputs[] = {
        "User input",
        "Short input",
        "This is a longer input that will be truncated to fit into the buffer size.",
        "",
        "Exactly 256 characters: " + std::string(232, 'A')
    };

    for (const auto &input : inputs) {
        std::cout << Task104::handleInput(input) << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

#define BUFFER_SIZE 256

void handle_input(const char* input) {
    char buffer[BUFFER_SIZE];

    size_t length = strlen(input) < BUFFER_SIZE ? strlen(input) : BUFFER_SIZE;
    strncpy(buffer, input, length);
    buffer[length] = '\0';

    printf("%s\n", buffer);
}

int main() {
    const char* inputs[] = {
        "User input",
        "Short input",
        "This is a longer input that will be truncated to fit into the buffer size.",
        "",
        "Exactly 256 characters: " "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    };

    for (int i = 0; i < 5; i++) {
        handle_input(inputs[i]);
    }

    return 0;
}
```
Created file: Task104.java
Created file: Task104.py
Created file: Task104.cpp
Created file: Task104.c
Task105_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task105, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that establishes secure SSL/TLS connections with remote servers.
```java
import javax.net.ssl.HttpsURLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.security.cert.Certificate;
import javax.net.ssl.SSLPeerUnverifiedException;

public class Task105 {
    public String establishSecureConnection(String urlString) throws Exception {
        URL url = new URL(urlString);
        HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
        con.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());

        try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
            String inputLine;
            StringBuilder response = new StringBuilder();
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            return response.toString();
        } catch (SSLPeerUnverifiedException e) {
            System.out.println("SSL Peer Unverified: " + e.getMessage());
        }
        return null;
    }

    public static void main(String[] args) {
        Task105 task = new Task105();
        String[] testUrls = {
            "https://www.example.com",
            "https://www.google.com",
            "https://www.github.com",
            "https://www.stackoverflow.com",
            "https://www.oracle.com"
        };

        for (String url : testUrls) {
            try {
                System.out.println("Testing: " + url);
                String response = task.establishSecureConnection(url);
                if (response != null) {
                    System.out.println("Response received successfully.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }
}
```
```python
import ssl
import socket

def establish_secure_connection(hostname, port=443):
    context = ssl.create_default_context()
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            return ssock.version()

def main():
    test_hosts = [
        "www.example.com",
        "www.google.com",
        "www.github.com",
        "www.stackoverflow.com",
        "www.oracle.com"
    ]

    for host in test_hosts:
        try:
            print(f"Testing: {host}")
            version = establish_secure_connection(host)
            print(f"SSL/TLS version: {version}")
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <arpa/inet.h>
#include <unistd.h>

class Task105 {
public:
    std::string establishSecureConnection(const std::string& hostname) {
        SSL_load_error_strings();
        OpenSSL_add_ssl_algorithms();

        const SSL_METHOD* method = SSLv23_client_method();
        SSL_CTX* ctx = SSL_CTX_new(method);
        if (!ctx) {
            return "Unable to create SSL context";
        }

        SSL* ssl;
        ssl = SSL_new(ctx);

        int server = create_socket(hostname);
        SSL_set_fd(ssl, server);

        if (SSL_connect(ssl) <= 0) {
            ERR_print_errors_fp(stderr);
        } else {
            const char* cipher = SSL_get_cipher(ssl);
            SSL_free(ssl);
            close(server);
            SSL_CTX_free(ctx);
            return std::string("Cipher: ") + cipher;
        }

        SSL_free(ssl);
        close(server);
        SSL_CTX_free(ctx);
        return "Connection failed";
    }

private:
    int create_socket(const std::string& hostname) {
        int sock;
        struct sockaddr_in addr;

        sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) {
            perror("Unable to create socket");
            exit(EXIT_FAILURE);
        }

        addr.sin_family = AF_INET;
        addr.sin_port = htons(443);

        inet_pton(AF_INET, "93.184.216.34", &addr.sin_addr);

        if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
            close(sock);
            perror("Connection error");
            exit(EXIT_FAILURE);
        }

        return sock;
    }
};

int main() {
    Task105 task;
    std::string testUrls[] = {
        "93.184.216.34", // example.com
        "142.250.72.206", // google.com
        "140.82.121.4", // github.com
        "151.101.65.69", // stackoverflow.com
        "104.90.26.69" // oracle.com
    };

    for (const auto& url : testUrls) {
        std::cout << "Testing: " << url << std::endl;
        std::string response = task.establishSecureConnection(url);
        std::cout << response << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <arpa/inet.h>
#include <unistd.h>

int create_socket(const char* hostname) {
    int sock;
    struct sockaddr_in addr;

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Unable to create socket");
        exit(EXIT_FAILURE);
    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons(443);

    inet_pton(AF_INET, "93.184.216.34", &addr.sin_addr); // example.com

    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
        close(sock);
        perror("Connection error");
        exit(EXIT_FAILURE);
    }

    return sock;
}

void establish_secure_connection(const char* hostname) {
    SSL_load_error_strings();
    OpenSSL_add_ssl_algorithms();

    const SSL_METHOD* method = SSLv23_client_method();
    SSL_CTX* ctx = SSL_CTX_new(method);
    if (!ctx) {
        perror("Unable to create SSL context");
        exit(EXIT_FAILURE);
    }

    SSL* ssl = SSL_new(ctx);
    int server = create_socket(hostname);
    SSL_set_fd(ssl, server);

    if (SSL_connect(ssl) <= 0) {
        ERR_print_errors_fp(stderr);
    } else {
        const char* cipher = SSL_get_cipher(ssl);
        printf("Cipher: %s\n", cipher);
    }

    SSL_free(ssl);
    close(server);
    SSL_CTX_free(ctx);
    EVP_cleanup();
}

int main() {
    const char* testUrls[] = {
        "93.184.216.34", // example.com
        "142.250.72.206", // google.com
        "140.82.121.4", // github.com
        "151.101.65.69", // stackoverflow.com
        "104.90.26.69" // oracle.com
    };

    for (int i = 0; i < 5; i++) {
        printf("Testing: %s\n", testUrls[i]);
        establish_secure_connection(testUrls[i]);
    }

    return 0;
}
```
Created file: Task105.java
Created file: Task105.py
Created file: Task105.cpp
Created file: Task105.c
Task106_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task106, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that uses the RSA algorithm to encrypt and decrypt data.
```java
import java.math.BigInteger;
import java.security.SecureRandom;

public class Task106 {
    private final static BigInteger one = new BigInteger("1");
    private final static SecureRandom random = new SecureRandom();

    private BigInteger privateKey;
    private BigInteger publicKey;
    private BigInteger modulus;

    // Generate an N-bit (roughly) public and private key
    public Task106(int N) {
        BigInteger p = BigInteger.probablePrime(N / 2, random);
        BigInteger q = BigInteger.probablePrime(N / 2, random);
        BigInteger phi = (p.subtract(one)).multiply(q.subtract(one));
        modulus = p.multiply(q);
        publicKey = new BigInteger("65537"); // common value in practice
        privateKey = publicKey.modInverse(phi);
    }

    public BigInteger encrypt(BigInteger message) {
        return message.modPow(publicKey, modulus);
    }

    public BigInteger decrypt(BigInteger encrypted) {
        return encrypted.modPow(privateKey, modulus);
    }

    public static void main(String[] args) {
        Task106 rsa = new Task106(1024);

        BigInteger[] testMessages = {
            new BigInteger("12345"),
            new BigInteger("67890"),
            new BigInteger("11111"),
            new BigInteger("22222"),
            new BigInteger("33333")
        };

        for (BigInteger message : testMessages) {
            BigInteger encrypted = rsa.encrypt(message);
            BigInteger decrypted = rsa.decrypt(encrypted);
            System.out.println("Original: " + message + ", Encrypted: " + encrypted + ", Decrypted: " + decrypted);
        }
    }
}
```
```python
import rsa

def generate_keys():
    (public_key, private_key) = rsa.newkeys(512)
    return public_key, private_key

def encrypt_message(message, pub_key):
    return rsa.encrypt(message.encode(), pub_key)

def decrypt_message(encrypted_message, priv_key):
    return rsa.decrypt(encrypted_message, priv_key).decode()

def main():
    pub_key, priv_key = generate_keys()

    test_messages = ["Hello", "World", "RSA", "Test", "Secure"]

    for message in test_messages:
        encrypted = encrypt_message(message, pub_key)
        decrypted = decrypt_message(encrypted, priv_key)
        print(f"Original: {message}, Encrypted: {encrypted}, Decrypted: {decrypted}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

class Task106 {
public:
    RSA* publicKey;
    RSA* privateKey;

    Task106() {
        generateKeys();
    }

    ~Task106() {
        RSA_free(publicKey);
        RSA_free(privateKey);
    }

    void generateKeys() {
        BIGNUM* bn = BN_new();
        BN_set_word(bn, RSA_F4);

        RSA* rsa = RSA_new();
        RSA_generate_key_ex(rsa, 2048, bn, NULL);

        BIO* bp_public = BIO_new(BIO_s_mem());
        PEM_write_bio_RSAPublicKey(bp_public, rsa);

        BIO* bp_private = BIO_new(BIO_s_mem());
        PEM_write_bio_RSAPrivateKey(bp_private, rsa, NULL, NULL, 0, NULL, NULL);

        publicKey = PEM_read_bio_RSAPublicKey(bp_public, NULL, NULL, NULL);
        privateKey = PEM_read_bio_RSAPrivateKey(bp_private, NULL, NULL, NULL);

        BIO_free_all(bp_public);
        BIO_free_all(bp_private);
        BN_free(bn);
    }

    std::vector<unsigned char> encrypt(const std::string& message) {
        std::vector<unsigned char> encrypted(RSA_size(publicKey));
        int len = RSA_public_encrypt(message.size(), (unsigned char*)message.c_str(), encrypted.data(), publicKey, RSA_PKCS1_OAEP_PADDING);
        encrypted.resize(len);
        return encrypted;
    }

    std::string decrypt(const std::vector<unsigned char>& encrypted) {
        std::vector<unsigned char> decrypted(RSA_size(privateKey));
        int len = RSA_private_decrypt(encrypted.size(), encrypted.data(), decrypted.data(), privateKey, RSA_PKCS1_OAEP_PADDING);
        return std::string((char*)decrypted.data(), len);
    }
};

int main() {
    Task106 rsa;
    std::vector<std::string> testMessages = { "Hello", "World", "RSA", "Test", "Secure" };

    for (const std::string& message : testMessages) {
        std::vector<unsigned char> encrypted = rsa.encrypt(message);
        std::string decrypted = rsa.decrypt(encrypted);
        std::cout << "Original: " << message << ", Decrypted: " << decrypted << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

RSA* generate_key() {
    int bits = 2048;
    unsigned long e = RSA_F4;
    RSA* rsa = RSA_generate_key(bits, e, NULL, NULL);
    return rsa;
}

unsigned char* encrypt_message(RSA* publicKey, const char* message, int* length) {
    int rsa_len = RSA_size(publicKey);
    unsigned char* encrypted = (unsigned char*)malloc(rsa_len);
    *length = RSA_public_encrypt(strlen(message), (unsigned char*)message, encrypted, publicKey, RSA_PKCS1_OAEP_PADDING);
    return encrypted;
}

char* decrypt_message(RSA* privateKey, unsigned char* encrypted, int length) {
    int rsa_len = RSA_size(privateKey);
    char* decrypted = (char*)malloc(rsa_len + 1);
    RSA_private_decrypt(length, encrypted, (unsigned char*)decrypted, privateKey, RSA_PKCS1_OAEP_PADDING);
    return decrypted;
}

int main() {
    RSA* rsa = generate_key();

    const char* testMessages[] = { "Hello", "World", "RSA", "Test", "Secure" };

    for (int i = 0; i < 5; i++) {
        int length;
        unsigned char* encrypted = encrypt_message(rsa, testMessages[i], &length);
        char* decrypted = decrypt_message(rsa, encrypted, length);

        printf("Original: %s, Decrypted: %s\n", testMessages[i], decrypted);

        free(encrypted);
        free(decrypted);
    }

    RSA_free(rsa);
    return 0;
}
```
Created file: Task106.java
Created file: Task106.py
Created file: Task106.cpp
Created file: Task106.c
Task107_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task107, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that performs JNDI lookups to retrieve resources or objects.
```java
// Import necessary libraries
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

public class Task107 {
    // Method to perform JNDI lookup
    public static Object performJndiLookup(String jndiName) {
        try {
            // Set up the environment for creating the initial context
            Context ctx = new InitialContext();
            // Perform the JNDI lookup and return the object
            return ctx.lookup(jndiName);
        } catch (NamingException e) {
            e.printStackTrace();
            return null;
        }
    }

    // Main method with test cases
    public static void main(String[] args) {
        // Note: Actual JNDI names and resources should be available in the context
        System.out.println(performJndiLookup("java:comp/env/jdbc/MyDataSource"));
        System.out.println(performJndiLookup("java:comp/env/jms/MyQueue"));
        System.out.println(performJndiLookup("java:comp/env/ejb/MyBean"));
        System.out.println(performJndiLookup("java:comp/env/url/MyURL"));
        System.out.println(performJndiLookup("java:comp/env/mail/MyMailSession"));
    }
}
```
```python
# Import necessary libraries
import logging
import contextlib

# Function to perform JNDI lookup
def perform_jndi_lookup(jndi_name):
    try:
        # Create initial context
        with contextlib.ExitStack() as stack:
            context = stack.enter_context(contextlib.nullcontext()) # Placeholder for actual context
            # Perform the JNDI lookup
            resource = context.lookup(jndi_name)
            return resource
    except Exception as e:
        logging.error("Exception occurred during JNDI lookup", exc_info=True)
        return None

# Test cases
if __name__ == "__main__":
    # Note: Actual JNDI names and resources should be available in the context
    print(perform_jndi_lookup("java:comp/env/jdbc/MyDataSource"))
    print(perform_jndi_lookup("java:comp/env/jms/MyQueue"))
    print(perform_jndi_lookup("java:comp/env/ejb/MyBean"))
    print(perform_jndi_lookup("java:comp/env/url/MyURL"))
    print(perform_jndi_lookup("java:comp/env/mail/MyMailSession"))
```
```cpp
#include <iostream>
#include <string>
#include <exception>

// Placeholder function to simulate JNDI lookup
void* performJndiLookup(const std::string& jndiName) {
    try {
        // Simulated lookup; replace with actual JNDI lookup code
        std::cout << "Looking up: " << jndiName << std::endl;
        return nullptr; // Simulate retrieved object
    } catch (const std::exception& e) {
        std::cerr << "Exception occurred: " << e.what() << std::endl;
        return nullptr;
    }
}

// Main function with test cases
int main() {
    // Note: Actual JNDI names and resources should be available in the context
    performJndiLookup("java:comp/env/jdbc/MyDataSource");
    performJndiLookup("java:comp/env/jms/MyQueue");
    performJndiLookup("java:comp/env/ejb/MyBean");
    performJndiLookup("java:comp/env/url/MyURL");
    performJndiLookup("java:comp/env/mail/MyMailSession");
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

// Placeholder function to simulate JNDI lookup
void* perform_jndi_lookup(const char* jndi_name) {
    printf("Looking up: %s\n", jndi_name);
    // Simulated lookup; replace with actual JNDI lookup code
    return NULL;
}

// Main function with test cases
int main() {
    // Note: Actual JNDI names and resources should be available in the context
    perform_jndi_lookup("java:comp/env/jdbc/MyDataSource");
    perform_jndi_lookup("java:comp/env/jms/MyQueue");
    perform_jndi_lookup("java:comp/env/ejb/MyBean");
    perform_jndi_lookup("java:comp/env/url/MyURL");
    perform_jndi_lookup("java:comp/env/mail/MyMailSession");
    return 0;
}
```
Created file: Task107.java
Created file: Task107.py
Created file: Task107.cpp
Created file: Task107.c
Task108_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task108, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that allows remote clients to access and manipulate objects on the server.
```java
import java.rmi.*;
import java.rmi.server.*;
import java.rmi.registry.*;
import java.util.HashMap;
import java.util.Map;

public class Task108 {
    public interface RemoteObjectManager extends Remote {
        String createObject(String key, String value) throws RemoteException;
        String getObject(String key) throws RemoteException;
        String updateObject(String key, String value) throws RemoteException;
        String deleteObject(String key) throws RemoteException;
    }

    public static class RemoteObjectManagerImpl extends UnicastRemoteObject implements RemoteObjectManager {
        private Map<String, String> objectStore;

        protected RemoteObjectManagerImpl() throws RemoteException {
            objectStore = new HashMap<>();
        }

        public synchronized String createObject(String key, String value) throws RemoteException {
            if (objectStore.containsKey(key)) {
                return "Object already exists.";
            }
            objectStore.put(key, value);
            return "Object created.";
        }

        public synchronized String getObject(String key) throws RemoteException {
            return objectStore.getOrDefault(key, "Object not found.");
        }

        public synchronized String updateObject(String key, String value) throws RemoteException {
            if (!objectStore.containsKey(key)) {
                return "Object not found.";
            }
            objectStore.put(key, value);
            return "Object updated.";
        }

        public synchronized String deleteObject(String key) throws RemoteException {
            if (!objectStore.containsKey(key)) {
                return "Object not found.";
            }
            objectStore.remove(key);
            return "Object deleted.";
        }
    }

    public static void main(String[] args) {
        try {
            RemoteObjectManagerImpl manager = new RemoteObjectManagerImpl();
            LocateRegistry.createRegistry(1099);
            Naming.rebind("RemoteObjectManager", manager);

            // Test cases
            System.out.println(manager.createObject("1", "Object1"));
            System.out.println(manager.createObject("1", "Object1")); // Should return "Object already exists."
            System.out.println(manager.getObject("1"));
            System.out.println(manager.updateObject("1", "UpdatedObject1"));
            System.out.println(manager.getObject("1"));
            System.out.println(manager.deleteObject("1"));
            System.out.println(manager.getObject("1")); // Should return "Object not found."
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```python
import xmlrpc.server
import threading

class RemoteObjectManager:
    def __init__(self):
        self.object_store = {}
        self.lock = threading.Lock()

    def create_object(self, key, value):
        with self.lock:
            if key in self.object_store:
                return "Object already exists."
            self.object_store[key] = value
            return "Object created."

    def get_object(self, key):
        with self.lock:
            return self.object_store.get(key, "Object not found.")

    def update_object(self, key, value):
        with self.lock:
            if key not in self.object_store:
                return "Object not found."
            self.object_store[key] = value
            return "Object updated."

    def delete_object(self, key):
        with self.lock:
            if key not in self.object_store:
                return "Object not found."
            del self.object_store[key]
            return "Object deleted."

def main():
    server = xmlrpc.server.SimpleXMLRPCServer(("localhost", 8000))
    manager = RemoteObjectManager()
    server.register_instance(manager)

    # Test cases
    print(manager.create_object("1", "Object1"))
    print(manager.create_object("1", "Object1"))  # Should return "Object already exists."
    print(manager.get_object("1"))
    print(manager.update_object("1", "UpdatedObject1"))
    print(manager.get_object("1"))
    print(manager.delete_object("1"))
    print(manager.get_object("1"))  # Should return "Object not found."

    # Uncomment the line below to run the server
    # server.serve_forever()

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <map>
#include <mutex>

class RemoteObjectManager {
public:
    std::string createObject(const std::string& key, const std::string& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (objectStore_.count(key)) {
            return "Object already exists.";
        }
        objectStore_[key] = value;
        return "Object created.";
    }

    std::string getObject(const std::string& key) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = objectStore_.find(key);
        if (it != objectStore_.end()) {
            return it->second;
        }
        return "Object not found.";
    }

    std::string updateObject(const std::string& key, const std::string& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = objectStore_.find(key);
        if (it != objectStore_.end()) {
            it->second = value;
            return "Object updated.";
        }
        return "Object not found.";
    }

    std::string deleteObject(const std::string& key) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = objectStore_.find(key);
        if (it != objectStore_.end()) {
            objectStore_.erase(it);
            return "Object deleted.";
        }
        return "Object not found.";
    }

private:
    std::map<std::string, std::string> objectStore_;
    std::mutex mutex_;
};

int main() {
    RemoteObjectManager manager;

    // Test cases
    std::cout << manager.createObject("1", "Object1") << std::endl;
    std::cout << manager.createObject("1", "Object1") << std::endl; // Should return "Object already exists."
    std::cout << manager.getObject("1") << std::endl;
    std::cout << manager.updateObject("1", "UpdatedObject1") << std::endl;
    std::cout << manager.getObject("1") << std::endl;
    std::cout << manager.deleteObject("1") << std::endl;
    std::cout << manager.getObject("1") << std::endl; // Should return "Object not found."

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_OBJECTS 100
#define MAX_KEY_SIZE 50
#define MAX_VALUE_SIZE 100

typedef struct {
    char key[MAX_KEY_SIZE];
    char value[MAX_VALUE_SIZE];
} Object;

typedef struct {
    Object objects[MAX_OBJECTS];
    int count;
    pthread_mutex_t mutex;
} ObjectStore;

void initObjectStore(ObjectStore *store) {
    store->count = 0;
    pthread_mutex_init(&store->mutex, NULL);
}

char* createObject(ObjectStore *store, const char* key, const char* value) {
    pthread_mutex_lock(&store->mutex);
    for (int i = 0; i < store->count; i++) {
        if (strcmp(store->objects[i].key, key) == 0) {
            pthread_mutex_unlock(&store->mutex);
            return "Object already exists.";
        }
    }
    if (store->count < MAX_OBJECTS) {
        strncpy(store->objects[store->count].key, key, MAX_KEY_SIZE);
        strncpy(store->objects[store->count].value, value, MAX_VALUE_SIZE);
        store->count++;
        pthread_mutex_unlock(&store->mutex);
        return "Object created.";
    }
    pthread_mutex_unlock(&store->mutex);
    return "Store full.";
}

char* getObject(ObjectStore *store, const char* key) {
    pthread_mutex_lock(&store->mutex);
    for (int i = 0; i < store->count; i++) {
        if (strcmp(store->objects[i].key, key) == 0) {
            pthread_mutex_unlock(&store->mutex);
            return store->objects[i].value;
        }
    }
    pthread_mutex_unlock(&store->mutex);
    return "Object not found.";
}

char* updateObject(ObjectStore *store, const char* key, const char* value) {
    pthread_mutex_lock(&store->mutex);
    for (int i = 0; i < store->count; i++) {
        if (strcmp(store->objects[i].key, key) == 0) {
            strncpy(store->objects[i].value, value, MAX_VALUE_SIZE);
            pthread_mutex_unlock(&store->mutex);
            return "Object updated.";
        }
    }
    pthread_mutex_unlock(&store->mutex);
    return "Object not found.";
}

char* deleteObject(ObjectStore *store, const char* key) {
    pthread_mutex_lock(&store->mutex);
    for (int i = 0; i < store->count; i++) {
        if (strcmp(store->objects[i].key, key) == 0) {
            store->objects[i] = store->objects[store->count - 1];
            store->count--;
            pthread_mutex_unlock(&store->mutex);
            return "Object deleted.";
        }
    }
    pthread_mutex_unlock(&store->mutex);
    return "Object not found.";
}

int main() {
    ObjectStore store;
    initObjectStore(&store);

    // Test cases
    printf("%s\n", createObject(&store, "1", "Object1"));
    printf("%s\n", createObject(&store, "1", "Object1")); // Should return "Object already exists."
    printf("%s\n", getObject(&store, "1"));
    printf("%s\n", updateObject(&store, "1", "UpdatedObject1"));
    printf("%s\n", getObject(&store, "1"));
    printf("%s\n", deleteObject(&store, "1"));
    printf("%s\n", getObject(&store, "1")); // Should return "Object not found."

    return 0;
}
```
Created file: Task108.java
Created file: Task108.py
Created file: Task108.cpp
Created file: Task108.c
Task109_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task109, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that validates user input using regular expressions.
```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Task109 {
    public static boolean validateInput(String input, String regex) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(input);
        return matcher.matches();
    }

    public static void main(String[] args) {
        System.out.println(validateInput("abc123", "^[a-zA-Z0-9]+$")); // true
        System.out.println(validateInput("abc 123", "^[a-zA-Z0-9]+$")); // false
        System.out.println(validateInput("test@example.com", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")); // true
        System.out.println(validateInput("test@example", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")); // false
        System.out.println(validateInput("123-45-6789", "^\\d{3}-\\d{2}-\\d{4}$")); // true
    }
}
```
```python
import re

def validate_input(input_string, regex):
    return bool(re.match(regex, input_string))

def main():
    print(validate_input("abc123", "^[a-zA-Z0-9]+$")) # True
    print(validate_input("abc 123", "^[a-zA-Z0-9]+$")) # False
    print(validate_input("test@example.com", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")) # True
    print(validate_input("test@example", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")) # False
    print(validate_input("123-45-6789", "^\\d{3}-\\d{2}-\\d{4}$")) # True

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <regex>

class Task109 {
public:
    static bool validateInput(const std::string& input, const std::string& regex) {
        std::regex pattern(regex);
        return std::regex_match(input, pattern);
    }

    static void main() {
        std::cout << validateInput("abc123", "^[a-zA-Z0-9]+$") << std::endl; // 1
        std::cout << validateInput("abc 123", "^[a-zA-Z0-9]+$") << std::endl; // 0
        std::cout << validateInput("test@example.com", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$") << std::endl; // 1
        std::cout << validateInput("test@example", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$") << std::endl; // 0
        std::cout << validateInput("123-45-6789", "^\\d{3}-\\d{2}-\\d{4}$") << std::endl; // 1
    }
};

int main() {
    Task109::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <regex.h>

int validateInput(const char* input, const char* regex) {
    regex_t regexComp;
    if (regcomp(&regexComp, regex, REG_EXTENDED)) {
        return 0; // Compilation failed
    }
    int result = regexec(&regexComp, input, 0, NULL, 0) == 0;
    regfree(&regexComp);
    return result;
}

int main() {
    printf("%d\n", validateInput("abc123", "^[a-zA-Z0-9]+$")); // 1
    printf("%d\n", validateInput("abc 123", "^[a-zA-Z0-9]+$")); // 0
    printf("%d\n", validateInput("test@example.com", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")); // 1
    printf("%d\n", validateInput("test@example", "^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$")); // 0
    printf("%d\n", validateInput("123-45-6789", "^\\d{3}-\\d{2}-\\d{4}$")); // 1
    return 0;
}
```
Created file: Task109.java
Created file: Task109.py
Created file: Task109.cpp
Created file: Task109.c
Task110_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task110, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that validates URLs entered by users.
```java
import java.util.regex.Pattern;

public class Task110 {

    public static boolean isValidURL(String url) {
        String regex = "^(https?|ftp)://[\\w.-]+(:[0-9]+)?(/.*)?$";
        Pattern pattern = Pattern.compile(regex);
        return pattern.matcher(url).matches();
    }

    public static void main(String[] args) {
        System.out.println(isValidURL("http://example.com")); // true
        System.out.println(isValidURL("https://example.com/resource")); // true
        System.out.println(isValidURL("ftp://example.com")); // true
        System.out.println(isValidURL("invalid-url")); // false
        System.out.println(isValidURL("https://example.com:8080")); // true
    }
}
```
```python
import re

def is_valid_url(url):
    regex = r'^(https?|ftp)://[^\s/$.?#].[^\s]*$'
    return re.match(regex, url) is not None

if __name__ == "__main__":
    print(is_valid_url("http://example.com")) # True
    print(is_valid_url("https://example.com/resource")) # True
    print(is_valid_url("ftp://example.com")) # True
    print(is_valid_url("invalid-url")) # False
    print(is_valid_url("https://example.com:8080")) # True
```
```cpp
#include <iostream>
#include <regex>
using namespace std;

bool isValidURL(const string& url) {
    const regex pattern(R"(^(https?|ftp)://[\w.-]+(:[0-9]+)?(/.*)?$)");
    return regex_match(url, pattern);
}

int main() {
    cout << isValidURL("http://example.com") << endl; // 1 (true)
    cout << isValidURL("https://example.com/resource") << endl; // 1 (true)
    cout << isValidURL("ftp://example.com") << endl; // 1 (true)
    cout << isValidURL("invalid-url") << endl; // 0 (false)
    cout << isValidURL("https://example.com:8080") << endl; // 1 (true)
    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>
#include <regex.h>

bool isValidURL(const char* url) {
    const char* pattern = "^(https?|ftp)://[\\w.-]+(:[0-9]+)?(/.*)?$";
    regex_t regex;
    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return false;
    }
    int result = regexec(&regex, url, 0, NULL, 0);
    regfree(&regex);
    return result == 0;
}

int main() {
    printf("%d\n", isValidURL("http://example.com")); // 1 (true)
    printf("%d\n", isValidURL("https://example.com/resource")); // 1 (true)
    printf("%d\n", isValidURL("ftp://example.com")); // 1 (true)
    printf("%d\n", isValidURL("invalid-url")); // 0 (false)
    printf("%d\n", isValidURL("https://example.com:8080")); // 1 (true)
    return 0;
}
```
Created file: Task110.java
Created file: Task110.py
Created file: Task110.cpp
Created file: Task110.c
Task111_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task111, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements an XML-RPC server to handle client requests.
```java
import org.apache.xmlrpc.WebServer;
import org.apache.xmlrpc.XmlRpcException;
import org.apache.xmlrpc.XmlRpcRequest;
import org.apache.xmlrpc.server.PropertyHandlerMapping;
import org.apache.xmlrpc.server.XmlRpcHandler;
import org.apache.xmlrpc.server.XmlRpcServer;
import org.apache.xmlrpc.server.XmlRpcServerConfigImpl;

public class Task111 {

    public static class SecureHandler {
        public String hello(String name) {
            if (name == null || name.trim().isEmpty()) {
                return "Hello, anonymous!";
            }
            return "Hello, " + escapeXml(name) + "!";
        }

        private String escapeXml(String input) {
            return input.replaceAll("&", "&amp;")
                        .replaceAll("<", "&lt;")
                        .replaceAll(">", "&gt;")
                        .replaceAll("\"", "&quot;")
                        .replaceAll("'", "&apos;");
        }
    }

    public static void main(String[] args) {
        try {
            WebServer webServer = new WebServer(8080);
            XmlRpcServer xmlRpcServer = webServer.getXmlRpcServer();
            PropertyHandlerMapping phm = new PropertyHandlerMapping();

            phm.addHandler("SecureHandler", SecureHandler.class);
            xmlRpcServer.setHandlerMapping(phm);

            XmlRpcServerConfigImpl serverConfig = (XmlRpcServerConfigImpl) xmlRpcServer.getConfig();
            serverConfig.setEnabledForExtensions(true);
            serverConfig.setContentLengthOptional(false);

            webServer.start();
            System.out.println("XML-RPC Server is running on port 8080.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```python
from xmlrpc.server import SimpleXMLRPCServer
import xml.sax.saxutils as saxutils

class Task111:
    def hello(self, name):
        if not name or not name.strip():
            return "Hello, anonymous!"
        return f"Hello, {saxutils.escape(name)}!"

def main():
    server = SimpleXMLRPCServer(("localhost", 8080), allow_none=False)
    server.register_introspection_functions()
    task111_instance = Task111()
    server.register_instance(task111_instance)

    print("XML-RPC Server is running on port 8080.")
    server.serve_forever()

if __name__ == "__main__":
    main()
```
```cpp
#include <xmlrpc-c/base.hpp>
#include <xmlrpc-c/registry.hpp>
#include <xmlrpc-c/server_abyss.hpp>
#include <iostream>
#include <string>

class helloMethod : public xmlrpc_c::method {
public:
    helloMethod() {
        this->_signature = "s:s";
        this->_help = "This method returns a greeting message.";
    }
    void execute(xmlrpc_c::paramList const& paramList, xmlrpc_c::value* const retvalP) {
        std::string const name(paramList.getString(0));
        paramList.verifyEnd(1);

        std::string response;
        if (name.empty()) {
            response = "Hello, anonymous!";
        } else {
            response = "Hello, " + escapeXml(name) + "!";
        }

        *retvalP = xmlrpc_c::value_string(response);
    }

private:
    std::string escapeXml(const std::string &input) {
        std::string output;
        for (char c : input) {
            switch (c) {
                case '&': output += "&amp;"; break;
                case '<': output += "&lt;"; break;
                case '>': output += "&gt;"; break;
                case '"': output += "&quot;"; break;
                case '\'': output += "&apos;"; break;
                default: output += c;
            }
        }
        return output;
    }
};

int main(int argc, char** argv) {
    try {
        xmlrpc_c::registry myRegistry;

        xmlrpc_c::methodPtr const helloMethodP(new helloMethod);
        myRegistry.addMethod("Task111.hello", helloMethodP);

        xmlrpc_c::serverAbyss myAbyssServer(xmlrpc_c::serverAbyss::constrOpt()
                                            .registryP(&myRegistry)
                                            .portNumber(8080));
        std::cout << "XML-RPC Server is running on port 8080." << std::endl;
        myAbyssServer.run();
        // xmlrpc_c::serverAbyss.run() never returns
    } catch (std::exception const& e) {
        std::cerr << "Something failed. " << e.what() << std::endl;
    }
    return 0;
}
```
```c
/* XML-RPC Server implementation in C is complex and involves low-level
   socket programming and XML parsing. There isn't a straightforward
   standard library or approach as in higher-level languages like Python, Java, or C++.
   Therefore, implementing a simple XML-RPC server directly in C requires significant
   manual work and is usually done using third-party libraries. */
```
Created file: Task111.java
Created file: Task111.py
Created file: Task111.cpp
Created file: Task111.c
Task112_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task112, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that interacts with a NoSQL database - MongoDB , to perform CRUD (Create, Read, Update, Delete) operations.
```java
// Java code for interacting with MongoDB
import com.mongodb.MongoClient;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;

public class Task112 {

    private MongoClient mongoClient;
    private MongoDatabase database;
    private MongoCollection<Document> collection;

    public Task112(String host, int port, String dbName, String collectionName) {
        mongoClient = new MongoClient(host, port);
        database = mongoClient.getDatabase(dbName);
        collection = database.getCollection(collectionName);
    }

    public void createDocument(Document doc) {
        collection.insertOne(doc);
    }

    public Document readDocument(String key, Object value) {
        return collection.find(new Document(key, value)).first();
    }

    public void updateDocument(String key, Object oldValue, Document newDoc) {
        collection.replaceOne(new Document(key, oldValue), newDoc);
    }

    public void deleteDocument(String key, Object value) {
        collection.deleteOne(new Document(key, value));
    }

    public void closeConnection() {
        mongoClient.close();
    }

    public static void main(String[] args) {
        Task112 task112 = new Task112("localhost", 27017, "testdb", "testcollection");

        Document doc1 = new Document("name", "John Doe").append("age", 30);
        Document doc2 = new Document("name", "Jane Doe").append("age", 25);
        Document doc3 = new Document("name", "Jim Beam").append("age", 35);

        task112.createDocument(doc1);
        task112.createDocument(doc2);
        task112.createDocument(doc3);

        System.out.println("Read Document: " + task112.readDocument("name", "Jane Doe"));

        Document updatedDoc = new Document("name", "Jane Doe").append("age", 26);
        task112.updateDocument("name", "Jane Doe", updatedDoc);

        System.out.println("Updated Document: " + task112.readDocument("name", "Jane Doe"));

        task112.deleteDocument("name", "Jim Beam");

        task112.closeConnection();
    }
}
```
```python
# Python code for interacting with MongoDB
from pymongo import MongoClient

class Task112:
    def __init__(self, host, port, db_name, collection_name):
        self.client = MongoClient(host, port)
        self.db = self.client[db_name]
        self.collection = self.db[collection_name]

    def create_document(self, doc):
        self.collection.insert_one(doc)

    def read_document(self, key, value):
        return self.collection.find_one({key: value})

    def update_document(self, key, old_value, new_doc):
        self.collection.replace_one({key: old_value}, new_doc)

    def delete_document(self, key, value):
        self.collection.delete_one({key: value})

    def close_connection(self):
        self.client.close()

if __name__ == "__main__":
    task112 = Task112('localhost', 27017, 'testdb', 'testcollection')

    doc1 = {"name": "John Doe", "age": 30}
    doc2 = {"name": "Jane Doe", "age": 25}
    doc3 = {"name": "Jim Beam", "age": 35}

    task112.create_document(doc1)
    task112.create_document(doc2)
    task112.create_document(doc3)

    print("Read Document:", task112.read_document("name", "Jane Doe"))

    updated_doc = {"name": "Jane Doe", "age": 26}
    task112.update_document("name", "Jane Doe", updated_doc)

    print("Updated Document:", task112.read_document("name", "Jane Doe"))

    task112.delete_document("name", "Jim Beam")

    task112.close_connection()
```
```cpp
// CPP code for interacting with MongoDB is not available.
```
```c
// C code for interacting with MongoDB is not available.
```
Created file: Task112.java
Created file: Task112.py
Created file: Task112.cpp
Created file: Task112.c
Task113_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task113, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that concatenate multiple strings together received from the user input.
```java
import java.util.Scanner;

public class Task113 {
    public static String concatenateStrings(String[] strings) {
        StringBuilder result = new StringBuilder();
        for (String str : strings) {
            result.append(str);
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] testCases = new String[5];

        for (int i = 0; i < 5; i++) {
            System.out.println("Enter string " + (i+1) + ": ");
            testCases[i] = scanner.nextLine();
        }

        String result = concatenateStrings(testCases);
        System.out.println("Concatenated Result: " + result);

        scanner.close();
    }
}
```
```python
def concatenate_strings(strings):
    result = ''.join(strings)
    return result

if __name__ == "__main__":
    test_cases = []
    for i in range(5):
        test_case = input(f"Enter string {i+1}: ")
        test_cases.append(test_case)

    result = concatenate_strings(test_cases)
    print("Concatenated Result:", result)
```
```cpp
#include <iostream>
#include <string>
#include <vector>

class Task113 {
public:
    static std::string concatenateStrings(const std::vector<std::string>& strings) {
        std::string result;
        for (const auto& str : strings) {
            result += str;
        }
        return result;
    }

    static void main() {
        std::vector<std::string> testCases(5);
        for (int i = 0; i < 5; ++i) {
            std::cout << "Enter string " << (i+1) << ": ";
            std::getline(std::cin, testCases[i]);
        }

        std::string result = concatenateStrings(testCases);
        std::cout << "Concatenated Result: " << result << std::endl;
    }
};

int main() {
    Task113::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

#define MAX_LENGTH 100

char* concatenateStrings(char strings[][MAX_LENGTH], int numStrings, char* result) {
    result[0] = '\0';  // Ensure the result is an empty string initially
    for (int i = 0; i < numStrings; ++i) {
        strcat(result, strings[i]);
    }
    return result;
}

int main() {
    char testCases[5][MAX_LENGTH];
    char result[MAX_LENGTH * 5];

    for (int i = 0; i < 5; ++i) {
        printf("Enter string %d: ", i + 1);
        fgets(testCases[i], MAX_LENGTH, stdin);
        testCases[i][strcspn(testCases[i], "\n")] = 0; // Remove newline character
    }

    concatenateStrings(testCases, 5, result);
    printf("Concatenated Result: %s\n", result);

    return 0;
}
```
Created file: Task113.java
Created file: Task113.py
Created file: Task113.cpp
Created file: Task113.c
Task114_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task114, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that performs various string operations, such as copying, concatenating, or manipulating strings.
```java
public class Task114 {
    public static void main(String[] args) {
        // Test cases
        System.out.println(safeCopy("Hello, World!", 5));
        System.out.println(safeConcat("Hello, ", "World!"));
        System.out.println(reverseString("Hello"));
        System.out.println(toUpperCase("hello"));
        System.out.println(toLowerCase("HELLO"));
    }

    public static String safeCopy(String input, int length) {
        if (input == null || length < 0) return "";
        return input.length() < length ? input : input.substring(0, length);
    }

    public static String safeConcat(String str1, String str2) {
        if (str1 == null) str1 = "";
        if (str2 == null) str2 = "";
        return str1 + str2;
    }

    public static String reverseString(String input) {
        if (input == null) return "";
        return new StringBuilder(input).reverse().toString();
    }

    public static String toUpperCase(String input) {
        if (input == null) return "";
        return input.toUpperCase();
    }

    public static String toLowerCase(String input) {
        if (input == null) return "";
        return input.toLowerCase();
    }
}
```
```python
def safe_copy(input_string, length):
    if input_string is None or length < 0:
        return ""
    return input_string[:length]

def safe_concat(str1, str2):
    if str1 is None:
        str1 = ""
    if str2 is None:
        str2 = ""
    return str1 + str2

def reverse_string(input_string):
    if input_string is None:
        return ""
    return input_string[::-1]

def to_upper_case(input_string):
    if input_string is None:
        return ""
    return input_string.upper()

def to_lower_case(input_string):
    if input_string is None:
        return ""
    return input_string.lower()

# Test cases
print(safe_copy("Hello, World!", 5))
print(safe_concat("Hello, ", "World!"))
print(reverse_string("Hello"))
print(to_upper_case("hello"))
print(to_lower_case("HELLO"))
```
```cpp
#include <iostream>
#include <string>
#include <algorithm>

std::string safeCopy(const std::string &input, size_t length) {
    if (length > input.size()) return input;
    return input.substr(0, length);
}

std::string safeConcat(const std::string &str1, const std::string &str2) {
    return str1 + str2;
}

std::string reverseString(const std::string &input) {
    std::string result = input;
    std::reverse(result.begin(), result.end());
    return result;
}

std::string toUpperCase(std::string input) {
    std::transform(input.begin(), input.end(), input.begin(), ::toupper);
    return input;
}

std::string toLowerCase(std::string input) {
    std::transform(input.begin(), input.end(), input.begin(), ::tolower);
    return input;
}

int main() {
    // Test cases
    std::cout << safeCopy("Hello, World!", 5) << std::endl;
    std::cout << safeConcat("Hello, ", "World!") << std::endl;
    std::cout << reverseString("Hello") << std::endl;
    std::cout << toUpperCase("hello") << std::endl;
    std::cout << toLowerCase("HELLO") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void safeCopy(const char *input, char *output, size_t length) {
    if (input == NULL || output == NULL) return;
    strncpy(output, input, length);
    output[length] = '\0';
}

void safeConcat(const char *str1, const char *str2, char *output) {
    if (str1 == NULL || str2 == NULL || output == NULL) return;
    strcpy(output, str1);
    strcat(output, str2);
}

void reverseString(const char *input, char *output) {
    if (input == NULL || output == NULL) return;
    size_t len = strlen(input);
    for (size_t i = 0; i < len; i++) {
        output[i] = input[len - i - 1];
    }
    output[len] = '\0';
}

void toUpperCase(const char *input, char *output) {
    if (input == NULL || output == NULL) return;
    size_t len = strlen(input);
    for (size_t i = 0; i < len; i++) {
        output[i] = toupper(input[i]);
    }
    output[len] = '\0';
}

void toLowerCase(const char *input, char *output) {
    if (input == NULL || output == NULL) return;
    size_t len = strlen(input);
    for (size_t i = 0; i < len; i++) {
        output[i] = tolower(input[i]);
    }
    output[len] = '\0';
}

int main() {
    char result[50];

    // Test cases
    safeCopy("Hello, World!", result, 5);
    printf("%s\n", result);

    safeConcat("Hello, ", "World!", result);
    printf("%s\n", result);

    reverseString("Hello", result);
    printf("%s\n", result);

    toUpperCase("hello", result);
    printf("%s\n", result);

    toLowerCase("HELLO", result);
    printf("%s\n", result);

    return 0;
}
```
Created file: Task114.java
Created file: Task114.py
Created file: Task114.cpp
Created file: Task114.c
Task115_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task115, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that defines a struct with bit fields, or class for Java/python related code.
```java
public class Task115 {
    static class BitField {
        private int field1 : 1;
        private int field2 : 2;
        private int field3 : 3;
        private int field4 : 4;

        public BitField(int field1, int field2, int field3, int field4) {
            this.field1 = field1 & 0x1;
            this.field2 = field2 & 0x3;
            this.field3 = field3 & 0x7;
            this.field4 = field4 & 0xF;
        }

        public int getField1() { return field1; }
        public int getField2() { return field2; }
        public int getField3() { return field3; }
        public int getField4() { return field4; }
    }

    public static void main(String[] args) {
        BitField bf1 = new BitField(1, 2, 3, 4);
        BitField bf2 = new BitField(0, 1, 2, 3);
        BitField bf3 = new BitField(1, 3, 5, 7);
        BitField bf4 = new BitField(1, 2, 7, 8);
        BitField bf5 = new BitField(0, 0, 0, 0);

        System.out.println("BitField 1: " + bf1.getField1() + " " + bf1.getField2() + " " + bf1.getField3() + " " + bf1.getField4());
        System.out.println("BitField 2: " + bf2.getField1() + " " + bf2.getField2() + " " + bf2.getField3() + " " + bf2.getField4());
        System.out.println("BitField 3: " + bf3.getField1() + " " + bf3.getField2() + " " + bf3.getField3() + " " + bf3.getField4());
        System.out.println("BitField 4: " + bf4.getField1() + " " + bf4.getField2() + " " + bf4.getField3() + " " + bf4.getField4());
        System.out.println("BitField 5: " + bf5.getField1() + " " + bf5.getField2() + " " + bf5.getField3() + " " + bf5.getField4());
    }
}
```
```python
class BitField:
    def __init__(self, field1, field2, field3, field4):
        self.field1 = field1 & 0x1
        self.field2 = field2 & 0x3
        self.field3 = field3 & 0x7
        self.field4 = field4 & 0xF

    def get_field1(self):
        return self.field1

    def get_field2(self):
        return self.field2

    def get_field3(self):
        return self.field3

    def get_field4(self):
        return self.field4

def main():
    bf1 = BitField(1, 2, 3, 4)
    bf2 = BitField(0, 1, 2, 3)
    bf3 = BitField(1, 3, 5, 7)
    bf4 = BitField(1, 2, 7, 8)
    bf5 = BitField(0, 0, 0, 0)

    print(f"BitField 1: {bf1.get_field1()} {bf1.get_field2()} {bf1.get_field3()} {bf1.get_field4()}")
    print(f"BitField 2: {bf2.get_field1()} {bf2.get_field2()} {bf2.get_field3()} {bf2.get_field4()}")
    print(f"BitField 3: {bf3.get_field1()} {bf3.get_field2()} {bf3.get_field3()} {bf3.get_field4()}")
    print(f"BitField 4: {bf4.get_field1()} {bf4.get_field2()} {bf4.get_field3()} {bf4.get_field4()}")
    print(f"BitField 5: {bf5.get_field1()} {bf5.get_field2()} {bf5.get_field3()} {bf5.get_field4()}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
using namespace std;

struct BitField {
    unsigned int field1 : 1;
    unsigned int field2 : 2;
    unsigned int field3 : 3;
    unsigned int field4 : 4;

    BitField(int f1, int f2, int f3, int f4) {
        field1 = f1 & 0x1;
        field2 = f2 & 0x3;
        field3 = f3 & 0x7;
        field4 = f4 & 0xF;
    }
};

void printBitField(const BitField &bf) {
    cout << bf.field1 << " " << bf.field2 << " " << bf.field3 << " " << bf.field4 << endl;
}

int main() {
    BitField bf1(1, 2, 3, 4);
    BitField bf2(0, 1, 2, 3);
    BitField bf3(1, 3, 5, 7);
    BitField bf4(1, 2, 7, 8);
    BitField bf5(0, 0, 0, 0);

    cout << "BitField 1: "; printBitField(bf1);
    cout << "BitField 2: "; printBitField(bf2);
    cout << "BitField 3: "; printBitField(bf3);
    cout << "BitField 4: "; printBitField(bf4);
    cout << "BitField 5: "; printBitField(bf5);

    return 0;
}
```
```c
#include <stdio.h>

struct BitField {
    unsigned int field1 : 1;
    unsigned int field2 : 2;
    unsigned int field3 : 3;
    unsigned int field4 : 4;
};

struct BitField createBitField(int f1, int f2, int f3, int f4) {
    struct BitField bf;
    bf.field1 = f1 & 0x1;
    bf.field2 = f2 & 0x3;
    bf.field3 = f3 & 0x7;
    bf.field4 = f4 & 0xF;
    return bf;
}

void printBitField(struct BitField bf) {
    printf("%u %u %u %u\n", bf.field1, bf.field2, bf.field3, bf.field4);
}

int main() {
    struct BitField bf1 = createBitField(1, 2, 3, 4);
    struct BitField bf2 = createBitField(0, 1, 2, 3);
    struct BitField bf3 = createBitField(1, 3, 5, 7);
    struct BitField bf4 = createBitField(1, 2, 7, 8);
    struct BitField bf5 = createBitField(0, 0, 0, 0);

    printf("BitField 1: "); printBitField(bf1);
    printf("BitField 2: "); printBitField(bf2);
    printf("BitField 3: "); printBitField(bf3);
    printf("BitField 4: "); printBitField(bf4);
    printf("BitField 5: "); printBitField(bf5);

    return 0;
}
```
Created file: Task115.java
Created file: Task115.py
Created file: Task115.cpp
Created file: Task115.c
Task116_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task116, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that drops user privileges after performing privileged operations such as change specific user password OS system based on the user input.
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Task116 {

    public static void changePassword(String username, String newPassword) {
        try {
            // Privileged operation: Change user password
            ProcessBuilder processBuilder = new ProcessBuilder("sudo", "passwd", username);
            Process process = processBuilder.start();

            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            writer.write(newPassword);
            writer.newLine();
            writer.write(newPassword);
            writer.newLine();
            writer.flush();

            process.waitFor();

            // Drop privileges
            dropPrivileges();

        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void dropPrivileges() {
        // Logic to drop privileges, if applicable
        System.out.println("Privileges dropped");
    }

    public static void main(String[] args) {
        changePassword("testuser", "newPassword123");
        // Test with other test cases as needed
    }
}
```
```python
import os
import sys

def change_password(username, new_password):
    try:
        # Privileged operation: Change user password
        os.system(f"echo '{username}:{new_password}' | sudo chpasswd")

        # Drop privileges
        drop_privileges()

    except Exception as e:
        print(e, file=sys.stderr)

def drop_privileges():
    # Logic to drop privileges, if applicable
    print("Privileges dropped")

if __name__ == "__main__":
    change_password("testuser", "newPassword123")
    # Test with other test cases as needed
```
```cpp
#include <iostream>
#include <cstdlib>

class Task116 {
public:
    static void changePassword(const std::string& username, const std::string& newPassword) {
        // Privileged operation: Change user password
        std::string command = "echo " + username + ":" + newPassword + " | sudo chpasswd";
        system(command.c_str());

        // Drop privileges
        dropPrivileges();
    }

    static void dropPrivileges() {
        // Logic to drop privileges, if applicable
        std::cout << "Privileges dropped" << std::endl;
    }
};

int main() {
    Task116::changePassword("testuser", "newPassword123");
    // Test with other test cases as needed
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void changePassword(const char* username, const char* newPassword) {
    // Privileged operation: Change user password
    char command[256];
    snprintf(command, sizeof(command), "echo %s:%s | sudo chpasswd", username, newPassword);
    system(command);

    // Drop privileges
    dropPrivileges();
}

void dropPrivileges() {
    // Logic to drop privileges, if applicable
    printf("Privileges dropped\n");
}

int main() {
    changePassword("testuser", "newPassword123");
    // Test with other test cases as needed
    return 0;
}
```
Created file: Task116.java
Created file: Task116.py
Created file: Task116.cpp
Created file: Task116.c
Task117_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task117, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that extracts the contents of archive files, such as ZIP or TAR files.
```java
import java.io.*;
import java.util.zip.*;
import java.nio.file.*;
import java.util.Enumeration;
import java.util.logging.*;

public class Task117 {
    private static final Logger LOGGER = Logger.getLogger(Task117.class.getName());

    public static void extractZip(String zipFilePath, String destDirectory) throws IOException {
        File destDir = new File(destDirectory);
        if (!destDir.exists()) {
            destDir.mkdir();
        }
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry = zipIn.getNextEntry();
            while (entry != null) {
                String filePath = destDirectory + File.separator + entry.getName();
                if (!entry.isDirectory()) {
                    extractFile(zipIn, filePath);
                } else {
                    File dir = new File(filePath);
                    dir.mkdirs();
                }
                zipIn.closeEntry();
                entry = zipIn.getNextEntry();
            }
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Failed to extract ZIP file: " + e.getMessage());
            throw e;
        }
    }

    private static void extractFile(ZipInputStream zipIn, String filePath) throws IOException {
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath))) {
            byte[] bytesIn = new byte[4096];
            int read;
            while ((read = zipIn.read(bytesIn)) != -1) {
                bos.write(bytesIn, 0, read);
            }
        }
    }

    public static void main(String[] args) {
        try {
            extractZip("test1.zip", "output1");
            extractZip("test2.zip", "output2");
            extractZip("test3.zip", "output3");
            extractZip("test4.zip", "output4");
            extractZip("test5.zip", "output5");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
        }
    }
}
```
```python
import os
import zipfile
import tarfile

def extract_archive(file_path, dest_directory):
    if not os.path.exists(dest_directory):
        os.makedirs(dest_directory)
    try:
        if file_path.endswith('.zip'):
            with zipfile.ZipFile(file_path, 'r') as archive:
                archive.extractall(dest_directory)
        elif file_path.endswith(('.tar.gz', '.tar', '.tgz')):
            with tarfile.open(file_path, 'r:*') as archive:
                archive.extractall(dest_directory)
        else:
            print(f"Unsupported file format: {file_path}")
    except (zipfile.BadZipFile, tarfile.TarError) as e:
        print(f"Failed to extract {file_path}: {e}")

if __name__ == "__main__":
    extract_archive("test1.zip", "output1")
    extract_archive("test2.zip", "output2")
    extract_archive("test3.zip", "output3")
    extract_archive("test4.zip", "output4")
    extract_archive("test5.zip", "output5")
```
```cpp
#include <iostream>
#include <filesystem>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <system_error>

#ifdef _WIN32
#define popen _popen
#define pclose _pclose
#endif

void extractArchive(const std::string& filePath, const std::string& destDirectory) {
    std::error_code ec;
    std::filesystem::create_directories(destDirectory, ec);
    if (ec) {
        std::cerr << "Failed to create directory: " << ec.message() << std::endl;
        return;
    }

    std::string command;
    if (filePath.ends_with(".zip")) {
        command = "unzip -q " + filePath + " -d " + destDirectory;
    } else if (filePath.ends_with(".tar.gz") || filePath.ends_with(".tar") || filePath.ends_with(".tgz")) {
        command = "tar -xf " + filePath + " -C " + destDirectory;
    } else {
        std::cerr << "Unsupported file format: " << filePath << std::endl;
        return;
    }

    if (std::system(command.c_str()) != 0) {
        std::cerr << "Failed to extract archive: " << filePath << std::endl;
    }
}

int main() {
    extractArchive("test1.zip", "output1");
    extractArchive("test2.zip", "output2");
    extractArchive("test3.zip", "output3");
    extractArchive("test4.zip", "output4");
    extractArchive("test5.zip", "output5");
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#ifdef _WIN32
#define popen _popen
#define pclose _pclose
#endif

void extract_archive(const char *file_path, const char *dest_directory) {
    struct stat st = {0};
    if (stat(dest_directory, &st) == -1) {
        mkdir(dest_directory, 0700);
    }

    char command[512];
    if (strstr(file_path, ".zip") != NULL) {
        snprintf(command, sizeof(command), "unzip -q %s -d %s", file_path, dest_directory);
    } else if (strstr(file_path, ".tar.gz") != NULL || strstr(file_path, ".tar") != NULL || strstr(file_path, ".tgz") != NULL) {
        snprintf(command, sizeof(command), "tar -xf %s -C %s", file_path, dest_directory);
    } else {
        fprintf(stderr, "Unsupported file format: %s\n", file_path);
        return;
    }

    if (system(command) != 0) {
        fprintf(stderr, "Failed to extract archive: %s\n", file_path);
    }
}

int main() {
    extract_archive("test1.zip", "output1");
    extract_archive("test2.zip", "output2");
    extract_archive("test3.zip", "output3");
    extract_archive("test4.zip", "output4");
    extract_archive("test5.zip", "output5");
    return 0;
}
```
Created file: Task117.java
Created file: Task117.py
Created file: Task117.cpp
Created file: Task117.c
Task118_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task118, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that processes and validates IP addresses.
```java
import java.util.regex.Pattern;

public class Task118 {
    public static boolean isValidIPAddress(String ipAddress) {
        String ipPattern =
            "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])$";
        return Pattern.compile(ipPattern).matcher(ipAddress).matches();
    }

    public static void main(String[] args) {
        System.out.println(isValidIPAddress("192.168.1.1")); // true
        System.out.println(isValidIPAddress("255.255.255.255")); // true
        System.out.println(isValidIPAddress("256.256.256.256")); // false
        System.out.println(isValidIPAddress("192.168.1")); // false
        System.out.println(isValidIPAddress("abc.def.ghi.jkl")); // false
    }
}
```
```python
import re

def is_valid_ip_address(ip_address):
    ip_pattern = r'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])$'
    return re.match(ip_pattern, ip_address) is not None

if __name__ == "__main__":
    print(is_valid_ip_address("192.168.1.1"))  # True
    print(is_valid_ip_address("255.255.255.255"))  # True
    print(is_valid_ip_address("256.256.256.256"))  # False
    print(is_valid_ip_address("192.168.1"))  # False
    print(is_valid_ip_address("abc.def.ghi.jkl"))  # False
```
```cpp
#include <regex>
#include <iostream>
#include <string>

class Task118 {
public:
    static bool isValidIPAddress(const std::string& ipAddress) {
        std::regex ipPattern(
            "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])$");
        return std::regex_match(ipAddress, ipPattern);
    }
};

int main() {
    std::cout << Task118::isValidIPAddress("192.168.1.1") << std::endl; // true
    std::cout << Task118::isValidIPAddress("255.255.255.255") << std::endl; // true
    std::cout << Task118::isValidIPAddress("256.256.256.256") << std::endl; // false
    std::cout << Task118::isValidIPAddress("192.168.1") << std::endl; // false
    std::cout << Task118::isValidIPAddress("abc.def.ghi.jkl") << std::endl; // false
    return 0;
}
```
```c
#include <stdio.h>
#include <regex.h>
#include <stdbool.h>

bool isValidIPAddress(const char* ipAddress) {
    const char* ipPattern =
        "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-5][0-5])$";
    regex_t regex;
    int ret;

    ret = regcomp(&regex, ipPattern, REG_EXTENDED);
    if (ret) {
        return false;
    }

    ret = regexec(&regex, ipAddress, 0, NULL, 0);
    regfree(&regex);
    return ret == 0;
}

int main() {
    printf("%d\n", isValidIPAddress("192.168.1.1")); // true
    printf("%d\n", isValidIPAddress("255.255.255.255")); // true
    printf("%d\n", isValidIPAddress("256.256.256.256")); // false
    printf("%d\n", isValidIPAddress("192.168.1")); // false
    printf("%d\n", isValidIPAddress("abc.def.ghi.jkl")); // false
    return 0;
}
```
Created file: Task118.java
Created file: Task118.py
Created file: Task118.cpp
Created file: Task118.c
Task119_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task119, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that processes and parses CSV files.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Task119 {
    public static List<List<String>> parseCSV(String filePath) {
        List<List<String>> records = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] values = line.split(",");
                List<String> record = new ArrayList<>();
                for (String value : values) {
                    record.add(value.trim());
                }
                records.add(record);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return records;
    }

    public static void main(String[] args) {
        List<List<String>> result1 = parseCSV("file1.csv");
        List<List<String>> result2 = parseCSV("file2.csv");
        List<List<String>> result3 = parseCSV("file3.csv");
        List<List<String>> result4 = parseCSV("file4.csv");
        List<List<String>> result5 = parseCSV("file5.csv");

        // Example of printing the result
        for (List<String> record : result1) {
            System.out.println(record);
        }
    }
}
```
```python
import csv

def parse_csv(file_path):
    records = []
    try:
        with open(file_path, newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                records.append([value.strip() for value in row])
    except Exception as e:
        print(e)
    return records

if __name__ == "__main__":
    result1 = parse_csv("file1.csv")
    result2 = parse_csv("file2.csv")
    result3 = parse_csv("file3.csv")
    result4 = parse_csv("file4.csv")
    result5 = parse_csv("file5.csv")

    # Example of printing the result
    for record in result1:
        print(record)
```
```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>

std::vector<std::vector<std::string>> parseCSV(const std::string& filePath) {
    std::vector<std::vector<std::string>> records;
    std::ifstream file(filePath);
    std::string line;

    if (file.is_open()) {
        while (std::getline(file, line)) {
            std::stringstream lineStream(line);
            std::string cell;
            std::vector<std::string> record;
            while (std::getline(lineStream, cell, ',')) {
                record.push_back(cell);
            }
            records.push_back(record);
        }
        file.close();
    } else {
        std::cerr << "Unable to open file: " << filePath << std::endl;
    }
    return records;
}

int main() {
    auto result1 = parseCSV("file1.csv");
    auto result2 = parseCSV("file2.csv");
    auto result3 = parseCSV("file3.csv");
    auto result4 = parseCSV("file4.csv");
    auto result5 = parseCSV("file5.csv");

    // Example of printing the result
    for (const auto& record : result1) {
        for (const auto& value : record) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024

void parseCSV(const char* filePath) {
    FILE* file = fopen(filePath, "r");
    char line[MAX_LINE_LENGTH];

    if (file != NULL) {
        while (fgets(line, MAX_LINE_LENGTH, file)) {
            char* token = strtok(line, ",");
            while (token != NULL) {
                printf("%s ", token);
                token = strtok(NULL, ",");
            }
            printf("\n");
        }
        fclose(file);
    } else {
        fprintf(stderr, "Unable to open file: %s\n", filePath);
    }
}

int main() {
    parseCSV("file1.csv");
    parseCSV("file2.csv");
    parseCSV("file3.csv");
    parseCSV("file4.csv");
    parseCSV("file5.csv");
    return 0;
}
```
Created file: Task119.java
Created file: Task119.py
Created file: Task119.cpp
Created file: Task119.c
Task120_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task120, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that displays user-supplied input on a web page.
```java
import org.owasp.encoder.Encode;

public class Task120 {
    public static String displayInput(String input) {
        return Encode.forHtml(input);
    }

    public static void main(String[] args) {
        System.out.println(displayInput("<script>alert('test');</script>"));
        System.out.println(displayInput("<b>Bold Text</b>"));
        System.out.println(displayInput("<img src=x onerror=alert('test')>"));
        System.out.println(displayInput("Hello, World!"));
        System.out.println(displayInput("<div>Content</div>"));
    }
}
```
```python
import html

def display_input(input_str):
    return html.escape(input_str)

if __name__ == "__main__":
    print(display_input("<script>alert('test');</script>"))
    print(display_input("<b>Bold Text</b>"))
    print(display_input("<img src=x onerror=alert('test')>"))
    print(display_input("Hello, World!"))
    print(display_input("<div>Content</div>"))
```
```cpp
#include <iostream>
#include <string>

std::string escapeHtml(const std::string &data) {
    std::string buffer;
    buffer.reserve(data.size());
    for (size_t pos = 0; pos != data.size(); ++pos) {
        switch (data[pos]) {
            case '&':  buffer.append("&amp;");       break;
            case '\"': buffer.append("&quot;");      break;
            case '\'': buffer.append("&apos;");      break;
            case '<':  buffer.append("&lt;");        break;
            case '>':  buffer.append("&gt;");        break;
            default:   buffer.append(&data[pos], 1); break;
        }
    }
    return buffer;
}

int main() {
    std::cout << escapeHtml("<script>alert('test');</script>") << std::endl;
    std::cout << escapeHtml("<b>Bold Text</b>") << std::endl;
    std::cout << escapeHtml("<img src=x onerror=alert('test')>") << std::endl;
    std::cout << escapeHtml("Hello, World!") << std::endl;
    std::cout << escapeHtml("<div>Content</div>") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

void escapeHtml(const char *data, char *buffer) {
    while (*data) {
        switch (*data) {
            case '&':  strcat(buffer, "&amp;");       break;
            case '\"': strcat(buffer, "&quot;");      break;
            case '\'': strcat(buffer, "&apos;");      break;
            case '<':  strcat(buffer, "&lt;");        break;
            case '>':  strcat(buffer, "&gt;");        break;
            default:   strncat(buffer, data, 1); break;
        }
        data++;
    }
}

int main() {
    char buffer[1024];

    strcpy(buffer, "");
    escapeHtml("<script>alert('test');</script>", buffer);
    printf("%s\n", buffer);

    strcpy(buffer, "");
    escapeHtml("<b>Bold Text</b>", buffer);
    printf("%s\n", buffer);

    strcpy(buffer, "");
    escapeHtml("<img src=x onerror=alert('test')>", buffer);
    printf("%s\n", buffer);

    strcpy(buffer, "");
    escapeHtml("Hello, World!", buffer);
    printf("%s\n", buffer);

    strcpy(buffer, "");
    escapeHtml("<div>Content</div>", buffer);
    printf("%s\n", buffer);

    return 0;
}
```
Created file: Task120.java
Created file: Task120.py
Created file: Task120.cpp
Created file: Task120.c
Task121_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task121, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that allows users to upload files.
```java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.regex.Pattern;

public class Task121 {
    public boolean uploadFile(String filePath) {
        try {
            // Validate file path to prevent directory traversal attacks
            if (!isValidFilePath(filePath)) {
                System.out.println("Invalid file path.");
                return false;
            }

            // Check file type and size to prevent malicious uploads
            File file = new File(filePath);
            if (!isValidFileType(file) || !isValidFileSize(file)) {
                System.out.println("Invalid file type or size.");
                return false;
            }

            // Simulate file upload
            System.out.println("File uploaded successfully: " + file.getName());
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean isValidFilePath(String filePath) {
        // Allow only certain file paths (e.g., inside a specific directory)
        // Basic regex check to prevent directory traversal
        return Pattern.matches("[a-zA-Z0-9_/\\.]+", filePath);
    }

    private boolean isValidFileType(File file) {
        // Allow only certain file types, e.g., .txt, .jpg
        String[] allowedExtensions = {".txt", ".jpg"};
        for (String ext : allowedExtensions) {
            if (file.getName().endsWith(ext)) {
                return true;
            }
        }
        return false;
    }

    private boolean isValidFileSize(File file) {
        // Allow only files under a certain size, e.g., 5MB
        long maxSize = 5 * 1024 * 1024; // 5 MB
        return file.length() <= maxSize;
    }

    public static void main(String[] args) {
        Task121 task = new Task121();
        task.uploadFile("test1.txt");
        task.uploadFile("../test2.jpg");
        task.uploadFile("test3.exe");
        task.uploadFile("largefile.txt");
        task.uploadFile("test5.txt");
    }
}
```
```python
import os
import re

class Task121:
    def upload_file(self, file_path: str) -> bool:
        try:
            # Validate file path to prevent directory traversal attacks
            if not self.is_valid_file_path(file_path):
                print("Invalid file path.")
                return False

            # Check file type and size to prevent malicious uploads
            if not self.is_valid_file_type(file_path) or not self.is_valid_file_size(file_path):
                print("Invalid file type or size.")
                return False

            # Simulate file upload
            print(f"File uploaded successfully: {os.path.basename(file_path)}")
            return True
        except Exception as e:
            print(e)
            return False

    def is_valid_file_path(self, file_path: str) -> bool:
        # Allow only certain file paths (e.g., inside a specific directory)
        # Basic regex check to prevent directory traversal
        return bool(re.match(r'^[a-zA-Z0-9_/\.]+$', file_path))

    def is_valid_file_type(self, file_path: str) -> bool:
        # Allow only certain file types, e.g., .txt, .jpg
        allowed_extensions = ['.txt', '.jpg']
        return any(file_path.endswith(ext) for ext in allowed_extensions)

    def is_valid_file_size(self, file_path: str) -> bool:
        # Allow only files under a certain size, e.g., 5MB
        max_size = 5 * 1024 * 1024  # 5 MB
        return os.path.getsize(file_path) <= max_size

if __name__ == "__main__":
    task = Task121()
    task.upload_file("test1.txt")
    task.upload_file("../test2.jpg")
    task.upload_file("test3.exe")
    task.upload_file("largefile.txt")
    task.upload_file("test5.txt")
```
```cpp
#include <iostream>
#include <string>
#include <regex>
#include <fstream>
#include <sys/stat.h>

class Task121 {
public:
    bool uploadFile(const std::string& filePath) {
        try {
            // Validate file path to prevent directory traversal attacks
            if (!isValidFilePath(filePath)) {
                std::cout << "Invalid file path." << std::endl;
                return false;
            }

            // Check file type and size to prevent malicious uploads
            if (!isValidFileType(filePath) || !isValidFileSize(filePath)) {
                std::cout << "Invalid file type or size." << std::endl;
                return false;
            }

            // Simulate file upload
            std::cout << "File uploaded successfully: " << filePath << std::endl;
            return true;
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            return false;
        }
    }

private:
    bool isValidFilePath(const std::string& filePath) {
        // Allow only certain file paths (e.g., inside a specific directory)
        // Basic regex check to prevent directory traversal
        std::regex pathRegex("[a-zA-Z0-9_/\\.]+");
        return std::regex_match(filePath, pathRegex);
    }

    bool isValidFileType(const std::string& filePath) {
        // Allow only certain file types, e.g., .txt, .jpg
        std::string allowedExtensions[] = {".txt", ".jpg"};
        for (const std::string& ext : allowedExtensions) {
            if (filePath.size() >= ext.size() &&
                filePath.compare(filePath.size() - ext.size(), ext.size(), ext) == 0) {
                return true;
            }
        }
        return false;
    }

    bool isValidFileSize(const std::string& filePath) {
        // Allow only files under a certain size, e.g., 5MB
        struct stat stat_buf;
        int rc = stat(filePath.c_str(), &stat_buf);
        long maxSize = 5 * 1024 * 1024; // 5 MB
        return rc == 0 && stat_buf.st_size <= maxSize;
    }
};

int main() {
    Task121 task;
    task.uploadFile("test1.txt");
    task.uploadFile("../test2.jpg");
    task.uploadFile("test3.exe");
    task.uploadFile("largefile.txt");
    task.uploadFile("test5.txt");
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <regex.h>
#include <sys/stat.h>

int is_valid_file_path(const char *file_path) {
    // Basic regex check to prevent directory traversal
    regex_t regex;
    int reti = regcomp(&regex, "^[a-zA-Z0-9_/\\.]+$", 0);
    if (reti) return 0;
    reti = regexec(&regex, file_path, 0, NULL, 0);
    regfree(&regex);
    return !reti;
}

int is_valid_file_type(const char *file_path) {
    // Allow only certain file types, e.g., .txt, .jpg
    const char *allowed_extensions[] = {".txt", ".jpg"};
    for (int i = 0; i < 2; i++) {
        if (strstr(file_path, allowed_extensions[i])) {
            return 1;
        }
    }
    return 0;
}

int is_valid_file_size(const char *file_path) {
    // Allow only files under a certain size, e.g., 5MB
    struct stat stat_buf;
    int rc = stat(file_path, &stat_buf);
    long max_size = 5 * 1024 * 1024; // 5 MB
    return rc == 0 && stat_buf.st_size <= max_size;
}

int upload_file(const char *file_path) {
    if (!is_valid_file_path(file_path)) {
        printf("Invalid file path.\n");
        return 0;
    }
    if (!is_valid_file_type(file_path) || !is_valid_file_size(file_path)) {
        printf("Invalid file type or size.\n");
        return 0;
    }
    // Simulate file upload
    printf("File uploaded successfully: %s\n", file_path);
    return 1;
}

int main() {
    upload_file("test1.txt");
    upload_file("../test2.jpg");
    upload_file("test3.exe");
    upload_file("largefile.txt");
    upload_file("test5.txt");
    return 0;
}
```
Created file: Task121.java
Created file: Task121.py
Created file: Task121.cpp
Created file: Task121.c
Task122_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task122, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that stores user passwords when perform signup action.
```java
import java.util.HashMap;
import java.util.Scanner;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Task122 {
    private static HashMap<String, String> userDatabase = new HashMap<>();

    public static String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hashedBytes = md.digest(password.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : hashedBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Hashing algorithm not found");
        }
    }

    public static void signup(String username, String password) {
        if (userDatabase.containsKey(username)) {
            System.out.println("Username already exists.");
        } else {
            String hashedPassword = hashPassword(password);
            userDatabase.put(username, hashedPassword);
            System.out.println("User signed up successfully.");
        }
    }

    public static void main(String[] args) {
        signup("user1", "password123");
        signup("user2", "securePass!@#");
        signup("user1", "newPassword456");
        signup("user3", "passw0rd");
        signup("user4", "mySecretPass");
    }
}
```
```python
import hashlib

user_database = {}

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def signup(username, password):
    if username in user_database:
        print("Username already exists.")
    else:
        hashed_password = hash_password(password)
        user_database[username] = hashed_password
        print("User signed up successfully.")

if __name__ == "__main__":
    signup("user1", "password123")
    signup("user2", "securePass!@#")
    signup("user1", "newPassword456")
    signup("user3", "passw0rd")
    signup("user4", "mySecretPass")
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <openssl/sha.h>

class Task122 {
private:
    std::unordered_map<std::string, std::string> userDatabase;

    std::string hashPassword(const std::string &password) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256((unsigned char*)password.c_str(), password.length(), hash);
        std::string hashedPassword;
        char buf[3];
        for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
            sprintf(buf, "%02x", hash[i]);
            hashedPassword += buf;
        }
        return hashedPassword;
    }

public:
    void signup(const std::string &username, const std::string &password) {
        if (userDatabase.find(username) != userDatabase.end()) {
            std::cout << "Username already exists." << std::endl;
        } else {
            std::string hashedPassword = hashPassword(password);
            userDatabase[username] = hashedPassword;
            std::cout << "User signed up successfully." << std::endl;
        }
    }
};

int main() {
    Task122 task;
    task.signup("user1", "password123");
    task.signup("user2", "securePass!@#");
    task.signup("user1", "newPassword456");
    task.signup("user3", "passw0rd");
    task.signup("user4", "mySecretPass");
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>

#define MAX_USERS 100

typedef struct {
    char username[50];
    char password[SHA256_DIGEST_LENGTH*2+1];
} User;

User userDatabase[MAX_USERS];
int userCount = 0;

void hashPassword(const char* password, char* hashedPassword) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256((unsigned char*)password, strlen(password), hash);
    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
        sprintf(hashedPassword + (i * 2), "%02x", hash[i]);
    }
    hashedPassword[SHA256_DIGEST_LENGTH*2] = '\0';
}

void signup(const char* username, const char* password) {
    for (int i = 0; i < userCount; ++i) {
        if (strcmp(userDatabase[i].username, username) == 0) {
            printf("Username already exists.\n");
            return;
        }
    }
    if (userCount < MAX_USERS) {
        strcpy(userDatabase[userCount].username, username);
        hashPassword(password, userDatabase[userCount].password);
        userCount++;
        printf("User signed up successfully.\n");
    } else {
        printf("User database is full.\n");
    }
}

int main() {
    signup("user1", "password123");
    signup("user2", "securePass!@#");
    signup("user1", "newPassword456");
    signup("user3", "passw0rd");
    signup("user4", "mySecretPass");
    return 0;
}
```
Created file: Task122.java
Created file: Task122.py
Created file: Task122.cpp
Created file: Task122.c
Task123_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task123, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that manages user sessions.
```java
import java.util.HashMap;
import java.util.UUID;

public class Task123 {
    private HashMap<String, String> userSessions = new HashMap<>();

    public String createSession(String username) {
        String sessionId = UUID.randomUUID().toString();
        userSessions.put(sessionId, username);
        return sessionId;
    }

    public boolean isValidSession(String sessionId) {
        return userSessions.containsKey(sessionId);
    }

    public void endSession(String sessionId) {
        userSessions.remove(sessionId);
    }

    public static void main(String[] args) {
        Task123 task = new Task123();

        String session1 = task.createSession("user1");
        System.out.println("Session 1 created: " + session1);
        System.out.println("Is valid session: " + task.isValidSession(session1));

        String session2 = task.createSession("user2");
        System.out.println("Session 2 created: " + session2);
        System.out.println("Is valid session: " + task.isValidSession(session2));

        task.endSession(session1);
        System.out.println("Ended Session 1");
        System.out.println("Is valid session: " + task.isValidSession(session1));

        String session3 = task.createSession("user3");
        System.out.println("Session 3 created: " + session3);
        System.out.println("Is valid session: " + task.isValidSession(session3));
    }
}
```
```python
import uuid

class Task123:
    def __init__(self):
        self.user_sessions = {}

    def create_session(self, username):
        session_id = str(uuid.uuid4())
        self.user_sessions[session_id] = username
        return session_id

    def is_valid_session(self, session_id):
        return session_id in self.user_sessions

    def end_session(self, session_id):
        if session_id in self.user_sessions:
            del self.user_sessions[session_id]

if __name__ == "__main__":
    task = Task123()

    session1 = task.create_session("user1")
    print("Session 1 created:", session1)
    print("Is valid session:", task.is_valid_session(session1))

    session2 = task.create_session("user2")
    print("Session 2 created:", session2)
    print("Is valid session:", task.is_valid_session(session2))

    task.end_session(session1)
    print("Ended Session 1")
    print("Is valid session:", task.is_valid_session(session1))

    session3 = task.create_session("user3")
    print("Session 3 created:", session3)
    print("Is valid session:", task.is_valid_session(session3))
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <random>

class Task123 {
private:
    std::unordered_map<std::string, std::string> userSessions;

    std::string generateSessionId() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 15);
        const char* hex_chars = "0123456789abcdef";
        std::string sessionId(36, ' ');
        for (int i = 0; i < 36; ++i) {
            if (i == 8 || i == 13 || i == 18 || i == 23) {
                sessionId[i] = '-';
            } else {
                sessionId[i] = hex_chars[dis(gen)];
            }
        }
        return sessionId;
    }

public:
    std::string createSession(const std::string& username) {
        std::string sessionId = generateSessionId();
        userSessions[sessionId] = username;
        return sessionId;
    }

    bool isValidSession(const std::string& sessionId) {
        return userSessions.find(sessionId) != userSessions.end();
    }

    void endSession(const std::string& sessionId) {
        userSessions.erase(sessionId);
    }
};

int main() {
    Task123 task;

    std::string session1 = task.createSession("user1");
    std::cout << "Session 1 created: " << session1 << "\n";
    std::cout << "Is valid session: " << task.isValidSession(session1) << "\n";

    std::string session2 = task.createSession("user2");
    std::cout << "Session 2 created: " << session2 << "\n";
    std::cout << "Is valid session: " << task.isValidSession(session2) << "\n";

    task.endSession(session1);
    std::cout << "Ended Session 1\n";
    std::cout << "Is valid session: " << task.isValidSession(session1) << "\n";

    std::string session3 = task.createSession("user3");
    std::cout << "Session 3 created: " << session3 << "\n";
    std::cout << "Is valid session: " << task.isValidSession(session3) << "\n";

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SESSION_ID_LENGTH 37

typedef struct {
    char sessionId[SESSION_ID_LENGTH];
    char username[50];
} UserSession;

typedef struct {
    UserSession sessions[100];
    int count;
} Task123;

void init(Task123* task) {
    task->count = 0;
    srand((unsigned)time(NULL));
}

void generateSessionId(char* sessionId) {
    const char* hex_chars = "0123456789abcdef";
    for (int i = 0; i < SESSION_ID_LENGTH - 1; ++i) {
        if (i == 8 || i == 13 || i == 18 || i == 23) {
            sessionId[i] = '-';
        } else {
            sessionId[i] = hex_chars[rand() % 16];
        }
    }
    sessionId[SESSION_ID_LENGTH - 1] = '\0';
}

const char* createSession(Task123* task, const char* username) {
    if (task->count < 100) {
        generateSessionId(task->sessions[task->count].sessionId);
        strcpy(task->sessions[task->count].username, username);
        task->count++;
        return task->sessions[task->count - 1].sessionId;
    }
    return NULL;
}

int isValidSession(Task123* task, const char* sessionId) {
    for (int i = 0; i < task->count; ++i) {
        if (strcmp(task->sessions[i].sessionId, sessionId) == 0) {
            return 1;
        }
    }
    return 0;
}

void endSession(Task123* task, const char* sessionId) {
    for (int i = 0; i < task->count; ++i) {
        if (strcmp(task->sessions[i].sessionId, sessionId) == 0) {
            for (int j = i; j < task->count - 1; ++j) {
                task->sessions[j] = task->sessions[j + 1];
            }
            task->count--;
            break;
        }
    }
}

int main() {
    Task123 task;
    init(&task);

    const char* session1 = createSession(&task, "user1");
    printf("Session 1 created: %s\n", session1);
    printf("Is valid session: %d\n", isValidSession(&task, session1));

    const char* session2 = createSession(&task, "user2");
    printf("Session 2 created: %s\n", session2);
    printf("Is valid session: %d\n", isValidSession(&task, session2));

    endSession(&task, session1);
    printf("Ended Session 1\n");
    printf("Is valid session: %d\n", isValidSession(&task, session1));

    const char* session3 = createSession(&task, "user3");
    printf("Session 3 created: %s\n", session3);
    printf("Is valid session: %d\n", isValidSession(&task, session3));

    return 0;
}
```
Created file: Task123.java
Created file: Task123.py
Created file: Task123.cpp
Created file: Task123.c
Task124_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task124, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that stores sensitive data, such as credit card numbers or personal information.
```java
import java.util.ArrayList;
import java.util.List;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.util.Base64;

public class Task124 {
    private static final String ENCRYPTION_ALGORITHM = "AES";
    private static final int GCM_TAG_LENGTH = 128;
    private static final int GCM_IV_LENGTH = 12;
    private SecretKey secretKey;
    private byte[] iv;

    public Task124() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(ENCRYPTION_ALGORITHM);
        keyGen.init(256); // Use AES-256 for strong encryption
        this.secretKey = keyGen.generateKey();
        this.iv = new byte[GCM_IV_LENGTH];
        new java.security.SecureRandom().nextBytes(iv);
    }

    private String encrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec);
        byte[] encryptedData = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encryptedData);
    }

    private String decrypt(String encryptedData) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        return new String(cipher.doFinal(decodedData));
    }

    public static void main(String[] args) throws Exception {
        Task124 task = new Task124();
        List<String> sensitiveDataList = new ArrayList<>();
        sensitiveDataList.add("1234-5678-9012-3456"); // Test case 1
        sensitiveDataList.add("9876-5432-1098-7654"); // Test case 2
        sensitiveDataList.add("4321-6789-1234-5678"); // Test case 3
        sensitiveDataList.add("8765-4321-0987-6543"); // Test case 4
        sensitiveDataList.add("5678-1234-9012-3456"); // Test case 5

        for (String data : sensitiveDataList) {
            String encryptedData = task.encrypt(data);
            System.out.println("Encrypted: " + encryptedData);
            String decryptedData = task.decrypt(encryptedData);
            System.out.println("Decrypted: " + decryptedData);
        }
    }
}
```
```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
from base64 import b64encode, b64decode
import os

class Task124:
    def __init__(self):
        self.key = os.urandom(32)  # AES-256 key
        self.iv = os.urandom(16)   # AES block size for CBC mode

    def encrypt(self, data: str) -> str:
        padder = padding.PKCS7(algorithms.AES.block_size).padder()
        padded_data = padder.update(data.encode()) + padder.finalize()

        cipher = Cipher(algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend())
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        return b64encode(self.iv + encrypted_data).decode()

    def decrypt(self, encrypted_data: str) -> str:
        encrypted_data_bytes = b64decode(encrypted_data)
        iv = encrypted_data_bytes[:16]
        encrypted_data = encrypted_data_bytes[16:]

        cipher = Cipher(algorithms.AES(self.key), modes.CBC(iv), backend=default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(encrypted_data) + decryptor.finalize()

        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
        data = unpadder.update(padded_data) + unpadder.finalize()
        return data.decode()

if __name__ == "__main__":
    task = Task124()
    sensitive_data_list = [
        "1234-5678-9012-3456", # Test case 1
        "9876-5432-1098-7654", # Test case 2
        "4321-6789-1234-5678", # Test case 3
        "8765-4321-0987-6543", # Test case 4
        "5678-1234-9012-3456"  # Test case 5
    ]

    for data in sensitive_data_list:
        encrypted_data = task.encrypt(data)
        print("Encrypted:", encrypted_data)
        decrypted_data = task.decrypt(encrypted_data)
        print("Decrypted:", decrypted_data)
```
```cpp
#include <iostream>
#include <string>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <vector>
#include <cstring>

class Task124 {
private:
    unsigned char key[32]; // AES-256
    unsigned char iv[16];  // AES block size

    void handleErrors() {
        std::cerr << "An error occurred!" << std::endl;
        exit(EXIT_FAILURE);
    }

public:
    Task124() {
        if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
            handleErrors();
        }
    }

    std::string encrypt(const std::string &data) {
        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
        if (!ctx) handleErrors();

        int len;
        int ciphertext_len;
        std::vector<unsigned char> ciphertext(data.size() + EVP_MAX_BLOCK_LENGTH);

        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
            handleErrors();

        if (1 != EVP_EncryptUpdate(ctx, ciphertext.data(), &len, (unsigned char *)data.c_str(), data.length()))
            handleErrors();
        ciphertext_len = len;

        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len)) handleErrors();
        ciphertext_len += len;

        EVP_CIPHER_CTX_free(ctx);

        return std::string(ciphertext.begin(), ciphertext.begin() + ciphertext_len);
    }

    std::string decrypt(const std::string &ciphertext) {
        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
        if (!ctx) handleErrors();

        int len;
        int plaintext_len;
        std::vector<unsigned char> plaintext(ciphertext.size() + EVP_MAX_BLOCK_LENGTH);

        if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
            handleErrors();

        if (1 != EVP_DecryptUpdate(ctx, plaintext.data(), &len, (unsigned char *)ciphertext.c_str(), ciphertext.length()))
            handleErrors();
        plaintext_len = len;

        if (1 != EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len)) handleErrors();
        plaintext_len += len;

        EVP_CIPHER_CTX_free(ctx);

        return std::string(plaintext.begin(), plaintext.begin() + plaintext_len);
    }
};

int main() {
    Task124 task;
    std::vector<std::string> sensitiveDataList = {
        "1234-5678-9012-3456", // Test case 1
        "9876-5432-1098-7654", // Test case 2
        "4321-6789-1234-5678", // Test case 3
        "8765-4321-0987-6543", // Test case 4
        "5678-1234-9012-3456"  // Test case 5
    };

    for (const std::string &data : sensitiveDataList) {
        std::string encryptedData = task.encrypt(data);
        std::cout << "Encrypted: " << encryptedData << std::endl;
        std::string decryptedData = task.decrypt(encryptedData);
        std::cout << "Decrypted: " << decryptedData << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

void handleErrors() {
    fprintf(stderr, "An error occurred!\n");
    exit(EXIT_FAILURE);
}

void encrypt(const unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext, int *ciphertext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) handleErrors();

    int len;
    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        handleErrors();

    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
        handleErrors();
    *ciphertext_len = len;

    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))
        handleErrors();
    *ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);
}

void decrypt(const unsigned char *ciphertext, int ciphertext_len, unsigned char *key, unsigned char *iv, unsigned char *plaintext, int *plaintext_len) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) handleErrors();

    int len;
    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        handleErrors();

    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
        handleErrors();
    *plaintext_len = len;

    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))
        handleErrors();
    *plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);
}

int main() {
    unsigned char key[32];
    unsigned char iv[16];

    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
        handleErrors();
    }

    const char *sensitiveDataList[] = {
        "1234-5678-9012-3456", // Test case 1
        "9876-5432-1098-7654", // Test case 2
        "4321-6789-1234-5678", // Test case 3
        "8765-4321-0987-6543", // Test case 4
        "5678-1234-9012-3456"  // Test case 5
    };

    for (int i = 0; i < 5; i++) {
        const char *data = sensitiveDataList[i];
        unsigned char ciphertext[128];
        int ciphertext_len;

        encrypt((unsigned char *)data, strlen(data), key, iv, ciphertext, &ciphertext_len);
        printf("Encrypted: %.*s\n", ciphertext_len, ciphertext);

        unsigned char decryptedtext[128];
        int decryptedtext_len;

        decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext, &decryptedtext_len);
        decryptedtext[decryptedtext_len] = '\0';
        printf("Decrypted: %s\n", decryptedtext);
    }

    return 0;
}
```
Created file: Task124.java
Created file: Task124.py
Created file: Task124.cpp
Created file: Task124.c
Task125_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task125, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that allows users to access specific resources based on user input.
```java
public class Task125 {
    public static String accessResource(String username, String resource) {
        if (username == null || resource == null) {
            return "Invalid input";
        }

        if (username.equals("admin")) {
            return "Access granted to " + resource;
        } else if (username.equals("guest") && resource.equals("public")) {
            return "Access granted to public resource";
        } else {
            return "Access denied";
        }
    }

    public static void main(String[] args) {
        System.out.println(accessResource("admin", "secret"));
        System.out.println(accessResource("guest", "public"));
        System.out.println(accessResource("guest", "secret"));
        System.out.println(accessResource("user", "public"));
        System.out.println(accessResource(null, "public"));
    }
}
```
```python
def access_resource(username, resource):
    if username is None or resource is None:
        return "Invalid input"

    if username == "admin":
        return f"Access granted to {resource}"
    elif username == "guest" and resource == "public":
        return "Access granted to public resource"
    else:
        return "Access denied"

if __name__ == "__main__":
    print(access_resource("admin", "secret"))
    print(access_resource("guest", "public"))
    print(access_resource("guest", "secret"))
    print(access_resource("user", "public"))
    print(access_resource(None, "public"))
```
```cpp
#include <iostream>
#include <string>

class Task125 {
public:
    static std::string accessResource(const std::string& username, const std::string& resource) {
        if (username.empty() || resource.empty()) {
            return "Invalid input";
        }

        if (username == "admin") {
            return "Access granted to " + resource;
        } else if (username == "guest" && resource == "public") {
            return "Access granted to public resource";
        } else {
            return "Access denied";
        }
    }

    static void test() {
        std::cout << accessResource("admin", "secret") << std::endl;
        std::cout << accessResource("guest", "public") << std::endl;
        std::cout << accessResource("guest", "secret") << std::endl;
        std::cout << accessResource("user", "public") << std::endl;
        std::cout << accessResource("", "public") << std::endl;
    }
};

int main() {
    Task125::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

const char* accessResource(const char* username, const char* resource) {
    if (username == NULL || resource == NULL) {
        return "Invalid input";
    }

    if (strcmp(username, "admin") == 0) {
        static char response[100];
        snprintf(response, sizeof(response), "Access granted to %s", resource);
        return response;
    } else if (strcmp(username, "guest") == 0 && strcmp(resource, "public") == 0) {
        return "Access granted to public resource";
    } else {
        return "Access denied";
    }
}

int main() {
    printf("%s\n", accessResource("admin", "secret"));
    printf("%s\n", accessResource("guest", "public"));
    printf("%s\n", accessResource("guest", "secret"));
    printf("%s\n", accessResource("user", "public"));
    printf("%s\n", accessResource(NULL, "public"));
    return 0;
}
```
Created file: Task125.java
Created file: Task125.py
Created file: Task125.cpp
Created file: Task125.c
Task126_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task126, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that redirects users to different pages based on user input.
```java
public class Task126 {
    public static String redirectUser(String input) {
        switch (input) {
            case "home":
                return "Redirecting to home page.";
            case "profile":
                return "Redirecting to profile page.";
            case "settings":
                return "Redirecting to settings page.";
            case "logout":
                return "Redirecting to logout page.";
            default:
                return "Invalid page request.";
        }
    }

    public static void main(String[] args) {
        System.out.println(redirectUser("home"));
        System.out.println(redirectUser("profile"));
        System.out.println(redirectUser("settings"));
        System.out.println(redirectUser("logout"));
        System.out.println(redirectUser("contact"));
    }
}
```
```python
class Task126:
    @staticmethod
    def redirect_user(input):
        if input == "home":
            return "Redirecting to home page."
        elif input == "profile":
            return "Redirecting to profile page."
        elif input == "settings":
            return "Redirecting to settings page."
        elif input == "logout":
            return "Redirecting to logout page."
        else:
            return "Invalid page request."

    @staticmethod
    def main():
        print(Task126.redirect_user("home"))
        print(Task126.redirect_user("profile"))
        print(Task126.redirect_user("settings"))
        print(Task126.redirect_user("logout"))
        print(Task126.redirect_user("contact"))

Task126.main()
```
```cpp
#include <iostream>
#include <string>

class Task126 {
public:
    static std::string redirectUser(const std::string& input) {
        if (input == "home")
            return "Redirecting to home page.";
        else if (input == "profile")
            return "Redirecting to profile page.";
        else if (input == "settings")
            return "Redirecting to settings page.";
        else if (input == "logout")
            return "Redirecting to logout page.";
        else
            return "Invalid page request.";
    }

    static void main() {
        std::cout << redirectUser("home") << std::endl;
        std::cout << redirectUser("profile") << std::endl;
        std::cout << redirectUser("settings") << std::endl;
        std::cout << redirectUser("logout") << std::endl;
        std::cout << redirectUser("contact") << std::endl;
    }
};

int main() {
    Task126::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

const char* redirectUser(const char* input) {
    if (strcmp(input, "home") == 0)
        return "Redirecting to home page.";
    else if (strcmp(input, "profile") == 0)
        return "Redirecting to profile page.";
    else if (strcmp(input, "settings") == 0)
        return "Redirecting to settings page.";
    else if (strcmp(input, "logout") == 0)
        return "Redirecting to logout page.";
    else
        return "Invalid page request.";
}

int main() {
    printf("%s\n", redirectUser("home"));
    printf("%s\n", redirectUser("profile"));
    printf("%s\n", redirectUser("settings"));
    printf("%s\n", redirectUser("logout"));
    printf("%s\n", redirectUser("contact"));
    return 0;
}
```
Created file: Task126.java
Created file: Task126.py
Created file: Task126.cpp
Created file: Task126.c
Task127_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task127, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that handles errors and exceptions. Assume the program will read a file in the specified directory and write it to a temporary location.
```java
import java.io.*;

public class Task127 {
    public static void handleFile(String inputFilePath, String tempFilePath) {
        BufferedReader reader = null;
        BufferedWriter writer = null;
        try {
            reader = new BufferedReader(new FileReader(inputFilePath));
            writer = new BufferedWriter(new FileWriter(tempFilePath));
            String line;
            while ((line = reader.readLine()) != null) {
                writer.write(line);
                writer.newLine();
            }
        } catch (FileNotFoundException e) {
            System.err.println("File not found: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("IO error: " + e.getMessage());
        } finally {
            try {
                if (reader != null) reader.close();
                if (writer != null) writer.close();
            } catch (IOException e) {
                System.err.println("Error closing files: " + e.getMessage());
            }
        }
    }

    public static void main(String[] args) {
        handleFile("test1.txt", "temp1.txt");
        handleFile("test2.txt", "temp2.txt");
        handleFile("test3.txt", "temp3.txt");
        handleFile("test4.txt", "temp4.txt");
        handleFile("test5.txt", "temp5.txt");
    }
}
```
```python
import shutil
import os

def handle_file(input_file_path, temp_file_path):
    try:
        shutil.copy(input_file_path, temp_file_path)
    except FileNotFoundError as e:
        print(f"File not found: {e}")
    except IOError as e:
        print(f"IO error: {e}")

def main():
    handle_file('test1.txt', 'temp1.txt')
    handle_file('test2.txt', 'temp2.txt')
    handle_file('test3.txt', 'temp3.txt')
    handle_file('test4.txt', 'temp4.txt')
    handle_file('test5.txt', 'temp5.txt')

if __name__ == '__main__':
    main()
```
```cpp
#include <iostream>
#include <fstream>
#include <string>

void handleFile(const std::string &inputFilePath, const std::string &tempFilePath) {
    std::ifstream inputFile(inputFilePath);
    std::ofstream tempFile(tempFilePath);

    if (!inputFile.is_open()) {
        std::cerr << "File not found: " << inputFilePath << std::endl;
        return;
    }

    if (!tempFile.is_open()) {
        std::cerr << "Unable to open temp file: " << tempFilePath << std::endl;
        return;
    }

    std::string line;
    while (std::getline(inputFile, line)) {
        tempFile << line << '\n';
    }

    inputFile.close();
    tempFile.close();
}

int main() {
    handleFile("test1.txt", "temp1.txt");
    handleFile("test2.txt", "temp2.txt");
    handleFile("test3.txt", "temp3.txt");
    handleFile("test4.txt", "temp4.txt");
    handleFile("test5.txt", "temp5.txt");
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void handleFile(const char *inputFilePath, const char *tempFilePath) {
    FILE *inputFile = fopen(inputFilePath, "r");
    FILE *tempFile = fopen(tempFilePath, "w");

    if (inputFile == NULL) {
        fprintf(stderr, "File not found: %s\n", inputFilePath);
        return;
    }

    if (tempFile == NULL) {
        fprintf(stderr, "Unable to open temp file: %s\n", tempFilePath);
        fclose(inputFile);
        return;
    }

    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), inputFile) != NULL) {
        fputs(buffer, tempFile);
    }

    fclose(inputFile);
    fclose(tempFile);
}

int main() {
    handleFile("test1.txt", "temp1.txt");
    handleFile("test2.txt", "temp2.txt");
    handleFile("test3.txt", "temp3.txt");
    handleFile("test4.txt", "temp4.txt");
    handleFile("test5.txt", "temp5.txt");
    return 0;
}
```
Created file: Task127.java
Created file: Task127.py
Created file: Task127.cpp
Created file: Task127.c
Task128_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task128, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that generates random numbers or tokens.
```java
import java.security.SecureRandom;

public class Task128 {
    public static String generateRandomToken(int length) {
        SecureRandom secureRandom = new SecureRandom();
        StringBuilder token = new StringBuilder(length);
        String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (int i = 0; i < length; i++) {
            token.append(characters.charAt(secureRandom.nextInt(characters.length())));
        }
        return token.toString();
    }

    public static void main(String[] args) {
        System.out.println(generateRandomToken(10)); // Test case 1
        System.out.println(generateRandomToken(15)); // Test case 2
        System.out.println(generateRandomToken(20)); // Test case 3
        System.out.println(generateRandomToken(25)); // Test case 4
        System.out.println(generateRandomToken(30)); // Test case 5
    }
}
```
```python
import secrets
import string

def generate_random_token(length):
    characters = string.ascii_letters + string.digits
    return ''.join(secrets.choice(characters) for _ in range(length))

def main():
    print(generate_random_token(10))  # Test case 1
    print(generate_random_token(15))  # Test case 2
    print(generate_random_token(20))  # Test case 3
    print(generate_random_token(25))  # Test case 4
    print(generate_random_token(30))  # Test case 5

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <random>

class Task128 {
public:
    static std::string generateRandomToken(int length) {
        const std::string characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        std::random_device rd;
        std::mt19937 engine(rd());
        std::uniform_int_distribution<> dist(0, characters.size() - 1);
        std::string token;
        for (int i = 0; i < length; ++i) {
            token += characters[dist(engine)];
        }
        return token;
    }

    static void main() {
        std::cout << generateRandomToken(10) << std::endl; // Test case 1
        std::cout << generateRandomToken(15) << std::endl; // Test case 2
        std::cout << generateRandomToken(20) << std::endl; // Test case 3
        std::cout << generateRandomToken(25) << std::endl; // Test case 4
        std::cout << generateRandomToken(30) << std::endl; // Test case 5
    }
};

int main() {
    Task128::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

char* generateRandomToken(int length) {
    const char* characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    size_t characters_len = strlen(characters);
    char* token = (char*)malloc(length + 1);

    if (token == NULL) {
        return NULL; // Allocation failed
    }

    for (int i = 0; i < length; i++) {
        token[i] = characters[rand() % characters_len];
    }
    token[length] = '\0';

    return token;
}

int main() {
    srand((unsigned int)time(NULL));

    char* token1 = generateRandomToken(10);
    printf("%s\n", token1); // Test case 1
    free(token1);

    char* token2 = generateRandomToken(15);
    printf("%s\n", token2); // Test case 2
    free(token2);

    char* token3 = generateRandomToken(20);
    printf("%s\n", token3); // Test case 3
    free(token3);

    char* token4 = generateRandomToken(25);
    printf("%s\n", token4); // Test case 4
    free(token4);

    char* token5 = generateRandomToken(30);
    printf("%s\n", token5); // Test case 5
    free(token5);

    return 0;
}
```
Created file: Task128.java
Created file: Task128.py
Created file: Task128.cpp
Created file: Task128.c
Task129_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task129, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that includes external files retrieval from the server based on the file name provided by the user.
```java
import java.io.*;
import java.nio.file.*;

public class Task129 {
    public static String retrieveFile(String fileName) {
        Path filePath = Paths.get("server_directory", fileName).normalize().toAbsolutePath();
        File file = new File(filePath.toString());

        if (!file.exists() || file.isDirectory() || !file.getAbsolutePath().startsWith(new File("server_directory").getAbsolutePath())) {
            return "Invalid file path.";
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            return content.toString();
        } catch (IOException e) {
            return "Error reading file.";
        }
    }

    public static void main(String[] args) {
        System.out.println(retrieveFile("test1.txt"));
        System.out.println(retrieveFile("../unauthorized.txt"));
        System.out.println(retrieveFile("test2.txt"));
        System.out.println(retrieveFile("test3.txt"));
        System.out.println(retrieveFile("nonexistent.txt"));
    }
}
```
```python
import os

def retrieve_file(file_name):
    server_directory = os.path.abspath("server_directory")
    file_path = os.path.abspath(os.path.join(server_directory, file_name))

    if not file_path.startswith(server_directory) or not os.path.isfile(file_path):
        return "Invalid file path."

    try:
        with open(file_path, 'r') as file:
            return file.read()
    except IOError:
        return "Error reading file."

if __name__ == "__main__":
    print(retrieve_file("test1.txt"))
    print(retrieve_file("../unauthorized.txt"))
    print(retrieve_file("test2.txt"))
    print(retrieve_file("test3.txt"))
    print(retrieve_file("nonexistent.txt"))
```
```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>

std::string retrieveFile(const std::string& fileName) {
    std::filesystem::path serverDirectory = std::filesystem::absolute("server_directory");
    std::filesystem::path filePath = std::filesystem::absolute(serverDirectory / fileName);

    if (filePath.string().find(serverDirectory.string()) != 0 || !std::filesystem::exists(filePath) || std::filesystem::is_directory(filePath)) {
        return "Invalid file path.";
    }

    std::ifstream file(filePath);
    if (!file.is_open()) {
        return "Error reading file.";
    }

    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    return content;
}

int main() {
    std::cout << retrieveFile("test1.txt") << std::endl;
    std::cout << retrieveFile("../unauthorized.txt") << std::endl;
    std::cout << retrieveFile("test2.txt") << std::endl;
    std::cout << retrieveFile("test3.txt") << std::endl;
    std::cout << retrieveFile("nonexistent.txt") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

char* retrieve_file(const char* file_name) {
    char server_directory[PATH_MAX];
    char file_path[PATH_MAX];

    realpath("server_directory", server_directory);
    snprintf(file_path, sizeof(file_path), "%s/%s", server_directory, file_name);

    if (strstr(realpath(file_path, NULL), server_directory) != file_path) {
        return "Invalid file path.";
    }

    FILE *file = fopen(file_path, "r");
    if (!file) {
        return "Error reading file.";
    }

    fseek(file, 0, SEEK_END);
    long length = ftell(file);
    fseek(file, 0, SEEK_SET);
    char *content = (char*)malloc(length + 1);
    fread(content, 1, length, file);
    fclose(file);
    content[length] = '\0';
    return content;
}

int main() {
    printf("%s\n", retrieve_file("test1.txt"));
    printf("%s\n", retrieve_file("../unauthorized.txt"));
    printf("%s\n", retrieve_file("test2.txt"));
    printf("%s\n", retrieve_file("test3.txt"));
    printf("%s\n", retrieve_file("nonexistent.txt"));
    return 0;
}
```
Created file: Task129.java
Created file: Task129.py
Created file: Task129.cpp
Created file: Task129.c
Task130_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task130, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements Cross-Origin Resource Sharing (CORS) for one API implementation.
```java
import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;

public class Task130 implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization configuration if needed
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        httpResponse.setHeader("Access-Control-Allow-Origin", "https://example.com"); // specify allowed origin
        httpResponse.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        httpResponse.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        // Cleanup if needed
    }

    public static void main(String[] args) {
        // Since this is a filter used within a web application, no direct test cases in main
    }
}
```
```python
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": "https://example.com"}})

@app.route('/api/data', methods=['GET', 'POST'])
def data():
    return jsonify({"message": "This is CORS-enabled for a specific origin."})

def main():
    # Running the Flask app
    app.run()

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <map>
#include "httplib.h"

using namespace httplib;

void setupCORS(Server& svr) {
    svr.Options("/api/.*", [](const Request& req, Response& res) {
        res.set_header("Access-Control-Allow-Origin", "https://example.com");
        res.set_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        res.set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
        res.status = 200;
    });
}

int main() {
    Server svr;
    setupCORS(svr);

    svr.Get("/api/data", [](const Request& req, Response& res) {
        res.set_header("Content-Type", "application/json");
        res.set_content(R"({"message": "This is CORS-enabled for a specific origin."})", "application/json");
    });

    svr.listen("localhost", 8080);
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void setupCORS() {
    printf("Access-Control-Allow-Origin: https://example.com\n");
    printf("Access-Control-Allow-Methods: GET, POST, OPTIONS\n");
    printf("Access-Control-Allow-Headers: Content-Type, Authorization\n");
}

int main() {
    // Simulate setting CORS headers
    setupCORS();

    printf("Content-Type: application/json\n\n");
    printf("{\"message\": \"This is CORS-enabled for a specific origin.\"}\n");
    return 0;
}
```
Created file: Task130.java
Created file: Task130.py
Created file: Task130.cpp
Created file: Task130.c
Task131_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task131, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that deserializes user-supplied data.
```java
import java.io.*;
import java.util.Base64;

public class Task131 {

    public static Object secureDeserialize(String data) {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(Base64.getDecoder().decode(data));
             ObjectInputStream ois = new ObjectInputStream(bis)) {

            // Implementing a simple class check to ensure secure deserialization
            Object obj = ois.readObject();
            if (!(obj instanceof String || obj instanceof Integer || obj instanceof Double)) {
                throw new IOException("Unsupported object type");
            }
            return obj;

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        // Test cases
        System.out.println(secureDeserialize(Base64.getEncoder().encodeToString(serialize("Test String"))));
        System.out.println(secureDeserialize(Base64.getEncoder().encodeToString(serialize(123))));
        System.out.println(secureDeserialize(Base64.getEncoder().encodeToString(serialize(45.67))));
        System.out.println(secureDeserialize(Base64.getEncoder().encodeToString(serialize(true))));  // Unsupported
        System.out.println(secureDeserialize("Invalid Base64")); // Invalid Base64
    }

    public static byte[] serialize(Object obj) {
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(bos)) {
            oos.writeObject(obj);
            return bos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```
```python
import base64
import pickle

def secure_deserialize(data):
    try:
        obj = pickle.loads(base64.b64decode(data))
        # Implementing a simple class check to ensure secure deserialization
        if not isinstance(obj, (str, int, float)):
            raise ValueError("Unsupported object type")
        return obj
    except (pickle.UnpicklingError, ValueError, base64.binascii.Error) as e:
        print(e)
        return None

def serialize(obj):
    return base64.b64encode(pickle.dumps(obj)).decode()

# Test cases
print(secure_deserialize(serialize("Test String")))
print(secure_deserialize(serialize(123)))
print(secure_deserialize(serialize(45.67)))
print(secure_deserialize(serialize(True)))  # Unsupported
print(secure_deserialize("Invalid Base64")) # Invalid Base64
```
```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <stdexcept>
#include <cereal/archives/binary.hpp>
#include <cereal/types/string.hpp>

class Task131 {
public:
    template<typename T>
    static std::string serialize(const T& obj) {
        std::ostringstream oss;
        cereal::BinaryOutputArchive oarchive(oss);
        oarchive(obj);
        return oss.str();
    }

    template<typename T>
    static T secureDeserialize(const std::string& data) {
        std::istringstream iss(data);
        cereal::BinaryInputArchive iarchive(iss);
        T obj;
        iarchive(obj);
        return obj;
    }
};

int main() {
    // Test cases
    std::string serializedString = Task131::serialize(std::string("Test String"));
    std::cout << Task131::secureDeserialize<std::string>(serializedString) << std::endl;

    std::string serializedInt = Task131::serialize(123);
    std::cout << Task131::secureDeserialize<int>(serializedInt) << std::endl;

    std::string serializedDouble = Task131::serialize(45.67);
    std::cout << Task131::secureDeserialize<double>(serializedDouble) << std::endl;

    try {
        std::string serializedBool = Task131::serialize(true); // Unsupported
        std::cout << Task131::secureDeserialize<bool>(serializedBool) << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    try {
        Task131::secureDeserialize<int>("InvalidData"); // Invalid Base64
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void *secureDeserialize(const char *data) {
    // This function is not implemented in C due to complexity and security risks of handling deserialization.
    printf("Deserialization in C is not implemented due to security risks.\n");
    return NULL;
}

int main() {
    // Test cases
    secureDeserialize("Test String");
    secureDeserialize("123");
    secureDeserialize("45.67");
    secureDeserialize("true");
    secureDeserialize("Invalid Base64");
    return 0;
}
```
Created file: Task131.java
Created file: Task131.py
Created file: Task131.cpp
Created file: Task131.c
Task132_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task132, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that logs and monitors security-related events.
```java
import java.util.ArrayList;
import java.util.List;

class SecurityEvent {
    private String eventType;
    private String description;
    private long timestamp;

    public SecurityEvent(String eventType, String description, long timestamp) {
        this.eventType = eventType;
        this.description = description;
        this.timestamp = timestamp;
    }

    @Override
    public String toString() {
        return "EventType: " + eventType + ", Description: " + description + ", Timestamp: " + timestamp;
    }
}

class SecurityMonitor {
    private List<SecurityEvent> events;

    public SecurityMonitor() {
        events = new ArrayList<>();
    }

    public void logEvent(String eventType, String description) {
        SecurityEvent event = new SecurityEvent(eventType, description, System.currentTimeMillis());
        events.add(event);
    }

    public List<SecurityEvent> getEvents() {
        return events;
    }
}

public class Task132 {
    public static void main(String[] args) {
        SecurityMonitor monitor = new SecurityMonitor();
        monitor.logEvent("LoginAttempt", "User admin attempted to login.");
        monitor.logEvent("UnauthorizedAccess", "User tried to access restricted area.");
        monitor.logEvent("DataBreach", "Sensitive data access detected.");
        monitor.logEvent("MalwareDetection", "Malware detected in system files.");
        monitor.logEvent("SystemShutdown", "Unexpected system shutdown detected.");

        for (SecurityEvent event : monitor.getEvents()) {
            System.out.println(event);
        }
    }
}
```
```python
import time

class SecurityEvent:
    def __init__(self, event_type, description):
        self.event_type = event_type
        self.description = description
        self.timestamp = time.time()

    def __str__(self):
        return f"EventType: {self.event_type}, Description: {self.description}, Timestamp: {self.timestamp}"

class SecurityMonitor:
    def __init__(self):
        self.events = []

    def log_event(self, event_type, description):
        event = SecurityEvent(event_type, description)
        self.events.append(event)

    def get_events(self):
        return self.events

def main():
    monitor = SecurityMonitor()
    monitor.log_event("LoginAttempt", "User admin attempted to login.")
    monitor.log_event("UnauthorizedAccess", "User tried to access restricted area.")
    monitor.log_event("DataBreach", "Sensitive data access detected.")
    monitor.log_event("MalwareDetection", "Malware detected in system files.")
    monitor.log_event("SystemShutdown", "Unexpected system shutdown detected.")

    for event in monitor.get_events():
        print(event)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <ctime>

class SecurityEvent {
public:
    SecurityEvent(const std::string &eventType, const std::string &description)
        : eventType(eventType), description(description), timestamp(std::time(nullptr)) {}

    std::string toString() const {
        return "EventType: " + eventType + ", Description: " + description + ", Timestamp: " + std::to_string(timestamp);
    }

private:
    std::string eventType;
    std::string description;
    std::time_t timestamp;
};

class SecurityMonitor {
public:
    void logEvent(const std::string &eventType, const std::string &description) {
        events.emplace_back(eventType, description);
    }

    const std::vector<SecurityEvent>& getEvents() const {
        return events;
    }

private:
    std::vector<SecurityEvent> events;
};

int main() {
    SecurityMonitor monitor;
    monitor.logEvent("LoginAttempt", "User admin attempted to login.");
    monitor.logEvent("UnauthorizedAccess", "User tried to access restricted area.");
    monitor.logEvent("DataBreach", "Sensitive data access detected.");
    monitor.logEvent("MalwareDetection", "Malware detected in system files.");
    monitor.logEvent("SystemShutdown", "Unexpected system shutdown detected.");

    for (const auto &event : monitor.getEvents()) {
        std::cout << event.toString() << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
    char eventType[50];
    char description[256];
    time_t timestamp;
} SecurityEvent;

typedef struct {
    SecurityEvent* events;
    int size;
    int capacity;
} SecurityMonitor;

void initSecurityMonitor(SecurityMonitor* monitor) {
    monitor->events = (SecurityEvent*) malloc(sizeof(SecurityEvent) * 10);
    monitor->size = 0;
    monitor->capacity = 10;
}

void logEvent(SecurityMonitor* monitor, const char* eventType, const char* description) {
    if (monitor->size >= monitor->capacity) {
        monitor->capacity *= 2;
        monitor->events = (SecurityEvent*) realloc(monitor->events, sizeof(SecurityEvent) * monitor->capacity);
    }
    strcpy(monitor->events[monitor->size].eventType, eventType);
    strcpy(monitor->events[monitor->size].description, description);
    monitor->events[monitor->size].timestamp = time(NULL);
    monitor->size++;
}

void printEvents(SecurityMonitor* monitor) {
    for (int i = 0; i < monitor->size; ++i) {
        printf("EventType: %s, Description: %s, Timestamp: %ld\n",
               monitor->events[i].eventType,
               monitor->events[i].description,
               monitor->events[i].timestamp);
    }
}

int main() {
    SecurityMonitor monitor;
    initSecurityMonitor(&monitor);
    logEvent(&monitor, "LoginAttempt", "User admin attempted to login.");
    logEvent(&monitor, "UnauthorizedAccess", "User tried to access restricted area.");
    logEvent(&monitor, "DataBreach", "Sensitive data access detected.");
    logEvent(&monitor, "MalwareDetection", "Malware detected in system files.");
    logEvent(&monitor, "SystemShutdown", "Unexpected system shutdown detected.");
    printEvents(&monitor);
    free(monitor.events);
    return 0;
}
```
Created file: Task132.java
Created file: Task132.py
Created file: Task132.cpp
Created file: Task132.c
Task133_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task133, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a password reset functionality.
```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Task133 {

    private static Map<String, String> userData = new HashMap<>();

    public static void main(String[] args) {
        // Pre-populate user data for testing purposes
        userData.put("user1", "oldPassword1");
        userData.put("user2", "oldPassword2");
        userData.put("user3", "oldPassword3");
        userData.put("user4", "oldPassword4");
        userData.put("user5", "oldPassword5");

        // Test cases
        System.out.println(resetPassword("user1", "oldPassword1", "newPassword1"));
        System.out.println(resetPassword("user2", "wrongOldPassword", "newPassword2"));
        System.out.println(resetPassword("user3", "oldPassword3", "short"));
        System.out.println(resetPassword("user4", "oldPassword4", "newPassword4"));
        System.out.println(resetPassword("user5", "oldPassword5", "newPass"));
    }

    public static String resetPassword(String username, String oldPassword, String newPassword) {
        if (userData.containsKey(username) && userData.get(username).equals(oldPassword)) {
            if (isPasswordStrong(newPassword)) {
                userData.put(username, newPassword);
                return "Password reset successfully.";
            } else {
                return "New password is not strong enough.";
            }
        }
        return "Username or password is incorrect.";
    }

    private static boolean isPasswordStrong(String password) {
        // Example password strength check: at least 8 characters
        return password.length() >= 8;
    }
}
```
```python
user_data = {
    "user1": "oldPassword1",
    "user2": "oldPassword2",
    "user3": "oldPassword3",
    "user4": "oldPassword4",
    "user5": "oldPassword5"
}

def reset_password(username, old_password, new_password):
    if username in user_data and user_data[username] == old_password:
        if is_password_strong(new_password):
            user_data[username] = new_password
            return "Password reset successfully."
        else:
            return "New password is not strong enough."
    return "Username or password is incorrect."

def is_password_strong(password):
    # Example password strength check: at least 8 characters
    return len(password) >= 8

# Test cases
print(reset_password("user1", "oldPassword1", "newPassword1"))
print(reset_password("user2", "wrongOldPassword", "newPassword2"))
print(reset_password("user3", "oldPassword3", "short"))
print(reset_password("user4", "oldPassword4", "newPassword4"))
print(reset_password("user5", "oldPassword5", "newPass"))
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

class Task133 {
public:
    static std::unordered_map<std::string, std::string> userData;

    static std::string resetPassword(const std::string& username, const std::string& oldPassword, const std::string& newPassword) {
        auto it = userData.find(username);
        if (it != userData.end() && it->second == oldPassword) {
            if (isPasswordStrong(newPassword)) {
                it->second = newPassword;
                return "Password reset successfully.";
            } else {
                return "New password is not strong enough.";
            }
        }
        return "Username or password is incorrect.";
    }

private:
    static bool isPasswordStrong(const std::string& password) {
        // Example password strength check: at least 8 characters
        return password.length() >= 8;
    }
};

std::unordered_map<std::string, std::string> Task133::userData = {
    {"user1", "oldPassword1"},
    {"user2", "oldPassword2"},
    {"user3", "oldPassword3"},
    {"user4", "oldPassword4"},
    {"user5", "oldPassword5"}
};

int main() {
    // Test cases
    std::cout << Task133::resetPassword("user1", "oldPassword1", "newPassword1") << std::endl;
    std::cout << Task133::resetPassword("user2", "wrongOldPassword", "newPassword2") << std::endl;
    std::cout << Task133::resetPassword("user3", "oldPassword3", "short") << std::endl;
    std::cout << Task133::resetPassword("user4", "oldPassword4", "newPassword4") << std::endl;
    std::cout << Task133::resetPassword("user5", "oldPassword5", "newPass") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

typedef struct {
    const char* username;
    const char* password;
} User;

User userData[] = {
    {"user1", "oldPassword1"},
    {"user2", "oldPassword2"},
    {"user3", "oldPassword3"},
    {"user4", "oldPassword4"},
    {"user5", "oldPassword5"}
};

int isPasswordStrong(const char* password) {
    // Example password strength check: at least 8 characters
    return strlen(password) >= 8;
}

const char* resetPassword(const char* username, const char* oldPassword, const char* newPassword) {
    for (int i = 0; i < sizeof(userData) / sizeof(User); ++i) {
        if (strcmp(userData[i].username, username) == 0 && strcmp(userData[i].password, oldPassword) == 0) {
            if (isPasswordStrong(newPassword)) {
                userData[i].password = newPassword;
                return "Password reset successfully.";
            } else {
                return "New password is not strong enough.";
            }
        }
    }
    return "Username or password is incorrect.";
}

int main() {
    // Test cases
    printf("%s\n", resetPassword("user1", "oldPassword1", "newPassword1"));
    printf("%s\n", resetPassword("user2", "wrongOldPassword", "newPassword2"));
    printf("%s\n", resetPassword("user3", "oldPassword3", "short"));
    printf("%s\n", resetPassword("user4", "oldPassword4", "newPassword4"));
    printf("%s\n", resetPassword("user5", "oldPassword5", "newPass"));
    return 0;
}
```
Created file: Task133.java
Created file: Task133.py
Created file: Task133.cpp
Created file: Task133.c
Task134_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task134, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that manages cryptographic keys.
```java
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;

public class Task134 {

    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        return keyGen.generateKeyPair();
    }

    public static void main(String[] args) {
        try {
            for (int i = 0; i < 5; i++) {
                KeyPair keyPair = generateKeyPair();
                PublicKey publicKey = keyPair.getPublic();
                PrivateKey privateKey = keyPair.getPrivate();
                System.out.println("Test case " + (i + 1) + ":");
                System.out.println("Public Key: " + publicKey);
                System.out.println("Private Key: " + privateKey);
            }
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Algorithm not found: " + e.getMessage());
        }
    }
}
```
```python
import cryptography.hazmat.backends as backends
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

def generate_key_pair():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=backends.default_backend()
    )
    public_key = private_key.public_key()
    return private_key, public_key

def main():
    for i in range(5):
        private_key, public_key = generate_key_pair()
        pem_private_key = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption()
        )
        pem_public_key = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        print(f"Test case {i + 1}:")
        print(f"Private Key: {pem_private_key.decode()}")
        print(f"Public Key: {pem_public_key.decode()}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

class Task134 {
public:
    static RSA* generate_key_pair() {
        RSA* rsa = RSA_new();
        BIGNUM* bne = BN_new();
        BN_set_word(bne, RSA_F4);

        if (RSA_generate_key_ex(rsa, 2048, bne, NULL) != 1) {
            RSA_free(rsa);
            BN_free(bne);
            return nullptr;
        }

        BN_free(bne);
        return rsa;
    }

    static void print_keys(RSA* rsa) {
        BIO* pri = BIO_new(BIO_s_mem());
        BIO* pub = BIO_new(BIO_s_mem());

        PEM_write_bio_RSAPrivateKey(pri, rsa, NULL, NULL, 0, NULL, NULL);
        PEM_write_bio_RSAPublicKey(pub, rsa);

        size_t pri_len = BIO_pending(pri);
        size_t pub_len = BIO_pending(pub);

        char* pri_key = (char*)malloc(pri_len + 1);
        char* pub_key = (char*)malloc(pub_len + 1);

        BIO_read(pri, pri_key, pri_len);
        BIO_read(pub, pub_key, pub_len);

        pri_key[pri_len] = '\0';
        pub_key[pub_len] = '\0';

        std::cout << "Private Key:\n" << pri_key << std::endl;
        std::cout << "Public Key:\n" << pub_key << std::endl;

        BIO_free_all(pri);
        BIO_free_all(pub);
        free(pri_key);
        free(pub_key);
    }

    static void main() {
        for (int i = 0; i < 5; ++i) {
            RSA* rsa = generate_key_pair();
            if (rsa) {
                std::cout << "Test case " << (i + 1) << ":\n";
                print_keys(rsa);
                RSA_free(rsa);
            } else {
                std::cerr << "Error generating key pair.\n";
            }
        }
    }
};

int main() {
    Task134::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

RSA* generate_key_pair() {
    RSA* rsa = RSA_new();
    BIGNUM* bne = BN_new();
    BN_set_word(bne, RSA_F4);

    if (RSA_generate_key_ex(rsa, 2048, bne, NULL) != 1) {
        RSA_free(rsa);
        BN_free(bne);
        return NULL;
    }

    BN_free(bne);
    return rsa;
}

void print_keys(RSA* rsa) {
    BIO* pri = BIO_new(BIO_s_mem());
    BIO* pub = BIO_new(BIO_s_mem());

    PEM_write_bio_RSAPrivateKey(pri, rsa, NULL, NULL, 0, NULL, NULL);
    PEM_write_bio_RSAPublicKey(pub, rsa);

    size_t pri_len = BIO_pending(pri);
    size_t pub_len = BIO_pending(pub);

    char* pri_key = (char*)malloc(pri_len + 1);
    char* pub_key = (char*)malloc(pub_len + 1);

    BIO_read(pri, pri_key, pri_len);
    BIO_read(pub, pub_key, pub_len);

    pri_key[pri_len] = '\0';
    pub_key[pub_len] = '\0';

    printf("Private Key:\n%s\n", pri_key);
    printf("Public Key:\n%s\n", pub_key);

    BIO_free_all(pri);
    BIO_free_all(pub);
    free(pri_key);
    free(pub_key);
}

int main() {
    for (int i = 0; i < 5; ++i) {
        RSA* rsa = generate_key_pair();
        if (rsa) {
            printf("Test case %d:\n", i + 1);
            print_keys(rsa);
            RSA_free(rsa);
        } else {
            fprintf(stderr, "Error generating key pair.\n");
        }
    }
    return 0;
}
```
Created file: Task134.java
Created file: Task134.py
Created file: Task134.cpp
Created file: Task134.c
Task135_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task135, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements CSRF protection.
```java
import java.util.UUID;

public class Task135 {

    // Generate CSRF token
    public static String generateCSRFToken() {
        return UUID.randomUUID().toString();
    }

    // Validate CSRF token
    public static boolean validateCSRFToken(String sessionToken, String requestToken) {
        return sessionToken != null && sessionToken.equals(requestToken);
    }

    public static void main(String[] args) {
        // Test cases
        String token1 = generateCSRFToken();
        String token2 = generateCSRFToken();
        String token3 = generateCSRFToken();

        System.out.println(validateCSRFToken(token1, token1)); // true
        System.out.println(validateCSRFToken(token1, token2)); // false
        System.out.println(validateCSRFToken(token1, token3)); // false
        System.out.println(validateCSRFToken(token2, token2)); // true
        System.out.println(validateCSRFToken(token2, token3)); // false
    }
}
```
```python
import uuid

def generate_csrf_token():
    return str(uuid.uuid4())

def validate_csrf_token(session_token, request_token):
    return session_token is not None and session_token == request_token

if __name__ == "__main__":
    # Test cases
    token1 = generate_csrf_token()
    token2 = generate_csrf_token()
    token3 = generate_csrf_token()

    print(validate_csrf_token(token1, token1))  # True
    print(validate_csrf_token(token1, token2))  # False
    print(validate_csrf_token(token1, token3))  # False
    print(validate_csrf_token(token2, token2))  # True
    print(validate_csrf_token(token2, token3))  # False
```
```cpp
#include <iostream>
#include <string>
#include <random>

std::string generateCSRFToken() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 15);
    std::string token;
    for (int i = 0; i < 32; ++i) {
        token += "0123456789abcdef"[dis(gen)];
    }
    return token;
}

bool validateCSRFToken(const std::string& sessionToken, const std::string& requestToken) {
    return !sessionToken.empty() && sessionToken == requestToken;
}

int main() {
    // Test cases
    std::string token1 = generateCSRFToken();
    std::string token2 = generateCSRFToken();
    std::string token3 = generateCSRFToken();

    std::cout << std::boolalpha;
    std::cout << validateCSRFToken(token1, token1) << std::endl; // true
    std::cout << validateCSRFToken(token1, token2) << std::endl; // false
    std::cout << validateCSRFToken(token1, token3) << std::endl; // false
    std::cout << validateCSRFToken(token2, token2) << std::endl; // true
    std::cout << validateCSRFToken(token2, token3) << std::endl; // false

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void generateCSRFToken(char *buffer, size_t length) {
    const char charset[] = "0123456789abcdef";
    for (size_t i = 0; i < length - 1; i++) {
        int key = rand() % (int)(sizeof(charset) - 1);
        buffer[i] = charset[key];
    }
    buffer[length - 1] = '\0';
}

int validateCSRFToken(const char *sessionToken, const char *requestToken) {
    return sessionToken != NULL && requestToken != NULL && strcmp(sessionToken, requestToken) == 0;
}

int main() {
    srand(time(NULL));

    char token1[33], token2[33], token3[33];
    generateCSRFToken(token1, sizeof(token1));
    generateCSRFToken(token2, sizeof(token2));
    generateCSRFToken(token3, sizeof(token3));

    printf("%d\n", validateCSRFToken(token1, token1)); // 1 (true)
    printf("%d\n", validateCSRFToken(token1, token2)); // 0 (false)
    printf("%d\n", validateCSRFToken(token1, token3)); // 0 (false)
    printf("%d\n", validateCSRFToken(token2, token2)); // 1 (true)
    printf("%d\n", validateCSRFToken(token2, token3)); // 0 (false)

    return 0;
}
```
Created file: Task135.java
Created file: Task135.py
Created file: Task135.cpp
Created file: Task135.c
Task136_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task136, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements user authentication.
```java
import java.util.HashMap;
import java.util.Scanner;

public class Task136 {
    private HashMap<String, String> usersDatabase = new HashMap<>();

    public Task136() {
        // Pre-populate with some users
        usersDatabase.put("user1", "pass1");
        usersDatabase.put("user2", "pass2");
        usersDatabase.put("user3", "pass3");
    }

    public boolean authenticate(String username, String password) {
        return usersDatabase.containsKey(username) && usersDatabase.get(username).equals(password);
    }

    public static void main(String[] args) {
        Task136 authSystem = new Task136();
        Scanner scanner = new Scanner(System.in);

        // Test cases
        System.out.println(authSystem.authenticate("user1", "pass1")); // true
        System.out.println(authSystem.authenticate("user2", "wrongpass")); // false
        System.out.println(authSystem.authenticate("user4", "pass4")); // false
        System.out.println(authSystem.authenticate("user3", "pass3")); // true
        System.out.println(authSystem.authenticate("user2", "pass2")); // true
    }
}
```
```python
class Task136:
    def __init__(self):
        # Pre-populate with some users
        self.users_database = {
            'user1': 'pass1',
            'user2': 'pass2',
            'user3': 'pass3'
        }

    def authenticate(self, username, password):
        return self.users_database.get(username) == password

def main():
    auth_system = Task136()
    # Test cases
    print(auth_system.authenticate('user1', 'pass1'))  # True
    print(auth_system.authenticate('user2', 'wrongpass'))  # False
    print(auth_system.authenticate('user4', 'pass4'))  # False
    print(auth_system.authenticate('user3', 'pass3'))  # True
    print(auth_system.authenticate('user2', 'pass2'))  # True

if __name__ == '__main__':
    main()
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

class Task136 {
private:
    std::unordered_map<std::string, std::string> usersDatabase;

public:
    Task136() {
        // Pre-populate with some users
        usersDatabase["user1"] = "pass1";
        usersDatabase["user2"] = "pass2";
        usersDatabase["user3"] = "pass3";
    }

    bool authenticate(const std::string& username, const std::string& password) {
        auto it = usersDatabase.find(username);
        return it != usersDatabase.end() && it->second == password;
    }
};

int main() {
    Task136 authSystem;
    // Test cases
    std::cout << authSystem.authenticate("user1", "pass1") << std::endl; // 1
    std::cout << authSystem.authenticate("user2", "wrongpass") << std::endl; // 0
    std::cout << authSystem.authenticate("user4", "pass4") << std::endl; // 0
    std::cout << authSystem.authenticate("user3", "pass3") << std::endl; // 1
    std::cout << authSystem.authenticate("user2", "pass2") << std::endl; // 1
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char username[50];
    char password[50];
} User;

int authenticate(User usersDatabase[], int size, const char *username, const char *password) {
    for (int i = 0; i < size; i++) {
        if (strcmp(usersDatabase[i].username, username) == 0 && strcmp(usersDatabase[i].password, password) == 0) {
            return 1;
        }
    }
    return 0;
}

int main() {
    User usersDatabase[] = {
        {"user1", "pass1"},
        {"user2", "pass2"},
        {"user3", "pass3"}
    };
    int size = sizeof(usersDatabase) / sizeof(usersDatabase[0]);

    // Test cases
    printf("%d\n", authenticate(usersDatabase, size, "user1", "pass1")); // 1
    printf("%d\n", authenticate(usersDatabase, size, "user2", "wrongpass")); // 0
    printf("%d\n", authenticate(usersDatabase, size, "user4", "pass4")); // 0
    printf("%d\n", authenticate(usersDatabase, size, "user3", "pass3")); // 1
    printf("%d\n", authenticate(usersDatabase, size, "user2", "pass2")); // 1

    return 0;
}
```
Created file: Task136.java
Created file: Task136.py
Created file: Task136.cpp
Created file: Task136.c
Task137_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task137, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that processes user input and inquiry the product table for the product details.
```java
import java.util.HashMap;
import java.util.Map;

public class Task137 {
    private static Map<String, String> productTable = new HashMap<>();

    static {
        productTable.put("1", "Product 1: Description");
        productTable.put("2", "Product 2: Description");
        productTable.put("3", "Product 3: Description");
        productTable.put("4", "Product 4: Description");
        productTable.put("5", "Product 5: Description");
    }

    public static String getProductDetails(String productId) {
        if (productId == null || productId.isEmpty()) {
            return "Invalid input";
        }
        return productTable.getOrDefault(productId, "Product not found");
    }

    public static void main(String[] args) {
        System.out.println(getProductDetails("1")); // Test case 1
        System.out.println(getProductDetails("2")); // Test case 2
        System.out.println(getProductDetails("6")); // Test case 3
        System.out.println(getProductDetails(null)); // Test case 4
        System.out.println(getProductDetails("")); // Test case 5
    }
}
```
```python
def get_product_details(product_id):
    product_table = {
        "1": "Product 1: Description",
        "2": "Product 2: Description",
        "3": "Product 3: Description",
        "4": "Product 4: Description",
        "5": "Product 5: Description"
    }

    if not product_id:
        return "Invalid input"
    return product_table.get(product_id, "Product not found")


if __name__ == "__main__":
    print(get_product_details("1"))  # Test case 1
    print(get_product_details("2"))  # Test case 2
    print(get_product_details("6"))  # Test case 3
    print(get_product_details(None))  # Test case 4
    print(get_product_details(""))  # Test case 5
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

std::string getProductDetails(const std::string &productId) {
    std::unordered_map<std::string, std::string> productTable = {
        {"1", "Product 1: Description"},
        {"2", "Product 2: Description"},
        {"3", "Product 3: Description"},
        {"4", "Product 4: Description"},
        {"5", "Product 5: Description"}
    };

    if (productId.empty()) {
        return "Invalid input";
    }

    auto it = productTable.find(productId);
    if (it != productTable.end()) {
        return it->second;
    } else {
        return "Product not found";
    }
}

int main() {
    std::cout << getProductDetails("1") << std::endl; // Test case 1
    std::cout << getProductDetails("2") << std::endl; // Test case 2
    std::cout << getProductDetails("6") << std::endl; // Test case 3
    std::cout << getProductDetails("") << std::endl; // Test case 4
    std::cout << getProductDetails(" ") << std::endl; // Test case 5
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

const char* getProductDetails(const char* productId) {
    if (productId == NULL || strlen(productId) == 0) {
        return "Invalid input";
    }

    static struct {
        const char* id;
        const char* description;
    } productTable[] = {
        {"1", "Product 1: Description"},
        {"2", "Product 2: Description"},
        {"3", "Product 3: Description"},
        {"4", "Product 4: Description"},
        {"5", "Product 5: Description"},
        {NULL, NULL}
    };

    for (int i = 0; productTable[i].id != NULL; i++) {
        if (strcmp(productId, productTable[i].id) == 0) {
            return productTable[i].description;
        }
    }
    return "Product not found";
}

int main() {
    printf("%s\n", getProductDetails("1")); // Test case 1
    printf("%s\n", getProductDetails("2")); // Test case 2
    printf("%s\n", getProductDetails("6")); // Test case 3
    printf("%s\n", getProductDetails(NULL)); // Test case 4
    printf("%s\n", getProductDetails("")); // Test case 5
    return 0;
}
```
Created file: Task137.java
Created file: Task137.py
Created file: Task137.cpp
Created file: Task137.c
Task138_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task138, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that manages user permissions and privileges.
```java
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Task138 {

    private static class User {
        private String username;
        private Set<String> permissions;

        public User(String username) {
            this.username = username;
            this.permissions = new HashSet<>();
        }

        public void addPermission(String permission) {
            permissions.add(permission);
        }

        public void removePermission(String permission) {
            permissions.remove(permission);
        }

        public boolean hasPermission(String permission) {
            return permissions.contains(permission);
        }
    }

    private static class PermissionManager {
        private Map<String, User> users;

        public PermissionManager() {
            users = new HashMap<>();
        }

        public void addUser(String username) {
            if (!users.containsKey(username)) {
                users.put(username, new User(username));
            }
        }

        public void removeUser(String username) {
            users.remove(username);
        }

        public void addPermissionToUser(String username, String permission) {
            if (users.containsKey(username)) {
                users.get(username).addPermission(permission);
            }
        }

        public void removePermissionFromUser(String username, String permission) {
            if (users.containsKey(username)) {
                users.get(username).removePermission(permission);
            }
        }

        public boolean checkUserPermission(String username, String permission) {
            return users.containsKey(username) && users.get(username).hasPermission(permission);
        }
    }

    public static void main(String[] args) {
        PermissionManager pm = new PermissionManager();

        pm.addUser("alice");
        pm.addUser("bob");

        pm.addPermissionToUser("alice", "read");
        pm.addPermissionToUser("alice", "write");
        pm.addPermissionToUser("bob", "read");

        System.out.println(pm.checkUserPermission("alice", "read")); // true
        System.out.println(pm.checkUserPermission("alice", "execute")); // false
        System.out.println(pm.checkUserPermission("bob", "read")); // true
        System.out.println(pm.checkUserPermission("bob", "write")); // false
        System.out.println(pm.checkUserPermission("charlie", "read")); // false
    }
}
```
```python
class User:
    def __init__(self, username):
        self.username = username
        self.permissions = set()

    def add_permission(self, permission):
        self.permissions.add(permission)

    def remove_permission(self, permission):
        self.permissions.discard(permission)

    def has_permission(self, permission):
        return permission in self.permissions


class PermissionManager:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username not in self.users:
            self.users[username] = User(username)

    def remove_user(self, username):
        self.users.pop(username, None)

    def add_permission_to_user(self, username, permission):
        if username in self.users:
            self.users[username].add_permission(permission)

    def remove_permission_from_user(self, username, permission):
        if username in self.users:
            self.users[username].remove_permission(permission)

    def check_user_permission(self, username, permission):
        return username in self.users and self.users[username].has_permission(permission)


if __name__ == "__main__":
    pm = PermissionManager()

    pm.add_user("alice")
    pm.add_user("bob")

    pm.add_permission_to_user("alice", "read")
    pm.add_permission_to_user("alice", "write")
    pm.add_permission_to_user("bob", "read")

    print(pm.check_user_permission("alice", "read"))  # True
    print(pm.check_user_permission("alice", "execute"))  # False
    print(pm.check_user_permission("bob", "read"))  # True
    print(pm.check_user_permission("bob", "write"))  # False
    print(pm.check_user_permission("charlie", "read"))  # False
```
```cpp
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <string>

class User {
    std::string username;
    std::unordered_set<std::string> permissions;
public:
    User(const std::string& uname) : username(uname) {}

    void addPermission(const std::string& permission) {
        permissions.insert(permission);
    }

    void removePermission(const std::string& permission) {
        permissions.erase(permission);
    }

    bool hasPermission(const std::string& permission) const {
        return permissions.find(permission) != permissions.end();
    }
};

class PermissionManager {
    std::unordered_map<std::string, User> users;
public:
    void addUser(const std::string& username) {
        if (users.find(username) == users.end()) {
            users.emplace(username, User(username));
        }
    }

    void removeUser(const std::string& username) {
        users.erase(username);
    }

    void addPermissionToUser(const std::string& username, const std::string& permission) {
        if (users.find(username) != users.end()) {
            users[username].addPermission(permission);
        }
    }

    void removePermissionFromUser(const std::string& username, const std::string& permission) {
        if (users.find(username) != users.end()) {
            users[username].removePermission(permission);
        }
    }

    bool checkUserPermission(const std::string& username, const std::string& permission) const {
        auto it = users.find(username);
        return it != users.end() && it->second.hasPermission(permission);
    }
};

int main() {
    PermissionManager pm;

    pm.addUser("alice");
    pm.addUser("bob");

    pm.addPermissionToUser("alice", "read");
    pm.addPermissionToUser("alice", "write");
    pm.addPermissionToUser("bob", "read");

    std::cout << std::boolalpha;
    std::cout << pm.checkUserPermission("alice", "read") << std::endl;  // true
    std::cout << pm.checkUserPermission("alice", "execute") << std::endl;  // false
    std::cout << pm.checkUserPermission("bob", "read") << std::endl;  // true
    std::cout << pm.checkUserPermission("bob", "write") << std::endl;  // false
    std::cout << pm.checkUserPermission("charlie", "read") << std::endl;  // false

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *username;
    char **permissions;
    size_t permissionCount;
} User;

typedef struct {
    User *users;
    size_t userCount;
} PermissionManager;

User createUser(const char *username) {
    User user;
    user.username = strdup(username);
    user.permissions = NULL;
    user.permissionCount = 0;
    return user;
}

void freeUser(User *user) {
    free(user->username);
    for (size_t i = 0; i < user->permissionCount; ++i) {
        free(user->permissions[i]);
    }
    free(user->permissions);
}

void addPermission(User *user, const char *permission) {
    for (size_t i = 0; i < user->permissionCount; ++i) {
        if (strcmp(user->permissions[i], permission) == 0) {
            return;
        }
    }
    user->permissions = realloc(user->permissions, sizeof(char *) * (user->permissionCount + 1));
    user->permissions[user->permissionCount] = strdup(permission);
    user->permissionCount++;
}

void removePermission(User *user, const char *permission) {
    for (size_t i = 0; i < user->permissionCount; ++i) {
        if (strcmp(user->permissions[i], permission) == 0) {
            free(user->permissions[i]);
            user->permissions[i] = user->permissions[user->permissionCount - 1];
            user->permissions = realloc(user->permissions, sizeof(char *) * (user->permissionCount - 1));
            user->permissionCount--;
            return;
        }
    }
}

int hasPermission(const User *user, const char *permission) {
    for (size_t i = 0; i < user->permissionCount; ++i) {
        if (strcmp(user->permissions[i], permission) == 0) {
            return 1;
        }
    }
    return 0;
}

PermissionManager createPermissionManager() {
    PermissionManager pm;
    pm.users = NULL;
    pm.userCount = 0;
    return pm;
}

void freePermissionManager(PermissionManager *pm) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        freeUser(&pm->users[i]);
    }
    free(pm->users);
}

void addUser(PermissionManager *pm, const char *username) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        if (strcmp(pm->users[i].username, username) == 0) {
            return;
        }
    }
    pm->users = realloc(pm->users, sizeof(User) * (pm->userCount + 1));
    pm->users[pm->userCount] = createUser(username);
    pm->userCount++;
}

void removeUser(PermissionManager *pm, const char *username) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        if (strcmp(pm->users[i].username, username) == 0) {
            freeUser(&pm->users[i]);
            pm->users[i] = pm->users[pm->userCount - 1];
            pm->users = realloc(pm->users, sizeof(User) * (pm->userCount - 1));
            pm->userCount--;
            return;
        }
    }
}

void addPermissionToUser(PermissionManager *pm, const char *username, const char *permission) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        if (strcmp(pm->users[i].username, username) == 0) {
            addPermission(&pm->users[i], permission);
            return;
        }
    }
}

void removePermissionFromUser(PermissionManager *pm, const char *username, const char *permission) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        if (strcmp(pm->users[i].username, username) == 0) {
            removePermission(&pm->users[i], permission);
            return;
        }
    }
}

int checkUserPermission(const PermissionManager *pm, const char *username, const char *permission) {
    for (size_t i = 0; i < pm->userCount; ++i) {
        if (strcmp(pm->users[i].username, username) == 0) {
            return hasPermission(&pm->users[i], permission);
        }
    }
    return 0;
}

int main() {
    PermissionManager pm = createPermissionManager();

    addUser(&pm, "alice");
    addUser(&pm, "bob");

    addPermissionToUser(&pm, "alice", "read");
    addPermissionToUser(&pm, "alice", "write");
    addPermissionToUser(&pm, "bob", "read");

    printf("%d\n", checkUserPermission(&pm, "alice", "read"));  // 1
    printf("%d\n", checkUserPermission(&pm, "alice", "execute"));  // 0
    printf("%d\n", checkUserPermission(&pm, "bob", "read"));  // 1
    printf("%d\n", checkUserPermission(&pm, "bob", "write"));  // 0
    printf("%d\n", checkUserPermission(&pm, "charlie", "read"));  // 0

    freePermissionManager(&pm);
    return 0;
}
```
Created file: Task138.java
Created file: Task138.py
Created file: Task138.cpp
Created file: Task138.c
Task139_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task139, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes the radius of a circle as input and calculates its area.
```java
public class Task139 {
    public static double calculateCircleArea(double radius) {
        if (radius < 0) {
            throw new IllegalArgumentException("Radius cannot be negative");
        }
        return Math.PI * radius * radius;
    }

    public static void main(String[] args) {
        System.out.println(calculateCircleArea(1.0));  // Test case 1
        System.out.println(calculateCircleArea(2.5));  // Test case 2
        System.out.println(calculateCircleArea(0.0));  // Test case 3
        System.out.println(calculateCircleArea(10.0)); // Test case 4
        System.out.println(calculateCircleArea(5.75)); // Test case 5
    }
}
```
```python
import math

def calculate_circle_area(radius):
    if radius < 0:
        raise ValueError("Radius cannot be negative")
    return math.pi * radius * radius

if __name__ == "__main__":
    print(calculate_circle_area(1.0))   # Test case 1
    print(calculate_circle_area(2.5))   # Test case 2
    print(calculate_circle_area(0.0))   # Test case 3
    print(calculate_circle_area(10.0))  # Test case 4
    print(calculate_circle_area(5.75))  # Test case 5
```
```cpp
#include <iostream>
#include <cmath>
#include <stdexcept>

class Task139 {
public:
    static double calculateCircleArea(double radius) {
        if (radius < 0) {
            throw std::invalid_argument("Radius cannot be negative");
        }
        return M_PI * radius * radius;
    }

    static void runTests() {
        std::cout << calculateCircleArea(1.0) << std::endl;   // Test case 1
        std::cout << calculateCircleArea(2.5) << std::endl;   // Test case 2
        std::cout << calculateCircleArea(0.0) << std::endl;   // Test case 3
        std::cout << calculateCircleArea(10.0) << std::endl;  // Test case 4
        std::cout << calculateCircleArea(5.75) << std::endl;  // Test case 5
    }
};

int main() {
    Task139::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

double calculateCircleArea(double radius) {
    if (radius < 0) {
        fprintf(stderr, "Radius cannot be negative\n");
        exit(EXIT_FAILURE);
    }
    return M_PI * radius * radius;
}

int main() {
    printf("%f\n", calculateCircleArea(1.0));   // Test case 1
    printf("%f\n", calculateCircleArea(2.5));   // Test case 2
    printf("%f\n", calculateCircleArea(0.0));   // Test case 3
    printf("%f\n", calculateCircleArea(10.0));  // Test case 4
    printf("%f\n", calculateCircleArea(5.75));  // Test case 5
    return 0;
}
```
Created file: Task139.java
Created file: Task139.py
Created file: Task139.cpp
Created file: Task139.c
Task140_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task140, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes two numbers and an operator (+, -, *, /) as input and performs the corresponding arithmetic operation.
```java
import java.util.Scanner;

public class Task140 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        for (int i = 0; i < 5; i++) {
            System.out.print("Enter first number: ");
            double num1 = scanner.nextDouble();
            System.out.print("Enter second number: ");
            double num2 = scanner.nextDouble();
            System.out.print("Enter operator (+, -, *, /): ");
            char operator = scanner.next().charAt(0);

            try {
                System.out.println("Result: " + calculate(num1, num2, operator));
            } catch (IllegalArgumentException e) {
                System.out.println(e.getMessage());
            }
        }
        scanner.close();
    }

    public static double calculate(double num1, double num2, char operator) {
        switch (operator) {
            case '+':
                return num1 + num2;
            case '-':
                return num1 - num2;
            case '*':
                return num1 * num2;
            case '/':
                if (num2 == 0) {
                    throw new IllegalArgumentException("Error: Division by zero");
                }
                return num1 / num2;
            default:
                throw new IllegalArgumentException("Error: Invalid operator");
        }
    }
}
```
```python
def calculate(num1, num2, operator):
    if operator == '+':
        return num1 + num2
    elif operator == '-':
        return num1 - num2
    elif operator == '*':
        return num1 * num2
    elif operator == '/':
        if num2 == 0:
            raise ValueError("Error: Division by zero")
        return num1 / num2
    else:
        raise ValueError("Error: Invalid operator")

def main():
    test_cases = [
        (10, 5, '+'),
        (10, 5, '-'),
        (10, 5, '*'),
        (10, 0, '/'),
        (10, 5, '/')
    ]

    for num1, num2, operator in test_cases:
        try:
            result = calculate(num1, num2, operator)
            print(f"Result of {num1} {operator} {num2} = {result}")
        except ValueError as e:
            print(e)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <stdexcept>

class Task140 {
public:
    static double calculate(double num1, double num2, char op) {
        switch (op) {
            case '+':
                return num1 + num2;
            case '-':
                return num1 - num2;
            case '*':
                return num1 * num2;
            case '/':
                if (num2 == 0) {
                    throw std::invalid_argument("Error: Division by zero");
                }
                return num1 / num2;
            default:
                throw std::invalid_argument("Error: Invalid operator");
        }
    }
};

int main() {
    double testCases[5][3] = {
        {10, 5, '+'},
        {10, 5, '-'},
        {10, 5, '*'},
        {10, 0, '/'},
        {10, 5, '/'}
    };

    for (int i = 0; i < 5; ++i) {
        try {
            double result = Task140::calculate(testCases[i][0], testCases[i][1], (char)testCases[i][2]);
            std::cout << "Result of " << testCases[i][0] << " " << (char)testCases[i][2] << " " << testCases[i][1] << " = " << result << std::endl;
        } catch (const std::invalid_argument& e) {
            std::cout << e.what() << std::endl;
        }
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

double calculate(double num1, double num2, char op) {
    switch (op) {
        case '+':
            return num1 + num2;
        case '-':
            return num1 - num2;
        case '*':
            return num1 * num2;
        case '/':
            if (num2 == 0) {
                printf("Error: Division by zero\n");
                exit(EXIT_FAILURE);
            }
            return num1 / num2;
        default:
            printf("Error: Invalid operator\n");
            exit(EXIT_FAILURE);
    }
}

int main() {
    double testCases[5][3] = {
        {10, 5, '+'},
        {10, 5, '-'},
        {10, 5, '*'},
        {10, 0, '/'},
        {10, 5, '/'}
    };

    for (int i = 0; i < 5; ++i) {
        double result = calculate(testCases[i][0], testCases[i][1], (char)testCases[i][2]);
        printf("Result of %.2f %c %.2f = %.2f\n", testCases[i][0], (char)testCases[i][2], testCases[i][1], result);
    }
    return 0;
}
```
Created file: Task140.java
Created file: Task140.py
Created file: Task140.cpp
Created file: Task140.c
Task141_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task141, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a string as input and outputs its reverse.
```java
public class Task141 {
    public static String reverseString(String input) {
        if (input == null) {
            return null;
        }
        return new StringBuilder(input).reverse().toString();
    }

    public static void main(String[] args) {
        System.out.println(reverseString("hello")); // olleh
        System.out.println(reverseString("world")); // dlrow
        System.out.println(reverseString("Java"));  // avaJ
        System.out.println(reverseString("Python"));// nohtyP
        System.out.println(reverseString("C++"));   // ++C
    }
}
```
```python
def reverse_string(input_str):
    if input_str is None:
        return None
    return input_str[::-1]

if __name__ == "__main__":
    print(reverse_string("hello")) # olleh
    print(reverse_string("world")) # dlrow
    print(reverse_string("Java"))  # avaJ
    print(reverse_string("Python"))# nohtyP
    print(reverse_string("C++"))   # ++C
```
```cpp
#include <iostream>
#include <string>
#include <algorithm>

std::string reverseString(const std::string& input) {
    if (input.empty()) {
        return input;
    }
    std::string reversed = input;
    std::reverse(reversed.begin(), reversed.end());
    return reversed;
}

int main() {
    std::cout << reverseString("hello") << std::endl; // olleh
    std::cout << reverseString("world") << std::endl; // dlrow
    std::cout << reverseString("Java") << std::endl;  // avaJ
    std::cout << reverseString("Python") << std::endl;// nohtyP
    std::cout << reverseString("C++") << std::endl;   // ++C
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

char* reverseString(char* input) {
    if (input == NULL) {
        return NULL;
    }
    int len = strlen(input);
    for (int i = 0; i < len / 2; ++i) {
        char temp = input[i];
        input[i] = input[len - i - 1];
        input[len - i - 1] = temp;
    }
    return input;
}

int main() {
    char str1[] = "hello";
    char str2[] = "world";
    char str3[] = "Java";
    char str4[] = "Python";
    char str5[] = "C++";

    printf("%s\n", reverseString(str1)); // olleh
    printf("%s\n", reverseString(str2)); // dlrow
    printf("%s\n", reverseString(str3)); // avaJ
    printf("%s\n", reverseString(str4)); // nohtyP
    printf("%s\n", reverseString(str5)); // ++C

    return 0;
}
```
Created file: Task141.java
Created file: Task141.py
Created file: Task141.cpp
Created file: Task141.c
Task142_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task142, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes two numbers as input and finds their greatest common divisor.
```java
public class Task142 {
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }

    public static void main(String[] args) {
        System.out.println(gcd(48, 18)); // 6
        System.out.println(gcd(56, 98)); // 14
        System.out.println(gcd(101, 103)); // 1
        System.out.println(gcd(20, 30)); // 10
        System.out.println(gcd(7, 3)); // 1
    }
}
```
```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

if __name__ == "__main__":
    print(gcd(48, 18))  # 6
    print(gcd(56, 98))  # 14
    print(gcd(101, 103))  # 1
    print(gcd(20, 30))  # 10
    print(gcd(7, 3))  # 1
```
```cpp
#include <iostream>
using namespace std;

class Task142 {
public:
    static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
};

int main() {
    cout << Task142::gcd(48, 18) << endl; // 6
    cout << Task142::gcd(56, 98) << endl; // 14
    cout << Task142::gcd(101, 103) << endl; // 1
    cout << Task142::gcd(20, 30) << endl; // 10
    cout << Task142::gcd(7, 3) << endl; // 1
    return 0;
}
```
```c
#include <stdio.h>

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    printf("%d\n", gcd(48, 18)); // 6
    printf("%d\n", gcd(56, 98)); // 14
    printf("%d\n", gcd(101, 103)); // 1
    printf("%d\n", gcd(20, 30)); // 10
    printf("%d\n", gcd(7, 3)); // 1
    return 0;
}
```
Created file: Task142.java
Created file: Task142.py
Created file: Task142.cpp
Created file: Task142.c
Task143_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task143, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes an array of integers as input and sorts them in ascending order.
```java
public class Task143 {
    public static int[] sortArray(int[] arr) {
        if (arr == null) return null;
        int n = arr.length;
        for (int i = 0; i < n-1; i++) {
            for (int j = 0; j < n-i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

    public static void main(String[] args) {
        int[][] testCases = {
            {5, 3, 8, 6, 2},
            {1, 0, -1, 5, 3},
            {10, 20, 30, 40, 50},
            {9, 7, 5, 3, 1},
            {100, 99, 98, 97, 96}
        };

        for (int[] testCase : testCases) {
            int[] sortedArray = sortArray(testCase);
            for (int num : sortedArray) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
    }
}
```
```python
def sort_array(arr):
    if arr is None:
        return None
    n = len(arr)
    for i in range(n-1):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

def main():
    test_cases = [
        [5, 3, 8, 6, 2],
        [1, 0, -1, 5, 3],
        [10, 20, 30, 40, 50],
        [9, 7, 5, 3, 1],
        [100, 99, 98, 97, 96]
    ]

    for test_case in test_cases:
        sorted_array = sort_array(test_case)
        print(" ".join(map(str, sorted_array)))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>

class Task143 {
public:
    static std::vector<int> sortArray(std::vector<int> arr) {
        if (arr.empty()) return arr;
        int n = arr.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    std::swap(arr[j], arr[j + 1]);
                }
            }
        }
        return arr;
    }
};

int main() {
    std::vector<std::vector<int>> testCases = {
        {5, 3, 8, 6, 2},
        {1, 0, -1, 5, 3},
        {10, 20, 30, 40, 50},
        {9, 7, 5, 3, 1},
        {100, 99, 98, 97, 96}
    };

    for (const auto& testCase : testCases) {
        std::vector<int> sortedArray = Task143::sortArray(testCase);
        for (int num : sortedArray) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>

void sortArray(int arr[], int n) {
    if (arr == NULL) return;
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int testCases[5][5] = {
        {5, 3, 8, 6, 2},
        {1, 0, -1, 5, 3},
        {10, 20, 30, 40, 50},
        {9, 7, 5, 3, 1},
        {100, 99, 98, 97, 96}
    };

    int numberOfTestCases = sizeof(testCases) / sizeof(testCases[0]);
    for (int i = 0; i < numberOfTestCases; i++) {
        sortArray(testCases[i], 5);
        printArray(testCases[i], 5);
    }

    return 0;
}
```
Created file: Task143.java
Created file: Task143.py
Created file: Task143.cpp
Created file: Task143.c
Task144_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task144, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes two sorted arrays of integers as input and merges them into a single sorted array.
```java
public class Task144 {
    public static int[] mergeSortedArrays(int[] arr1, int[] arr2) {
        int[] mergedArray = new int[arr1.length + arr2.length];
        int i = 0, j = 0, k = 0;
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] <= arr2[j]) {
                mergedArray[k++] = arr1[i++];
            } else {
                mergedArray[k++] = arr2[j++];
            }
        }
        while (i < arr1.length) {
            mergedArray[k++] = arr1[i++];
        }
        while (j < arr2.length) {
            mergedArray[k++] = arr2[j++];
        }
        return mergedArray;
    }

    public static void main(String[] args) {
        int[] result1 = mergeSortedArrays(new int[]{1, 3, 5}, new int[]{2, 4, 6});
        int[] result2 = mergeSortedArrays(new int[]{}, new int[]{1, 2, 3});
        int[] result3 = mergeSortedArrays(new int[]{1, 2, 3}, new int[]{});
        int[] result4 = mergeSortedArrays(new int[]{1, 1, 1}, new int[]{1, 1, 1});
        int[] result5 = mergeSortedArrays(new int[]{1, 4, 7}, new int[]{2, 3, 6});
        // You can add print statements to see results if needed
    }
}
```
```python
def merge_sorted_arrays(arr1, arr2):
    merged_array = []
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            merged_array.append(arr1[i])
            i += 1
        else:
            merged_array.append(arr2[j])
            j += 1
    while i < len(arr1):
        merged_array.append(arr1[i])
        i += 1
    while j < len(arr2):
        merged_array.append(arr2[j])
        j += 1
    return merged_array

if __name__ == "__main__":
    result1 = merge_sorted_arrays([1, 3, 5], [2, 4, 6])
    result2 = merge_sorted_arrays([], [1, 2, 3])
    result3 = merge_sorted_arrays([1, 2, 3], [])
    result4 = merge_sorted_arrays([1, 1, 1], [1, 1, 1])
    result5 = merge_sorted_arrays([1, 4, 7], [2, 3, 6])
    # You can add print statements to see results if needed
```
```cpp
#include <iostream>
#include <vector>

std::vector<int> mergeSortedArrays(const std::vector<int>& arr1, const std::vector<int>& arr2) {
    std::vector<int> mergedArray;
    size_t i = 0, j = 0;
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] <= arr2[j]) {
            mergedArray.push_back(arr1[i++]);
        } else {
            mergedArray.push_back(arr2[j++]);
        }
    }
    while (i < arr1.size()) {
        mergedArray.push_back(arr1[i++]);
    }
    while (j < arr2.size()) {
        mergedArray.push_back(arr2[j++]);
    }
    return mergedArray;
}

int main() {
    std::vector<int> result1 = mergeSortedArrays({1, 3, 5}, {2, 4, 6});
    std::vector<int> result2 = mergeSortedArrays({}, {1, 2, 3});
    std::vector<int> result3 = mergeSortedArrays({1, 2, 3}, {});
    std::vector<int> result4 = mergeSortedArrays({1, 1, 1}, {1, 1, 1});
    std::vector<int> result5 = mergeSortedArrays({1, 4, 7}, {2, 3, 6});
    // You can add print statements to see results if needed
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int* mergeSortedArrays(const int* arr1, int size1, const int* arr2, int size2, int* mergedSize) {
    *mergedSize = size1 + size2;
    int* mergedArray = (int*)malloc(*mergedSize * sizeof(int));
    int i = 0, j = 0, k = 0;
    while (i < size1 && j < size2) {
        if (arr1[i] <= arr2[j]) {
            mergedArray[k++] = arr1[i++];
        } else {
            mergedArray[k++] = arr2[j++];
        }
    }
    while (i < size1) {
        mergedArray[k++] = arr1[i++];
    }
    while (j < size2) {
        mergedArray[k++] = arr2[j++];
    }
    return mergedArray;
}

int main() {
    int mergedSize1, mergedSize2, mergedSize3, mergedSize4, mergedSize5;
    int* result1 = mergeSortedArrays((int[]){1, 3, 5}, 3, (int[]){2, 4, 6}, 3, &mergedSize1);
    int* result2 = mergeSortedArrays((int[]){}, 0, (int[]){1, 2, 3}, 3, &mergedSize2);
    int* result3 = mergeSortedArrays((int[]){1, 2, 3}, 3, (int[]){}, 0, &mergedSize3);
    int* result4 = mergeSortedArrays((int[]){1, 1, 1}, 3, (int[]){1, 1, 1}, 3, &mergedSize4);
    int* result5 = mergeSortedArrays((int[]){1, 4, 7}, 3, (int[]){2, 3, 6}, 3, &mergedSize5);
    // You can add print statements to see results if needed
    free(result1);
    free(result2);
    free(result3);
    free(result4);
    free(result5);
}
```
Created file: Task144.java
Created file: Task144.py
Created file: Task144.cpp
Created file: Task144.c
Task145_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task145, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes an array of integers as input and finds the contiguous subarray with the maximum sum.
```java
import java.util.Arrays;

public class Task145 {
    public static int maxSubArraySum(int[] nums) {
        if (nums == null || nums.length == 0) {
            throw new IllegalArgumentException("Input array cannot be null or empty");
        }

        int maxSum = nums[0];
        int currentSum = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }

        return maxSum;
    }

    public static void main(String[] args) {
        int[][] testCases = {
            {-2, 1, -3, 4, -1, 2, 1, -5, 4},
            {1},
            {5, 4, -1, 7, 8},
            {-1, -2, -3, -4},
            {0, 0, 0, 0}
        };

        for (int[] testCase : testCases) {
            System.out.println("Max subarray sum of " + Arrays.toString(testCase) + " is: " + maxSubArraySum(testCase));
        }
    }
}
```
```python
def max_subarray_sum(nums):
    if not nums:
        raise ValueError("Input array cannot be null or empty")

    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum

if __name__ == "__main__":
    test_cases = [
        [-2, 1, -3, 4, -1, 2, 1, -5, 4],
        [1],
        [5, 4, -1, 7, 8],
        [-1, -2, -3, -4],
        [0, 0, 0, 0]
    ]

    for test_case in test_cases:
        print(f"Max subarray sum of {test_case} is: {max_subarray_sum(test_case)}")
```
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

class Task145 {
public:
    static int maxSubArraySum(const std::vector<int>& nums) {
        if (nums.empty()) {
            throw std::invalid_argument("Input array cannot be null or empty");
        }

        int maxSum = nums[0];
        int currentSum = nums[0];

        for (size_t i = 1; i < nums.size(); ++i) {
            currentSum = std::max(nums[i], currentSum + nums[i]);
            maxSum = std::max(maxSum, currentSum);
        }

        return maxSum;
    }

    static void runTestCases() {
        std::vector<std::vector<int>> testCases = {
            {-2, 1, -3, 4, -1, 2, 1, -5, 4},
            {1},
            {5, 4, -1, 7, 8},
            {-1, -2, -3, -4},
            {0, 0, 0, 0}
        };

        for (const auto& testCase : testCases) {
            std::cout << "Max subarray sum of {";
            for (size_t i = 0; i < testCase.size(); ++i) {
                std::cout << testCase[i];
                if (i < testCase.size() - 1) std::cout << ", ";
            }
            std::cout << "} is: " << maxSubArraySum(testCase) << std::endl;
        }
    }
};

int main() {
    Task145::runTestCases();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int maxSubArraySum(int* nums, int size) {
    if (nums == NULL || size <= 0) {
        fprintf(stderr, "Input array cannot be null or empty\n");
        exit(EXIT_FAILURE);
    }

    int maxSum = nums[0];
    int currentSum = nums[0];

    for (int i = 1; i < size; i++) {
        currentSum = nums[i] > currentSum + nums[i] ? nums[i] : currentSum + nums[i];
        maxSum = maxSum > currentSum ? maxSum : currentSum;
    }

    return maxSum;
}

void runTestCases() {
    int testCases[][9] = {
        {-2, 1, -3, 4, -1, 2, 1, -5, 4},
        {1},
        {5, 4, -1, 7, 8},
        {-1, -2, -3, -4},
        {0, 0, 0, 0}
    };

    int sizes[] = {9, 1, 5, 4, 4};

    for (int i = 0; i < 5; i++) {
        printf("Max subarray sum is: %d\n", maxSubArraySum(testCases[i], sizes[i]));
    }
}

int main() {
    runTestCases();
    return 0;
}
```
Created file: Task145.java
Created file: Task145.py
Created file: Task145.cpp
Created file: Task145.c
Task146_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task146, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes an array of unique integers from 1 to n as input, with one number missing, and finds the missing number.
```java
public class Task146 {
    public static int findMissingNumber(int[] arr, int n) {
        int totalSum = n * (n + 1) / 2;
        int arrSum = 0;
        for (int num : arr) {
            arrSum += num;
        }
        return totalSum - arrSum;
    }

    public static void main(String[] args) {
        System.out.println(findMissingNumber(new int[]{1, 2, 4, 5, 6}, 6)); // 3
        System.out.println(findMissingNumber(new int[]{2, 3, 1, 5}, 5)); // 4
        System.out.println(findMissingNumber(new int[]{1, 2, 3, 5}, 5)); // 4
        System.out.println(findMissingNumber(new int[]{3, 7, 1, 2, 8, 4, 5}, 8)); // 6
        System.out.println(findMissingNumber(new int[]{1, 2, 3, 4, 5, 7, 8}, 8)); // 6
    }
}
```
```python
def find_missing_number(arr, n):
    total_sum = n * (n + 1) // 2
    arr_sum = sum(arr)
    return total_sum - arr_sum

def main():
    print(find_missing_number([1, 2, 4, 5, 6], 6)) # 3
    print(find_missing_number([2, 3, 1, 5], 5)) # 4
    print(find_missing_number([1, 2, 3, 5], 5)) # 4
    print(find_missing_number([3, 7, 1, 2, 8, 4, 5], 8)) # 6
    print(find_missing_number([1, 2, 3, 4, 5, 7, 8], 8)) # 6

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>

class Task146 {
public:
    static int findMissingNumber(const std::vector<int>& arr, int n) {
        int totalSum = n * (n + 1) / 2;
        int arrSum = 0;
        for (int num : arr) {
            arrSum += num;
        }
        return totalSum - arrSum;
    }
};

int main() {
    std::cout << Task146::findMissingNumber({1, 2, 4, 5, 6}, 6) << std::endl; // 3
    std::cout << Task146::findMissingNumber({2, 3, 1, 5}, 5) << std::endl; // 4
    std::cout << Task146::findMissingNumber({1, 2, 3, 5}, 5) << std::endl; // 4
    std::cout << Task146::findMissingNumber({3, 7, 1, 2, 8, 4, 5}, 8) << std::endl; // 6
    std::cout << Task146::findMissingNumber({1, 2, 3, 4, 5, 7, 8}, 8) << std::endl; // 6
    return 0;
}
```
```c
#include <stdio.h>

int findMissingNumber(const int arr[], int n) {
    int totalSum = n * (n + 1) / 2;
    int arrSum = 0;
    for (int i = 0; i < n - 1; i++) {
        arrSum += arr[i];
    }
    return totalSum - arrSum;
}

int main() {
    int arr1[] = {1, 2, 4, 5, 6};
    int arr2[] = {2, 3, 1, 5};
    int arr3[] = {1, 2, 3, 5};
    int arr4[] = {3, 7, 1, 2, 8, 4, 5};
    int arr5[] = {1, 2, 3, 4, 5, 7, 8};

    printf("%d\n", findMissingNumber(arr1, 6)); // 3
    printf("%d\n", findMissingNumber(arr2, 5)); // 4
    printf("%d\n", findMissingNumber(arr3, 5)); // 4
    printf("%d\n", findMissingNumber(arr4, 8)); // 6
    printf("%d\n", findMissingNumber(arr5, 8)); // 6

    return 0;
}
```
Created file: Task146.java
Created file: Task146.py
Created file: Task146.cpp
Created file: Task146.c
Task147_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task147, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes an array of integers and an integer k as input, and finds the kth largest element in the array.
```java
import java.util.Arrays;

public class Task147 {
    public static int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }

    public static void main(String[] args) {
        System.out.println(findKthLargest(new int[]{3, 2, 1, 5, 6, 4}, 2)); // 5
        System.out.println(findKthLargest(new int[]{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4)); // 4
        System.out.println(findKthLargest(new int[]{1}, 1)); // 1
        System.out.println(findKthLargest(new int[]{2, 1}, 2)); // 1
        System.out.println(findKthLargest(new int[]{2, 1, 2}, 1)); // 2
    }
}
```
```python
import heapq

def find_kth_largest(nums, k):
    return heapq.nlargest(k, nums)[-1]

def main():
    print(find_kth_largest([3, 2, 1, 5, 6, 4], 2)) # 5
    print(find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)) # 4
    print(find_kth_largest([1], 1)) # 1
    print(find_kth_largest([2, 1], 2)) # 1
    print(find_kth_largest([2, 1, 2], 1)) # 2

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Task147 {
public:
    static int findKthLargest(std::vector<int>& nums, int k) {
        std::sort(nums.begin(), nums.end(), std::greater<int>());
        return nums[k - 1];
    }

    static void main() {
        std::cout << findKthLargest(std::vector<int>{3, 2, 1, 5, 6, 4}, 2) << std::endl; // 5
        std::cout << findKthLargest(std::vector<int>{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4) << std::endl; // 4
        std::cout << findKthLargest(std::vector<int>{1}, 1) << std::endl; // 1
        std::cout << findKthLargest(std::vector<int>{2, 1}, 2) << std::endl; // 1
        std::cout << findKthLargest(std::vector<int>{2, 1, 2}, 1) << std::endl; // 2
    }
};

int main() {
    Task147::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int compare(const void* a, const void* b) {
    return (*(int*)b - *(int*)a);
}

int findKthLargest(int* nums, int numsSize, int k) {
    qsort(nums, numsSize, sizeof(int), compare);
    return nums[k - 1];
}

int main() {
    int nums1[] = {3, 2, 1, 5, 6, 4};
    printf("%d\n", findKthLargest(nums1, 6, 2)); // 5

    int nums2[] = {3, 2, 3, 1, 2, 4, 5, 5, 6};
    printf("%d\n", findKthLargest(nums2, 9, 4)); // 4

    int nums3[] = {1};
    printf("%d\n", findKthLargest(nums3, 1, 1)); // 1

    int nums4[] = {2, 1};
    printf("%d\n", findKthLargest(nums4, 2, 2)); // 1

    int nums5[] = {2, 1, 2};
    printf("%d\n", findKthLargest(nums5, 3, 1)); // 2

    return 0;
}
```
Created file: Task147.java
Created file: Task147.py
Created file: Task147.cpp
Created file: Task147.c
Task148_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task148, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a stack data structure with push, pop, and peek operations.
```java
public class Task148 {
    static class Stack {
        private int maxSize;
        private int[] stackArray;
        private int top;

        public Stack(int size) {
            this.maxSize = size;
            this.stackArray = new int[maxSize];
            this.top = -1;
        }

        public boolean push(int value) {
            if (top == maxSize - 1) {
                return false; // stack is full
            }
            stackArray[++top] = value;
            return true;
        }

        public Integer pop() {
            if (top == -1) {
                return null; // stack is empty
            }
            return stackArray[top--];
        }

        public Integer peek() {
            if (top == -1) {
                return null; // stack is empty
            }
            return stackArray[top];
        }
    }

    public static void main(String[] args) {
        Stack stack = new Stack(5);

        System.out.println(stack.push(10)); // true
        System.out.println(stack.push(20)); // true
        System.out.println(stack.push(30)); // true
        System.out.println(stack.peek());   // 30
        System.out.println(stack.pop());    // 30
        System.out.println(stack.peek());   // 20
        System.out.println(stack.pop());    // 20
        System.out.println(stack.pop());    // 10
        System.out.println(stack.pop());    // null (empty)
    }
}
```
```python
class Stack:
    def __init__(self, size):
        self.max_size = size
        self.stack = []

    def push(self, value):
        if len(self.stack) >= self.max_size:
            return False  # stack is full
        self.stack.append(value)
        return True

    def pop(self):
        if not self.stack:
            return None  # stack is empty
        return self.stack.pop()

    def peek(self):
        if not self.stack:
            return None  # stack is empty
        return self.stack[-1]

def main():
    stack = Stack(5)

    print(stack.push(10))  # True
    print(stack.push(20))  # True
    print(stack.push(30))  # True
    print(stack.peek())    # 30
    print(stack.pop())     # 30
    print(stack.peek())    # 20
    print(stack.pop())     # 20
    print(stack.pop())     # 10
    print(stack.pop())     # None (empty)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>

class Stack {
    int maxSize;
    std::vector<int> stack;
public:
    Stack(int size) : maxSize(size) {}

    bool push(int value) {
        if (stack.size() >= maxSize) {
            return false; // stack is full
        }
        stack.push_back(value);
        return true;
    }

    int* pop() {
        if (stack.empty()) {
            return nullptr; // stack is empty
        }
        int* topValue = new int(stack.back());
        stack.pop_back();
        return topValue;
    }

    int* peek() {
        if (stack.empty()) {
            return nullptr; // stack is empty
        }
        return &stack.back();
    }
};

int main() {
    Stack stack(5);

    std::cout << std::boolalpha;
    std::cout << stack.push(10) << std::endl;  // true
    std::cout << stack.push(20) << std::endl;  // true
    std::cout << stack.push(30) << std::endl;  // true

    int* value = stack.peek();
    if (value) std::cout << *value << std::endl; // 30

    value = stack.pop();
    if (value) std::cout << *value << std::endl; // 30
    delete value;

    value = stack.peek();
    if (value) std::cout << *value << std::endl; // 20

    value = stack.pop();
    if (value) std::cout << *value << std::endl; // 20
    delete value;

    value = stack.pop();
    if (value) std::cout << *value << std::endl; // 10
    delete value;

    value = stack.pop();
    if (!value) std::cout << "null" << std::endl; // null (empty)

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int maxSize;
    int *stackArray;
    int top;
} Stack;

Stack* createStack(int size) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->maxSize = size;
    stack->stackArray = (int*)malloc(size * sizeof(int));
    stack->top = -1;
    return stack;
}

bool push(Stack *stack, int value) {
    if (stack->top == stack->maxSize - 1) {
        return false; // stack is full
    }
    stack->stackArray[++stack->top] = value;
    return true;
}

int* pop(Stack *stack) {
    if (stack->top == -1) {
        return NULL; // stack is empty
    }
    return &stack->stackArray[stack->top--];
}

int* peek(Stack *stack) {
    if (stack->top == -1) {
        return NULL; // stack is empty
    }
    return &stack->stackArray[stack->top];
}

int main() {
    Stack* stack = createStack(5);

    printf("%s\n", push(stack, 10) ? "true" : "false");  // true
    printf("%s\n", push(stack, 20) ? "true" : "false");  // true
    printf("%s\n", push(stack, 30) ? "true" : "false");  // true

    int* value = peek(stack);
    if (value) printf("%d\n", *value); // 30

    value = pop(stack);
    if (value) printf("%d\n", *value); // 30

    value = peek(stack);
    if (value) printf("%d\n", *value); // 20

    value = pop(stack);
    if (value) printf("%d\n", *value); // 20

    value = pop(stack);
    if (value) printf("%d\n", *value); // 10

    value = pop(stack);
    if (!value) printf("null\n"); // null (empty)

    free(stack->stackArray);
    free(stack);

    return 0;
}
```
Created file: Task148.java
Created file: Task148.py
Created file: Task148.cpp
Created file: Task148.c
Task149_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task149, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a queue data structure with enqueue, dequeue, and peek operations.
```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

public class Task149 {
    private LinkedList<Integer> queue;

    public Task149() {
        queue = new LinkedList<>();
    }

    public void enqueue(int value) {
        queue.addLast(value);
    }

    public int dequeue() {
        if (queue.isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return queue.removeFirst();
    }

    public int peek() {
        if (queue.isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return queue.getFirst();
    }

    public static void main(String[] args) {
        Task149 queue = new Task149();
        queue.enqueue(10);
        queue.enqueue(20);
        queue.enqueue(30);
        System.out.println(queue.dequeue()); // 10
        System.out.println(queue.peek());    // 20
        queue.enqueue(40);
        System.out.println(queue.dequeue()); // 20
        System.out.println(queue.dequeue()); // 30
    }
}
```
```python
class Task149:
    def __init__(self):
        self.queue = []

    def enqueue(self, value):
        self.queue.append(value)

    def dequeue(self):
        if not self.queue:
            raise IndexError("Queue is empty")
        return self.queue.pop(0)

    def peek(self):
        if not self.queue:
            raise IndexError("Queue is empty")
        return self.queue[0]

def main():
    queue = Task149()
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    print(queue.dequeue()) # 10
    print(queue.peek())    # 20
    queue.enqueue(40)
    print(queue.dequeue()) # 20
    print(queue.dequeue()) # 30

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <queue>
#include <stdexcept>

class Task149 {
private:
    std::queue<int> queue;

public:
    void enqueue(int value) {
        queue.push(value);
    }

    int dequeue() {
        if (queue.empty()) {
            throw std::out_of_range("Queue is empty");
        }
        int front = queue.front();
        queue.pop();
        return front;
    }

    int peek() {
        if (queue.empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return queue.front();
    }
};

int main() {
    Task149 queue;
    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);
    std::cout << queue.dequeue() << std::endl; // 10
    std::cout << queue.peek() << std::endl;    // 20
    queue.enqueue(40);
    std::cout << queue.dequeue() << std::endl; // 20
    std::cout << queue.dequeue() << std::endl; // 30
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct Task149 {
    Node* front;
    Node* rear;
} Task149;

void initQueue(Task149* queue) {
    queue->front = queue->rear = NULL;
}

void enqueue(Task149* queue, int value) {
    Node* temp = (Node*)malloc(sizeof(Node));
    if (!temp) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    temp->data = value;
    temp->next = NULL;
    if (queue->rear) {
        queue->rear->next = temp;
    }
    queue->rear = temp;
    if (!queue->front) {
        queue->front = temp;
    }
}

int dequeue(Task149* queue) {
    if (!queue->front) {
        fprintf(stderr, "Queue is empty\n");
        exit(EXIT_FAILURE);
    }
    Node* temp = queue->front;
    int value = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return value;
}

int peek(Task149* queue) {
    if (!queue->front) {
        fprintf(stderr, "Queue is empty\n");
        exit(EXIT_FAILURE);
    }
    return queue->front->data;
}

int main() {
    Task149 queue;
    initQueue(&queue);
    enqueue(&queue, 10);
    enqueue(&queue, 20);
    enqueue(&queue, 30);
    printf("%d\n", dequeue(&queue)); // 10
    printf("%d\n", peek(&queue));    // 20
    enqueue(&queue, 40);
    printf("%d\n", dequeue(&queue)); // 20
    printf("%d\n", dequeue(&queue)); // 30
    return 0;
}
```
Created file: Task149.java
Created file: Task149.py
Created file: Task149.cpp
Created file: Task149.c
Task150_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task150, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a singly linked list with insert, delete, and search operations.
```java
import java.util.NoSuchElementException;

public class Task150 {
    static class Node {
        int data;
        Node next;
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    static class SinglyLinkedList {
        private Node head;

        public void insert(int data) {
            Node newNode = new Node(data);
            if (head == null) {
                head = newNode;
            } else {
                Node current = head;
                while (current.next != null) {
                    current = current.next;
                }
                current.next = newNode;
            }
        }

        public boolean delete(int data) {
            if (head == null) return false;

            if (head.data == data) {
                head = head.next;
                return true;
            }

            Node current = head;
            while (current.next != null && current.next.data != data) {
                current = current.next;
            }

            if (current.next == null) return false;

            current.next = current.next.next;
            return true;
        }

        public boolean search(int data) {
            Node current = head;
            while (current != null) {
                if (current.data == data) return true;
                current = current.next;
            }
            return false;
        }
    }

    public static void main(String[] args) {
        SinglyLinkedList list = new SinglyLinkedList();
        list.insert(1);
        list.insert(2);
        list.insert(3);
        list.insert(4);
        list.insert(5);

        System.out.println(list.search(3)); // true
        System.out.println(list.delete(3)); // true
        System.out.println(list.search(3)); // false
        System.out.println(list.delete(3)); // false
        System.out.println(list.search(1)); // true
    }
}
```
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def delete(self, data):
        if not self.head:
            return False

        if self.head.data == data:
            self.head = self.head.next
            return True

        current = self.head
        while current.next and current.next.data != data:
            current = current.next

        if not current.next:
            return False

        current.next = current.next.next
        return True

    def search(self, data):
        current = self.head
        while current:
            if current.data == data:
                return True
            current = current.next
        return False

if __name__ == "__main__":
    list = SinglyLinkedList()
    list.insert(1)
    list.insert(2)
    list.insert(3)
    list.insert(4)
    list.insert(5)

    print(list.search(3))  # True
    print(list.delete(3))  # True
    print(list.search(3))  # False
    print(list.delete(3))  # False
    print(list.search(1))  # True
```
```cpp
#include <iostream>

class Node {
public:
    int data;
    Node* next;
    Node(int data) : data(data), next(nullptr) {}
};

class SinglyLinkedList {
private:
    Node* head;
public:
    SinglyLinkedList() : head(nullptr) {}

    void insert(int data) {
        Node* newNode = new Node(data);
        if (!head) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next) {
                current = current->next;
            }
            current->next = newNode;
        }
    }

    bool deleteNode(int data) {
        if (!head) return false;

        if (head->data == data) {
            Node* temp = head;
            head = head->next;
            delete temp;
            return true;
        }

        Node* current = head;
        while (current->next && current->next->data != data) {
            current = current->next;
        }

        if (!current->next) return false;

        Node* temp = current->next;
        current->next = current->next->next;
        delete temp;
        return true;
    }

    bool search(int data) {
        Node* current = head;
        while (current) {
            if (current->data == data) return true;
            current = current->next;
        }
        return false;
    }
};

int main() {
    SinglyLinkedList list;
    list.insert(1);
    list.insert(2);
    list.insert(3);
    list.insert(4);
    list.insert(5);

    std::cout << list.search(3) << std::endl; // 1 (true)
    std::cout << list.deleteNode(3) << std::endl; // 1 (true)
    std::cout << list.search(3) << std::endl; // 0 (false)
    std::cout << list.deleteNode(3) << std::endl; // 0 (false)
    std::cout << list.search(1) << std::endl; // 1 (true)

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct SinglyLinkedList {
    Node* head;
} SinglyLinkedList;

SinglyLinkedList* createList() {
    SinglyLinkedList* list = (SinglyLinkedList*)malloc(sizeof(SinglyLinkedList));
    list->head = NULL;
    return list;
}

void insert(SinglyLinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    if (!list->head) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next) {
            current = current->next;
        }
        current->next = newNode;
    }
}

int deleteNode(SinglyLinkedList* list, int data) {
    if (!list->head) return 0;

    if (list->head->data == data) {
        Node* temp = list->head;
        list->head = list->head->next;
        free(temp);
        return 1;
    }

    Node* current = list->head;
    while (current->next && current->next->data != data) {
        current = current->next;
    }

    if (!current->next) return 0;

    Node* temp = current->next;
    current->next = current->next->next;
    free(temp);
    return 1;
}

int search(SinglyLinkedList* list, int data) {
    Node* current = list->head;
    while (current) {
        if (current->data == data) return 1;
        current = current->next;
    }
    return 0;
}

int main() {
    SinglyLinkedList* list = createList();
    insert(list, 1);
    insert(list, 2);
    insert(list, 3);
    insert(list, 4);
    insert(list, 5);

    printf("%d\n", search(list, 3)); // 1 (true)
    printf("%d\n", deleteNode(list, 3)); // 1 (true)
    printf("%d\n", search(list, 3)); // 0 (false)
    printf("%d\n", deleteNode(list, 3)); // 0 (false)
    printf("%d\n", search(list, 1)); // 1 (true)

    return 0;
}
```
Created file: Task150.java
Created file: Task150.py
Created file: Task150.cpp
Created file: Task150.c
Task151_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task151, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a binary search tree with insert, delete, and search operations.
```java
import java.util.NoSuchElementException;

public class Task151 {
    static class TreeNode {
        int key;
        TreeNode left, right;

        TreeNode(int item) {
            key = item;
            left = right = null;
        }
    }

    static class BinarySearchTree {
        TreeNode root;

        BinarySearchTree() {
            root = null;
        }

        void insert(int key) {
            root = insertRec(root, key);
        }

        TreeNode insertRec(TreeNode root, int key) {
            if (root == null) {
                root = new TreeNode(key);
                return root;
            }
            if (key < root.key) {
                root.left = insertRec(root.left, key);
            } else if (key > root.key) {
                root.right = insertRec(root.right, key);
            }
            return root;
        }

        void deleteKey(int key) {
            root = deleteRec(root, key);
        }

        TreeNode deleteRec(TreeNode root, int key) {
            if (root == null) return root;
            if (key < root.key) {
                root.left = deleteRec(root.left, key);
            } else if (key > root.key) {
                root.right = deleteRec(root.right, key);
            } else {
                if (root.left == null)
                    return root.right;
                else if (root.right == null)
                    return root.left;
                root.key = minValue(root.right);
                root.right = deleteRec(root.right, root.key);
            }
            return root;
        }

        int minValue(TreeNode root) {
            int minValue = root.key;
            while (root.left != null) {
                minValue = root.left.key;
                root = root.left;
            }
            return minValue;
        }

        boolean search(int key) {
            return searchRec(root, key);
        }

        boolean searchRec(TreeNode root, int key) {
            if (root == null) return false;
            if (key == root.key) return true;
            return key < root.key ? searchRec(root.left, key) : searchRec(root.right, key);
        }
    }

    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        bst.insert(50);
        bst.insert(30);
        bst.insert(20);
        bst.insert(40);
        bst.insert(70);
        bst.insert(60);
        bst.insert(80);
        System.out.println(bst.search(20)); // true
        System.out.println(bst.search(100)); // false
        bst.deleteKey(20);
        System.out.println(bst.search(20)); // false
        bst.deleteKey(30);
        bst.deleteKey(50);
        System.out.println(bst.search(50)); // false
    }
}
```
```python
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.key = key

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = TreeNode(key)
        else:
            self._insert(self.root, key)

    def _insert(self, node, key):
        if key < node.key:
            if node.left is None:
                node.left = TreeNode(key)
            else:
                self._insert(node.left, key)
        elif key > node.key:
            if node.right is None:
                node.right = TreeNode(key)
            else:
                self._insert(node.right, key)

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def _delete(self, root, key):
        if root is None:
            return root
        if key < root.key:
            root.left = self._delete(root.left, key)
        elif key > root.key:
            root.right = self._delete(root.right, key)
        else:
            if root.left is None:
                return root.right
            elif root.right is None:
                return root.left
            temp = self._minValueNode(root.right)
            root.key = temp.key
            root.right = self._delete(root.right, temp.key)
        return root

    def _minValueNode(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current

    def search(self, key):
        return self._search(self.root, key)

    def _search(self, node, key):
        if node is None:
            return False
        if node.key == key:
            return True
        elif key < node.key:
            return self._search(node.left, key)
        else:
            return self._search(node.right, key)

def main():
    bst = BinarySearchTree()
    bst.insert(50)
    bst.insert(30)
    bst.insert(20)
    bst.insert(40)
    bst.insert(70)
    bst.insert(60)
    bst.insert(80)
    print(bst.search(20))  # True
    print(bst.search(100)) # False
    bst.delete(20)
    print(bst.search(20))  # False
    bst.delete(30)
    bst.delete(50)
    print(bst.search(50))  # False

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
using namespace std;

class TreeNode {
public:
    int key;
    TreeNode *left, *right;
    TreeNode(int item) : key(item), left(NULL), right(NULL) {}
};

class BinarySearchTree {
    TreeNode* root;

    TreeNode* insertRec(TreeNode* node, int key) {
        if (node == NULL) return new TreeNode(key);
        if (key < node->key)
            node->left = insertRec(node->left, key);
        else if (key > node->key)
            node->right = insertRec(node->right, key);
        return node;
    }

    TreeNode* deleteRec(TreeNode* root, int key) {
        if (root == NULL) return root;
        if (key < root->key)
            root->left = deleteRec(root->left, key);
        else if (key > root->key)
            root->right = deleteRec(root->right, key);
        else {
            if (root->left == NULL) return root->right;
            else if (root->right == NULL) return root->left;
            root->key = minValue(root->right);
            root->right = deleteRec(root->right, root->key);
        }
        return root;
    }

    int minValue(TreeNode* node) {
        int minv = node->key;
        while (node->left != NULL) {
            minv = node->left->key;
            node = node->left;
        }
        return minv;
    }

    bool searchRec(TreeNode* root, int key) {
        if (root == NULL) return false;
        if (root->key == key) return true;
        return key < root->key ? searchRec(root->left, key) : searchRec(root->right, key);
    }

public:
    BinarySearchTree() : root(NULL) {}

    void insert(int key) {
        root = insertRec(root, key);
    }

    void deleteKey(int key) {
        root = deleteRec(root, key);
    }

    bool search(int key) {
        return searchRec(root, key);
    }
};

int main() {
    BinarySearchTree bst;
    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);
    cout << bst.search(20) << endl;  // 1
    cout << bst.search(100) << endl; // 0
    bst.deleteKey(20);
    cout << bst.search(20) << endl;  // 0
    bst.deleteKey(30);
    bst.deleteKey(50);
    cout << bst.search(50) << endl;  // 0
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct TreeNode {
    int key;
    struct TreeNode *left, *right;
};

struct TreeNode* newNode(int item) {
    struct TreeNode* temp = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}

struct TreeNode* insertRec(struct TreeNode* node, int key) {
    if (node == NULL) return newNode(key);
    if (key < node->key)
        node->left = insertRec(node->left, key);
    else if (key > node->key)
        node->right = insertRec(node->right, key);
    return node;
}

struct TreeNode* minValueNode(struct TreeNode* node) {
    struct TreeNode* current = node;
    while (current && current->left != NULL)
        current = current->left;
    return current;
}

struct TreeNode* deleteRec(struct TreeNode* root, int key) {
    if (root == NULL) return root;
    if (key < root->key)
        root->left = deleteRec(root->left, key);
    else if (key > root->key)
        root->right = deleteRec(root->right, key);
    else {
        if (root->left == NULL) {
            struct TreeNode *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct TreeNode *temp = root->left;
            free(root);
            return temp;
        }
        struct TreeNode* temp = minValueNode(root->right);
        root->key = temp->key;
        root->right = deleteRec(root->right, temp->key);
    }
    return root;
}

bool searchRec(struct TreeNode* root, int key) {
    if (root == NULL) return false;
    if (root->key == key) return true;
    return key < root->key ? searchRec(root->left, key) : searchRec(root->right, key);
}

struct BinarySearchTree {
    struct TreeNode* root;
};

void insert(struct BinarySearchTree* bst, int key) {
    bst->root = insertRec(bst->root, key);
}

void deleteKey(struct BinarySearchTree* bst, int key) {
    bst->root = deleteRec(bst->root, key);
}

bool search(struct BinarySearchTree* bst, int key) {
    return searchRec(bst->root, key);
}

int main() {
    struct BinarySearchTree bst;
    bst.root = NULL;
    insert(&bst, 50);
    insert(&bst, 30);
    insert(&bst, 20);
    insert(&bst, 40);
    insert(&bst, 70);
    insert(&bst, 60);
    insert(&bst, 80);
    printf("%d\n", search(&bst, 20));  // 1
    printf("%d\n", search(&bst, 100)); // 0
    deleteKey(&bst, 20);
    printf("%d\n", search(&bst, 20));  // 0
    deleteKey(&bst, 30);
    deleteKey(&bst, 50);
    printf("%d\n", search(&bst, 50));  // 0
    return 0;
}
```
Created file: Task151.java
Created file: Task151.py
Created file: Task151.cpp
Created file: Task151.c
Task152_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task152, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a hash table with insert, delete, and search operations.
```java
import java.util.LinkedList;

public class Task152 {
    class HashNode {
        String key;
        int value;

        HashNode(String key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private LinkedList<HashNode>[] table;
    private static final int SIZE = 10;

    public Task152() {
        table = new LinkedList[SIZE];
        for (int i = 0; i < SIZE; i++) {
            table[i] = new LinkedList<>();
        }
    }

    private int getHash(String key) {
        return Math.abs(key.hashCode() % SIZE);
    }

    public void insert(String key, int value) {
        int hash = getHash(key);
        for (HashNode node : table[hash]) {
            if (node.key.equals(key)) {
                node.value = value;
                return;
            }
        }
        table[hash].add(new HashNode(key, value));
    }

    public Integer search(String key) {
        int hash = getHash(key);
        for (HashNode node : table[hash]) {
            if (node.key.equals(key)) {
                return node.value;
            }
        }
        return null;
    }

    public boolean delete(String key) {
        int hash = getHash(key);
        for (HashNode node : table[hash]) {
            if (node.key.equals(key)) {
                table[hash].remove(node);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Task152 hashTable = new Task152();
        hashTable.insert("apple", 1);
        hashTable.insert("banana", 2);
        hashTable.insert("grape", 3);
        hashTable.insert("orange", 4);
        hashTable.insert("melon", 5);

        System.out.println(hashTable.search("banana")); // 2
        System.out.println(hashTable.delete("apple"));  // true
        System.out.println(hashTable.search("apple"));  // null
        System.out.println(hashTable.delete("kiwi"));   // false
        System.out.println(hashTable.search("melon"));  // 5
    }
}
```
```python
class HashTable:
    def __init__(self):
        self.size = 10
        self.table = [[] for _ in range(self.size)]

    def _get_hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        hash_key = self._get_hash(key)
        for i, (k, v) in enumerate(self.table[hash_key]):
            if k == key:
                self.table[hash_key][i] = (key, value)
                return
        self.table[hash_key].append((key, value))

    def search(self, key):
        hash_key = self._get_hash(key)
        for k, v in self.table[hash_key]:
            if k == key:
                return v
        return None

    def delete(self, key):
        hash_key = self._get_hash(key)
        for i, (k, v) in enumerate(self.table[hash_key]):
            if k == key:
                del self.table[hash_key][i]
                return True
        return False

if __name__ == "__main__":
    hash_table = HashTable()
    hash_table.insert("apple", 1)
    hash_table.insert("banana", 2)
    hash_table.insert("grape", 3)
    hash_table.insert("orange", 4)
    hash_table.insert("melon", 5)

    print(hash_table.search("banana"))  # 2
    print(hash_table.delete("apple"))   # True
    print(hash_table.search("apple"))   # None
    print(hash_table.delete("kiwi"))    # False
    print(hash_table.search("melon"))   # 5
```
```cpp
#include <iostream>
#include <list>
#include <string>

class Task152 {
    struct HashNode {
        std::string key;
        int value;
        HashNode(std::string key, int value) : key(key), value(value) {}
    };

    std::list<HashNode>* table;
    static const int SIZE = 10;

    int getHash(const std::string& key) {
        std::hash<std::string> hashFunc;
        return hashFunc(key) % SIZE;
    }

public:
    Task152() {
        table = new std::list<HashNode>[SIZE];
    }

    ~Task152() {
        delete[] table;
    }

    void insert(const std::string& key, int value) {
        int hash = getHash(key);
        for (auto& node : table[hash]) {
            if (node.key == key) {
                node.value = value;
                return;
            }
        }
        table[hash].emplace_back(key, value);
    }

    int search(const std::string& key) {
        int hash = getHash(key);
        for (auto& node : table[hash]) {
            if (node.key == key) {
                return node.value;
            }
        }
        return -1;
    }

    bool deleteNode(const std::string& key) {
        int hash = getHash(key);
        for (auto it = table[hash].begin(); it != table[hash].end(); ++it) {
            if (it->key == key) {
                table[hash].erase(it);
                return true;
            }
        }
        return false;
    }
};

int main() {
    Task152 hashTable;
    hashTable.insert("apple", 1);
    hashTable.insert("banana", 2);
    hashTable.insert("grape", 3);
    hashTable.insert("orange", 4);
    hashTable.insert("melon", 5);

    std::cout << hashTable.search("banana") << std::endl; // 2
    std::cout << hashTable.deleteNode("apple") << std::endl; // true
    std::cout << hashTable.search("apple") << std::endl; // -1
    std::cout << hashTable.deleteNode("kiwi") << std::endl; // false
    std::cout << hashTable.search("melon") << std::endl; // 5

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 10

typedef struct HashNode {
    char* key;
    int value;
    struct HashNode* next;
} HashNode;

typedef struct {
    HashNode* table[SIZE];
} HashTable;

unsigned int hashFunction(const char* key) {
    unsigned int hash = 0;
    while (*key) {
        hash = (hash << 5) + *key++;
    }
    return hash % SIZE;
}

HashTable* createHashTable() {
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    for (int i = 0; i < SIZE; i++) {
        hashTable->table[i] = NULL;
    }
    return hashTable;
}

void insert(HashTable* hashTable, const char* key, int value) {
    unsigned int hash = hashFunction(key);
    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode));
    newNode->key = strdup(key);
    newNode->value = value;
    newNode->next = hashTable->table[hash];
    hashTable->table[hash] = newNode;
}

int search(HashTable* hashTable, const char* key) {
    unsigned int hash = hashFunction(key);
    HashNode* node = hashTable->table[hash];
    while (node != NULL) {
        if (strcmp(node->key, key) == 0) {
            return node->value;
        }
        node = node->next;
    }
    return -1;
}

int delete(HashTable* hashTable, const char* key) {
    unsigned int hash = hashFunction(key);
    HashNode* node = hashTable->table[hash];
    HashNode* prev = NULL;

    while (node != NULL) {
        if (strcmp(node->key, key) == 0) {
            if (prev == NULL) {
                hashTable->table[hash] = node->next;
            } else {
                prev->next = node->next;
            }
            free(node->key);
            free(node);
            return 1;
        }
        prev = node;
        node = node->next;
    }
    return 0;
}

int main() {
    HashTable* hashTable = createHashTable();
    insert(hashTable, "apple", 1);
    insert(hashTable, "banana", 2);
    insert(hashTable, "grape", 3);
    insert(hashTable, "orange", 4);
    insert(hashTable, "melon", 5);

    printf("%d\n", search(hashTable, "banana")); // 2
    printf("%d\n", delete(hashTable, "apple"));  // 1
    printf("%d\n", search(hashTable, "apple"));  // -1
    printf("%d\n", delete(hashTable, "kiwi"));   // 0
    printf("%d\n", search(hashTable, "melon"));  // 5

    return 0;
}
```
Created file: Task152.java
Created file: Task152.py
Created file: Task152.cpp
Created file: Task152.c
Task153_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task153, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a graph as input and performs a breadth-first search starting from a given node.
```java
import java.util.*;

public class Task153 {
    public List<Integer> bfs(int startNode, Map<Integer, List<Integer>> graph) {
        List<Integer> result = new ArrayList<>();
        if (!graph.containsKey(startNode)) {
            return result;
        }
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();

        queue.offer(startNode);
        visited.add(startNode);

        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            for (int neighbor : graph.get(node)) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }

        return result;
    }

    public static void main(String[] args) {
        Task153 task = new Task153();
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(0, 3, 4));
        graph.put(2, Arrays.asList(0, 4));
        graph.put(3, Arrays.asList(1, 5));
        graph.put(4, Arrays.asList(1, 2, 5));
        graph.put(5, Arrays.asList(3, 4));

        System.out.println(task.bfs(0, graph)); // [0, 1, 2, 3, 4, 5]
        System.out.println(task.bfs(1, graph)); // [1, 0, 3, 4, 2, 5]
        System.out.println(task.bfs(2, graph)); // [2, 0, 4, 1, 5, 3]
        System.out.println(task.bfs(3, graph)); // [3, 1, 5, 0, 4, 2]
        System.out.println(task.bfs(4, graph)); // [4, 1, 2, 5, 0, 3]
    }
}
```
```python
from collections import deque

def bfs(start_node, graph):
    result = []
    if start_node not in graph:
        return result
    queue = deque([start_node])
    visited = set([start_node])

    while queue:
        node = queue.popleft()
        result.append(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result

def main():
    graph = {
        0: [1, 2],
        1: [0, 3, 4],
        2: [0, 4],
        3: [1, 5],
        4: [1, 2, 5],
        5: [3, 4]
    }
    print(bfs(0, graph)) # [0, 1, 2, 3, 4, 5]
    print(bfs(1, graph)) # [1, 0, 3, 4, 2, 5]
    print(bfs(2, graph)) # [2, 0, 4, 1, 5, 3]
    print(bfs(3, graph)) # [3, 1, 5, 0, 4, 2]
    print(bfs(4, graph)) # [4, 1, 2, 5, 0, 3]

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <unordered_set>

using namespace std;

class Task153 {
public:
    vector<int> bfs(int startNode, unordered_map<int, vector<int>>& graph) {
        vector<int> result;
        if (graph.find(startNode) == graph.end()) {
            return result;
        }
        queue<int> q;
        unordered_set<int> visited;

        q.push(startNode);
        visited.insert(startNode);

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            result.push_back(node);
            for (int neighbor : graph[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }

        return result;
    }
};

int main() {
    Task153 task;
    unordered_map<int, vector<int>> graph = {
        {0, {1, 2}},
        {1, {0, 3, 4}},
        {2, {0, 4}},
        {3, {1, 5}},
        {4, {1, 2, 5}},
        {5, {3, 4}}
    };

    vector<int> result = task.bfs(0, graph);
    for (int val : result) cout << val << " ";
    cout << endl;

    result = task.bfs(1, graph);
    for (int val : result) cout << val << " ";
    cout << endl;

    result = task.bfs(2, graph);
    for (int val : result) cout << val << " ";
    cout << endl;

    result = task.bfs(3, graph);
    for (int val : result) cout << val << " ";
    cout << endl;

    result = task.bfs(4, graph);
    for (int val : result) cout << val << " ";
    cout << endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    Node* head[MAX_NODES];
    int visited[MAX_NODES];
} Graph;

Node* createNode(int v) {
    Node* newNode = malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

Graph* createGraph() {
    Graph* graph = malloc(sizeof(Graph));
    for (int i = 0; i < MAX_NODES; i++) {
        graph->head[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}

void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = createNode(dest);
    newNode->next = graph->head[src];
    graph->head[src] = newNode;

    newNode = createNode(src);
    newNode->next = graph->head[dest];
    graph->head[dest] = newNode;
}

void bfs(Graph* graph, int startVertex) {
    int queue[MAX_NODES];
    int front = 0;
    int rear = 0;

    graph->visited[startVertex] = 1;
    queue[rear++] = startVertex;

    while (front != rear) {
        int currentVertex = queue[front++];
        printf("%d ", currentVertex);

        Node* temp = graph->head[currentVertex];
        while (temp) {
            int adjVertex = temp->vertex;

            if (graph->visited[adjVertex] == 0) {
                graph->visited[adjVertex] = 1;
                queue[rear++] = adjVertex;
            }
            temp = temp->next;
        }
    }
}

int main() {
    Graph* graph = createGraph();
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 4);
    addEdge(graph, 3, 5);
    addEdge(graph, 4, 5);

    printf("BFS starting from vertex 0:\n");
    bfs(graph, 0);
    printf("\n");

    for (int i = 0; i < MAX_NODES; i++) graph->visited[i] = 0;
    printf("BFS starting from vertex 1:\n");
    bfs(graph, 1);
    printf("\n");

    for (int i = 0; i < MAX_NODES; i++) graph->visited[i] = 0;
    printf("BFS starting from vertex 2:\n");
    bfs(graph, 2);
    printf("\n");

    for (int i = 0; i < MAX_NODES; i++) graph->visited[i] = 0;
    printf("BFS starting from vertex 3:\n");
    bfs(graph, 3);
    printf("\n");

    for (int i = 0; i < MAX_NODES; i++) graph->visited[i] = 0;
    printf("BFS starting from vertex 4:\n");
    bfs(graph, 4);
    printf("\n");

    return 0;
}
```
Created file: Task153.java
Created file: Task153.py
Created file: Task153.cpp
Created file: Task153.c
Task154_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task154, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a graph as input and performs a depth-first search starting from a given node.
```java
public class Task154 {
    public static void main(String[] args) {
        int[][] graph = {
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {0, 1, 1, 0}
        };
        boolean[] visited = new boolean[4];
        System.out.println("DFS starting from node 0: " + dfs(graph, 0, visited));

        visited = new boolean[4];
        System.out.println("DFS starting from node 1: " + dfs(graph, 1, visited));

        visited = new boolean[4];
        System.out.println("DFS starting from node 2: " + dfs(graph, 2, visited));

        visited = new boolean[4];
        System.out.println("DFS starting from node 3: " + dfs(graph, 3, visited));

        visited = new boolean[4];
        System.out.println("DFS starting from node 0 again: " + dfs(graph, 0, visited));
    }

    public static String dfs(int[][] graph, int start, boolean[] visited) {
        StringBuilder result = new StringBuilder();
        dfsHelper(graph, start, visited, result);
        return result.toString();
    }

    private static void dfsHelper(int[][] graph, int node, boolean[] visited, StringBuilder result) {
        if (!visited[node]) {
            visited[node] = true;
            result.append(node).append(" ");
            for (int i = 0; i < graph[node].length; i++) {
                if (graph[node][i] == 1 && !visited[i]) {
                    dfsHelper(graph, i, visited, result);
                }
            }
        }
    }
}
```
```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = [False] * len(graph)
    result = []
    dfs_helper(graph, start, visited, result)
    return result

def dfs_helper(graph, node, visited, result):
    if not visited[node]:
        visited[node] = True
        result.append(node)
        for i, connected in enumerate(graph[node]):
            if connected == 1 and not visited[i]:
                dfs_helper(graph, i, visited, result)

if __name__ == "__main__":
    graph = [
        [0, 1, 1, 0],
        [1, 0, 0, 1],
        [1, 0, 0, 1],
        [0, 1, 1, 0]
    ]

    print("DFS starting from node 0:", dfs(graph, 0))
    print("DFS starting from node 1:", dfs(graph, 1))
    print("DFS starting from node 2:", dfs(graph, 2))
    print("DFS starting from node 3:", dfs(graph, 3))
    print("DFS starting from node 0 again:", dfs(graph, 0))
```
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

class Task154 {
public:
    static void dfsHelper(const std::vector<std::vector<int>>& graph, int node, std::vector<bool>& visited, std::stringstream& result) {
        if (!visited[node]) {
            visited[node] = true;
            result << node << " ";
            for (size_t i = 0; i < graph[node].size(); ++i) {
                if (graph[node][i] == 1 && !visited[i]) {
                    dfsHelper(graph, i, visited, result);
                }
            }
        }
    }

    static std::string dfs(const std::vector<std::vector<int>>& graph, int start) {
        std::vector<bool> visited(graph.size(), false);
        std::stringstream result;
        dfsHelper(graph, start, visited, result);
        return result.str();
    }

    static void test() {
        std::vector<std::vector<int>> graph = {
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {0, 1, 1, 0}
        };

        std::cout << "DFS starting from node 0: " << dfs(graph, 0) << std::endl;
        std::cout << "DFS starting from node 1: " << dfs(graph, 1) << std::endl;
        std::cout << "DFS starting from node 2: " << dfs(graph, 2) << std::endl;
        std::cout << "DFS starting from node 3: " << dfs(graph, 3) << std::endl;
        std::cout << "DFS starting from node 0 again: " << dfs(graph, 0) << std::endl;
    }
};

int main() {
    Task154::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>

void dfsHelper(int graph[4][4], int node, bool visited[4], char* result, int* pos) {
    if (!visited[node]) {
        visited[node] = true;
        *pos += sprintf(result + *pos, "%d ", node);
        for (int i = 0; i < 4; ++i) {
            if (graph[node][i] == 1 && !visited[i]) {
                dfsHelper(graph, i, visited, result, pos);
            }
        }
    }
}

char* dfs(int graph[4][4], int start) {
    static char result[20];
    int pos = 0;
    bool visited[4] = { false };
    dfsHelper(graph, start, visited, result, &pos);
    return result;
}

int main() {
    int graph[4][4] = {
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {1, 0, 0, 1},
        {0, 1, 1, 0}
    };

    printf("DFS starting from node 0: %s\n", dfs(graph, 0));
    printf("DFS starting from node 1: %s\n", dfs(graph, 1));
    printf("DFS starting from node 2: %s\n", dfs(graph, 2));
    printf("DFS starting from node 3: %s\n", dfs(graph, 3));
    printf("DFS starting from node 0 again: %s\n", dfs(graph, 0));

    return 0;
}
```
Created file: Task154.java
Created file: Task154.py
Created file: Task154.cpp
Created file: Task154.c
Task155_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task155, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes an array of integers as input and sorts them using the heap sort algorithm.
```java
import java.util.Arrays;

public class Task155 {
    public int[] heapSort(int[] array) {
        if (array == null) return null;

        int n = array.length;

        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }

        for (int i = n - 1; i > 0; i--) {
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;

            heapify(array, i, 0);
        }
        return array;
    }

    private void heapify(int[] array, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && array[left] > array[largest]) {
            largest = left;
        }

        if (right < n && array[right] > array[largest]) {
            largest = right;
        }

        if (largest != i) {
            int swap = array[i];
            array[i] = array[largest];
            array[largest] = swap;

            heapify(array, n, largest);
        }
    }

    public static void main(String[] args) {
        Task155 sorter = new Task155();
        int[][] testCases = {
            {4, 10, 3, 5, 1},
            {64, 25, 12, 22, 11},
            {12, 11, 13, 5, 6, 7},
            {3, 2, 1, 5, 4},
            {}
        };

        for (int[] testCase : testCases) {
            System.out.println(Arrays.toString(sorter.heapSort(testCase)));
        }
    }
}
```
```python
import heapq

def heap_sort(array):
    if array is None:
        return None

    heapq.heapify(array)
    sorted_array = [heapq.heappop(array) for _ in range(len(array))]
    return sorted_array

if __name__ == "__main__":
    test_cases = [
        [4, 10, 3, 5, 1],
        [64, 25, 12, 22, 11],
        [12, 11, 13, 5, 6, 7],
        [3, 2, 1, 5, 4],
        []
    ]

    for test in test_cases:
        print(heap_sort(test))
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Task155 {
public:
    vector<int> heapSort(vector<int>& array) {
        if (array.empty()) return array;

        int n = array.size();

        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }

        for (int i = n - 1; i > 0; i--) {
            swap(array[0], array[i]);
            heapify(array, i, 0);
        }

        return array;
    }

private:
    void heapify(vector<int>& array, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && array[left] > array[largest]) {
            largest = left;
        }

        if (right < n && array[right] > array[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(array[i], array[largest]);
            heapify(array, n, largest);
        }
    }
};

int main() {
    Task155 sorter;
    vector<vector<int>> testCases = {
        {4, 10, 3, 5, 1},
        {64, 25, 12, 22, 11},
        {12, 11, 13, 5, 6, 7},
        {3, 2, 1, 5, 4},
        {}
    };

    for (auto& testCase : testCases) {
        vector<int> sortedArray = sorter.heapSort(testCase);
        for (int num : sortedArray) {
            cout << num << " ";
        }
        cout << endl;
    }

    return 0;
}
```
```c
#include <stdio.h>

void heapify(int array[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && array[left] > array[largest])
        largest = left;

    if (right < n && array[right] > array[largest])
        largest = right;

    if (largest != i) {
        int temp = array[i];
        array[i] = array[largest];
        array[largest] = temp;

        heapify(array, n, largest);
    }
}

void heapSort(int array[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(array, n, i);

    for (int i = n - 1; i > 0; i--) {
        int temp = array[0];
        array[0] = array[i];
        array[i] = temp;

        heapify(array, i, 0);
    }
}

void printArray(int array[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", array[i]);
    printf("\n");
}

int main() {
    int testCases[][5] = {
        {4, 10, 3, 5, 1},
        {64, 25, 12, 22, 11},
        {12, 11, 13, 5, 6},
        {3, 2, 1, 5, 4},
        {0, 0, 0, 0, 0}
    };

    for (int i = 0; i < 5; i++) {
        int n = sizeof(testCases[i]) / sizeof(testCases[i][0]);
        heapSort(testCases[i], n);
        printArray(testCases[i], n);
    }

    return 0;
}
```
Created file: Task155.java
Created file: Task155.py
Created file: Task155.cpp
Created file: Task155.c
Task156_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task156, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a binary tree as input and performs a depth-first traversal (preorder, inorder, or postorder) on it.
```java
public class Task156 {
    static class TreeNode {
        int val;
        TreeNode left, right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static void preorderTraversal(TreeNode root) {
        if (root == null) return;
        System.out.print(root.val + " ");
        preorderTraversal(root.left);
        preorderTraversal(root.right);
    }

    public static void inorderTraversal(TreeNode root) {
        if (root == null) return;
        inorderTraversal(root.left);
        System.out.print(root.val + " ");
        inorderTraversal(root.right);
    }

    public static void postorderTraversal(TreeNode root) {
        if (root == null) return;
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        System.out.print(root.val + " ");
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        System.out.println("Preorder traversal:");
        preorderTraversal(root);
        System.out.println("\nInorder traversal:");
        inorderTraversal(root);
        System.out.println("\nPostorder traversal:");
        postorderTraversal(root);
    }
}
```
```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def preorder_traversal(root):
    if root is None:
        return
    print(root.val, end=' ')
    preorder_traversal(root.left)
    preorder_traversal(root.right)

def inorder_traversal(root):
    if root is None:
        return
    inorder_traversal(root.left)
    print(root.val, end=' ')
    inorder_traversal(root.right)

def postorder_traversal(root):
    if root is None:
        return
    postorder_traversal(root.left)
    postorder_traversal(root.right)
    print(root.val, end=' ')

if __name__ == '__main__':
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)

    print("Preorder traversal:")
    preorder_traversal(root)
    print("\nInorder traversal:")
    inorder_traversal(root)
    print("\nPostorder traversal:")
    postorder_traversal(root)
```
```cpp
#include <iostream>

class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    std::cout << root->val << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    std::cout << root->val << " ";
    inorderTraversal(root->right);
}

void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    std::cout << root->val << " ";
}

int main() {
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    std::cout << "Preorder traversal:\n";
    preorderTraversal(root);
    std::cout << "\nInorder traversal:\n";
    inorderTraversal(root);
    std::cout << "\nPostorder traversal:\n";
    postorderTraversal(root);

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

TreeNode* newTreeNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

void preorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    printf("%d ", root->val);
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

void inorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    inorderTraversal(root->left);
    printf("%d ", root->val);
    inorderTraversal(root->right);
}

void postorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->val);
}

int main() {
    TreeNode* root = newTreeNode(1);
    root->left = newTreeNode(2);
    root->right = newTreeNode(3);
    root->left->left = newTreeNode(4);
    root->left->right = newTreeNode(5);

    printf("Preorder traversal:\n");
    preorderTraversal(root);
    printf("\nInorder traversal:\n");
    inorderTraversal(root);
    printf("\nPostorder traversal:\n");
    postorderTraversal(root);

    return 0;
}
```
Created file: Task156.java
Created file: Task156.py
Created file: Task156.cpp
Created file: Task156.c
Task157_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task157, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that dynamically allocates and deallocates a memory resource.
```java
public class Task157 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            int[] array = allocateMemory(5);
            for (int j = 0; j < array.length; j++) {
                array[j] = j;
            }
            for (int num : array) {
                System.out.print(num + " ");
            }
            System.out.println();
            deallocateMemory(array);
        }
    }

    public static int[] allocateMemory(int size) {
        return new int[size];
    }

    public static void deallocateMemory(int[] array) {
        array = null;
    }
}
```
```python
def main():
    for _ in range(5):
        array = allocate_memory(5)
        for i in range(len(array)):
            array[i] = i
        print(array)
        deallocate_memory(array)

def allocate_memory(size):
    return [0] * size

def deallocate_memory(array):
    del array

main()
```
```cpp
#include <iostream>

class Task157 {
public:
    static void test() {
        for (int i = 0; i < 5; i++) {
            int* array = allocateMemory(5);
            for (int j = 0; j < 5; j++) {
                array[j] = j;
            }
            for (int j = 0; j < 5; j++) {
                std::cout << array[j] << " ";
            }
            std::cout << std::endl;
            deallocateMemory(array);
        }
    }

    static int* allocateMemory(int size) {
        return new int[size];
    }

    static void deallocateMemory(int* array) {
        delete[] array;
    }
};

int main() {
    Task157::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void test();
int* allocateMemory(int size);
void deallocateMemory(int* array);

int main() {
    test();
    return 0;
}

void test() {
    for (int i = 0; i < 5; i++) {
        int* array = allocateMemory(5);
        for (int j = 0; j < 5; j++) {
            array[j] = j;
        }
        for (int j = 0; j < 5; j++) {
            printf("%d ", array[j]);
        }
        printf("\n");
        deallocateMemory(array);
    }
}

int* allocateMemory(int size) {
    return (int*)malloc(size * sizeof(int));
}

void deallocateMemory(int* array) {
    free(array);
}
```
Created file: Task157.java
Created file: Task157.py
Created file: Task157.cpp
Created file: Task157.c
Task158_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task158, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
The program should allow a user to input data that is then used in an OS command
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Task158 {
    public static String runCommand(String input) {
        StringBuilder output = new StringBuilder();
        try {
            ProcessBuilder pb = new ProcessBuilder("echo", input);
            Process process = pb.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            reader.close();
            process.waitFor();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return output.toString();
    }

    public static void main(String[] args) {
        System.out.println(runCommand("test1"));
        System.out.println(runCommand("test2"));
        System.out.println(runCommand("test3"));
        System.out.println(runCommand("test4"));
        System.out.println(runCommand("test5"));
    }
}
```
```python
import subprocess

def run_command(input_data):
    try:
        result = subprocess.run(['echo', input_data], capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        return str(e)

if __name__ == "__main__":
    print(run_command("test1"))
    print(run_command("test2"))
    print(run_command("test3"))
    print(run_command("test4"))
    print(run_command("test5"))
```
```cpp
#include <iostream>
#include <string>
#include <array>
#include <memory>

class Task158 {
public:
    static std::string runCommand(const std::string& input) {
        std::array<char, 128> buffer;
        std::string result;
        std::string cmd = "echo " + input;
        std::shared_ptr<FILE> pipe(popen(cmd.c_str(), "r"), pclose);
        if (!pipe) return "popen() failed!";
        while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
            result += buffer.data();
        }
        return result;
    }

    static void main() {
        std::cout << runCommand("test1") << std::endl;
        std::cout << runCommand("test2") << std::endl;
        std::cout << runCommand("test3") << std::endl;
        std::cout << runCommand("test4") << std::endl;
        std::cout << runCommand("test5") << std::endl;
    }
};

int main() {
    Task158::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void run_command(const char *input) {
    char buffer[128];
    char command[256];
    snprintf(command, sizeof(command), "echo %s", input);
    FILE *pipe = popen(command, "r");
    if (!pipe) {
        printf("popen() failed!\n");
        return;
    }
    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
        printf("%s", buffer);
    }
    pclose(pipe);
}

int main() {
    run_command("test1");
    run_command("test2");
    run_command("test3");
    run_command("test4");
    run_command("test5");
    return 0;
}
```
Created file: Task158.java
Created file: Task158.py
Created file: Task158.cpp
Created file: Task158.c
Task159_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task159, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that dynamically allocates a memory buffer and allows a user to read data from the buffer using an index provided by the user.
```java
public class Task159 {

    public static char readFromBuffer(char[] buffer, int index) {
        if (index < 0 || index >= buffer.length) {
            throw new ArrayIndexOutOfBoundsException("Index out of bounds");
        }
        return buffer[index];
    }

    public static void main(String[] args) {
        char[] buffer = new char[10];
        for (int i = 0; i < buffer.length; i++) {
            buffer[i] = (char) ('A' + i);
        }

        try {
            System.out.println(readFromBuffer(buffer, 0)); // A
            System.out.println(readFromBuffer(buffer, 9)); // J
            System.out.println(readFromBuffer(buffer, 5)); // F
            System.out.println(readFromBuffer(buffer, -1)); // Exception
            System.out.println(readFromBuffer(buffer, 10)); // Exception
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e.getMessage());
        }
    }
}
```
```python
def read_from_buffer(buffer, index):
    if index < 0 or index >= len(buffer):
        raise IndexError("Index out of bounds")
    return buffer[index]

def main():
    buffer = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']

    try:
        print(read_from_buffer(buffer, 0))  # A
        print(read_from_buffer(buffer, 9))  # J
        print(read_from_buffer(buffer, 5))  # F
        print(read_from_buffer(buffer, -1)) # Exception
        print(read_from_buffer(buffer, 10)) # Exception
    except IndexError as e:
        print(e)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <stdexcept>

class Task159 {
public:
    static char readFromBuffer(char* buffer, size_t size, int index) {
        if (index < 0 || index >= size) {
            throw std::out_of_range("Index out of bounds");
        }
        return buffer[index];
    }
};

int main() {
    const size_t size = 10;
    char* buffer = new char[size];
    for (size_t i = 0; i < size; ++i) {
        buffer[i] = 'A' + i;
    }

    try {
        std::cout << Task159::readFromBuffer(buffer, size, 0) << std::endl; // A
        std::cout << Task159::readFromBuffer(buffer, size, 9) << std::endl; // J
        std::cout << Task159::readFromBuffer(buffer, size, 5) << std::endl; // F
        std::cout << Task159::readFromBuffer(buffer, size, -1) << std::endl; // Exception
        std::cout << Task159::readFromBuffer(buffer, size, 10) << std::endl; // Exception
    } catch (const std::out_of_range& e) {
        std::cout << e.what() << std::endl;
    }

    delete[] buffer;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char read_from_buffer(char* buffer, size_t size, int index) {
    if (index < 0 || index >= size) {
        fprintf(stderr, "Index out of bounds\n");
        exit(EXIT_FAILURE);
    }
    return buffer[index];
}

int main() {
    size_t size = 10;
    char* buffer = (char*)malloc(size * sizeof(char));
    if (!buffer) {
        perror("Failed to allocate memory");
        return EXIT_FAILURE;
    }

    for (size_t i = 0; i < size; ++i) {
        buffer[i] = 'A' + i;
    }

    printf("%c\n", read_from_buffer(buffer, size, 0));  // A
    printf("%c\n", read_from_buffer(buffer, size, 9));  // J
    printf("%c\n", read_from_buffer(buffer, size, 5));  // F
    // Uncomment to test index out of bounds
    // printf("%c\n", read_from_buffer(buffer, size, -1)); // Exception
    // printf("%c\n", read_from_buffer(buffer, size, 10)); // Exception

    free(buffer);
    return 0;
}
```
Created file: Task159.java
Created file: Task159.py
Created file: Task159.cpp
Created file: Task159.c
Task160_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task160, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that accepts a URL from a user and makes an HTTP request to that URL from the server.
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class Task160 {
    public static String fetchURLContent(String urlString) {
        StringBuilder content = new StringBuilder();
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(5000);

            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = in.readLine()) != null) {
                    content.append(line);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return content.toString();
    }

    public static void main(String[] args) {
        String[] testUrls = {
            "http://example.com",
            "https://www.google.com",
            "https://www.github.com",
            "https://www.stackoverflow.com",
            "https://www.microsoft.com"
        };
        for (String url : testUrls) {
            System.out.println("Fetching content for: " + url);
            System.out.println(fetchURLContent(url));
        }
    }
}
```
```python
import requests

def fetch_url_content(url: str) -> str:
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return response.text
    except requests.RequestException as e:
        return str(e)

def main():
    test_urls = [
        "http://example.com",
        "https://www.google.com",
        "https://www.github.com",
        "https://www.stackoverflow.com",
        "https://www.microsoft.com"
    ]
    for url in test_urls:
        print(f"Fetching content for: {url}")
        print(fetch_url_content(url))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <curl/curl.h>

class Task160 {
public:
    static std::string fetchURLContent(const std::string& url) {
        CURL* curl;
        CURLcode res;
        std::string readBuffer;

        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
            res = curl_easy_perform(curl);
            if(res != CURLE_OK) {
                fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            }
            curl_easy_cleanup(curl);
        }
        curl_global_cleanup();
        return readBuffer;
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
};

int main() {
    std::string testUrls[] = {
        "http://example.com",
        "https://www.google.com",
        "https://www.github.com",
        "https://www.stackoverflow.com",
        "https://www.microsoft.com"
    };
    for (const std::string& url : testUrls) {
        std::cout << "Fetching content for: " << url << std::endl;
        std::cout << Task160::fetchURLContent(url) << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

struct String {
    char *ptr;
    size_t len;
};

void init_string(struct String *s) {
    s->len = 0;
    s->ptr = malloc(s->len + 1);
    if (s->ptr == NULL) {
        fprintf(stderr, "malloc() failed\n");
        exit(EXIT_FAILURE);
    }
    s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, struct String *s) {
    size_t new_len = s->len + size * nmemb;
    s->ptr = realloc(s->ptr, new_len + 1);
    if (s->ptr == NULL) {
        fprintf(stderr, "realloc() failed\n");
        exit(EXIT_FAILURE);
    }
    memcpy(s->ptr + s->len, ptr, size * nmemb);
    s->ptr[new_len] = '\0';
    s->len = new_len;

    return size * nmemb;
}

char* fetchURLContent(const char* url) {
    CURL *curl;
    CURLcode res;
    struct String s;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    if(curl) {
        init_string(&s);
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &s);
        res = curl_easy_perform(curl);
        if(res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        }
        curl_easy_cleanup(curl);
    }
    curl_global_cleanup();

    return s.ptr;
}

int main() {
    const char* testUrls[] = {
        "http://example.com",
        "https://www.google.com",
        "https://www.github.com",
        "https://www.stackoverflow.com",
        "https://www.microsoft.com"
    };
    for (int i = 0; i < 5; i++) {
        printf("Fetching content for: %s\n", testUrls[i]);
        char* content = fetchURLContent(testUrls[i]);
        printf("%s\n", content);
        free(content);
    }
    return 0;
}
```
Created file: Task160.java
Created file: Task160.py
Created file: Task160.cpp
Created file: Task160.c
Task161_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task161, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
 Write a program that takes the capacity of the knapsack and a list of items with their weights and values as input, and finds the maximum value that can be put into the knapsack.
```java
import java.util.*;

public class Task161 {
    public static int knapsack(int capacity, int[] weights, int[] values) {
        int n = values.length;
        int[][] dp = new int[n + 1][capacity + 1];

        for (int i = 0; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                if (i == 0 || w == 0) {
                    dp[i][w] = 0;
                } else if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }

    public static void main(String[] args) {
        System.out.println(knapsack(50, new int[]{10, 20, 30}, new int[]{60, 100, 120})); // 220
        System.out.println(knapsack(10, new int[]{5, 4, 6}, new int[]{10, 40, 30})); // 50
        System.out.println(knapsack(5, new int[]{1, 2, 3}, new int[]{10, 20, 30})); // 50
        System.out.println(knapsack(0, new int[]{1, 2, 3}, new int[]{10, 20, 30})); // 0
        System.out.println(knapsack(7, new int[]{1, 3, 4}, new int[]{15, 20, 30})); // 35
    }
}
```
```python
def knapsack(capacity, weights, values):
    n = len(values)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    for i in range(n + 1):
        for w in range(capacity + 1):
            if i == 0 or w == 0:
                dp[i][w] = 0
            elif weights[i - 1] <= w:
                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][capacity]

if __name__ == "__main__":
    print(knapsack(50, [10, 20, 30], [60, 100, 120])) # 220
    print(knapsack(10, [5, 4, 6], [10, 40, 30])) # 50
    print(knapsack(5, [1, 2, 3], [10, 20, 30])) # 50
    print(knapsack(0, [1, 2, 3], [10, 20, 30])) # 0
    print(knapsack(7, [1, 3, 4], [15, 20, 30])) # 35
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Task161 {
public:
    static int knapsack(int capacity, vector<int>& weights, vector<int>& values) {
        int n = values.size();
        vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));

        for (int i = 0; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                if (i == 0 || w == 0) {
                    dp[i][w] = 0;
                } else if (weights[i - 1] <= w) {
                    dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }

    static void runTests() {
        cout << knapsack(50, vector<int>{10, 20, 30}, vector<int>{60, 100, 120}) << endl; // 220
        cout << knapsack(10, vector<int>{5, 4, 6}, vector<int>{10, 40, 30}) << endl; // 50
        cout << knapsack(5, vector<int>{1, 2, 3}, vector<int>{10, 20, 30}) << endl; // 50
        cout << knapsack(0, vector<int>{1, 2, 3}, vector<int>{10, 20, 30}) << endl; // 0
        cout << knapsack(7, vector<int>{1, 3, 4}, vector<int>{15, 20, 30}) << endl; // 35
    }
};

int main() {
    Task161::runTests();
    return 0;
}
```
```c
#include <stdio.h>

int knapsack(int capacity, int weights[], int values[], int n) {
    int dp[n + 1][capacity + 1];

    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0;
            } else if (weights[i - 1] <= w) {
                dp[i][w] = (values[i - 1] + dp[i - 1][w - weights[i - 1]] > dp[i - 1][w]) ?
                            values[i - 1] + dp[i - 1][w - weights[i - 1]] : dp[i - 1][w];
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][capacity];
}

int main() {
    int weights1[] = {10, 20, 30};
    int values1[] = {60, 100, 120};
    printf("%d\n", knapsack(50, weights1, values1, 3)); // 220

    int weights2[] = {5, 4, 6};
    int values2[] = {10, 40, 30};
    printf("%d\n", knapsack(10, weights2, values2, 3)); // 50

    int weights3[] = {1, 2, 3};
    int values3[] = {10, 20, 30};
    printf("%d\n", knapsack(5, weights3, values3, 3)); // 50

    int weights4[] = {1, 2, 3};
    int values4[] = {10, 20, 30};
    printf("%d\n", knapsack(0, weights4, values4, 3)); // 0

    int weights5[] = {1, 3, 4};
    int values5[] = {15, 20, 30};
    printf("%d\n", knapsack(7, weights5, values5, 3)); // 35

    return 0;
}
```
Created file: Task161.java
Created file: Task161.py
Created file: Task161.cpp
Created file: Task161.c
Task162_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task162, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a weighted graph and a starting node as input, and finds the shortest path from the starting node to all other nodes using Dijkstra's algorithm.
```java
import java.util.*;

public class Task162 {

    public static Map<Integer, Integer> dijkstra(Map<Integer, List<int[]>> graph, int start) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        Map<Integer, Integer> dist = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        pq.offer(new int[]{start, 0});
        dist.put(start, 0);

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int node = current[0];
            int distance = current[1];

            if (!visited.add(node)) {
                continue;
            }

            for (int[] neighbor : graph.getOrDefault(node, Collections.emptyList())) {
                int nextNode = neighbor[0];
                int edgeWeight = neighbor[1];
                int newDist = distance + edgeWeight;

                if (newDist < dist.getOrDefault(nextNode, Integer.MAX_VALUE)) {
                    dist.put(nextNode, newDist);
                    pq.offer(new int[]{nextNode, newDist});
                }
            }
        }
        return dist;
    }

    public static void main(String[] args) {
        Map<Integer, List<int[]>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(new int[]{1, 4}, new int[]{2, 1}));
        graph.put(1, Arrays.asList(new int[]{3, 1}));
        graph.put(2, Arrays.asList(new int[]{1, 2}, new int[]{3, 5}));
        graph.put(3, Collections.emptyList());

        System.out.println(dijkstra(graph, 0));
    }
}
```
```python
import heapq

def dijkstra(graph, start):
    pq = [(0, start)]
    dist = {start: 0}
    visited = set()

    while pq:
        current_distance, node = heapq.heappop(pq)

        if node in visited:
            continue

        visited.add(node)

        for neighbor, weight in graph.get(node, []):
            distance = current_distance + weight

            if distance < dist.get(neighbor, float('inf')):
                dist[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return dist

if __name__ == "__main__":
    graph = {
        0: [(1, 4), (2, 1)],
        1: [(3, 1)],
        2: [(1, 2), (3, 5)],
        3: []
    }
    print(dijkstra(graph, 0))
```
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <climits>
#include <set>

using namespace std;

class Task162 {
public:
    static unordered_map<int, int> dijkstra(const unordered_map<int, vector<pair<int, int>>>& graph, int start) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        unordered_map<int, int> dist;
        set<int> visited;

        pq.push({0, start});
        dist[start] = 0;

        while (!pq.empty()) {
            auto [current_distance, node] = pq.top();
            pq.pop();

            if (visited.count(node)) {
                continue;
            }

            visited.insert(node);

            for (const auto& [neighbor, weight] : graph.at(node)) {
                int distance = current_distance + weight;

                if (distance < dist[neighbor] || dist.find(neighbor) == dist.end()) {
                    dist[neighbor] = distance;
                    pq.push({distance, neighbor});
                }
            }
        }

        return dist;
    }

    static void test() {
        unordered_map<int, vector<pair<int, int>>> graph = {
            {0, {{1, 4}, {2, 1}}},
            {1, {{3, 1}}},
            {2, {{1, 2}, {3, 5}}},
            {3, {}}
        };

        unordered_map<int, int> result = dijkstra(graph, 0);

        for (const auto& [node, distance] : result) {
            cout << "Node " << node << " has distance " << distance << endl;
        }
    }
};

int main() {
    Task162::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <limits.h>
#include <stdbool.h>

#define V 4

int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++)
        if (!sptSet[v] && dist[v] <= min)
            min = dist[v], min_index = v;
    return min_index;
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printf("Vertex \t Distance from Source\n");
    for (int i = 0; i < V; i++)
        printf("%d \t\t %d\n", i, dist[i]);
}

int main() {
    int graph[V][V] = {
        {0, 4, 1, 0},
        {0, 0, 0, 1},
        {0, 2, 0, 5},
        {0, 0, 0, 0}
    };

    dijkstra(graph, 0);

    return 0;
}
```
Created file: Task162.java
Created file: Task162.py
Created file: Task162.cpp
Created file: Task162.c
Task163_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task163, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
A consecutive-run is a list of adjacent, consecutive integers. This list can be either increasing or decreasing. Create a function that takes an array of numbers and returns the length of the longest consecutive-run.

To illustrate:

longestRun([1, 2, 3, 5, 6, 7, 8, 9])  5
// Two consecutive runs: [1, 2, 3] and [5, 6, 7, 8, 9] (longest).
Examples
longestRun([1, 2, 3, 10, 11, 15])  3
// Longest consecutive-run: [1, 2, 3].

longestRun([5, 4, 2, 1])  2
// Longest consecutive-run: [5, 4] and [2, 1].

longestRun([3, 5, 7, 10, 15])  1
// No consecutive runs, so we return 1.
Notes
If there aren't any consecutive runs (there is a gap between each integer), return 1.
```java
public class Task163 {

    public static int longestRun(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int maxLen = 1;
        int currentLen = 1;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1] + 1 || nums[i] == nums[i - 1] - 1) {
                currentLen++;
            } else {
                maxLen = Math.max(maxLen, currentLen);
                currentLen = 1;
            }
        }

        return Math.max(maxLen, currentLen);
    }

    public static void main(String[] args) {
        System.out.println(longestRun(new int[]{1, 2, 3, 5, 6, 7, 8, 9})); // 5
        System.out.println(longestRun(new int[]{1, 2, 3, 10, 11, 15})); // 3
        System.out.println(longestRun(new int[]{5, 4, 2, 1})); // 2
        System.out.println(longestRun(new int[]{3, 5, 7, 10, 15})); // 1
        System.out.println(longestRun(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9})); // 9
    }
}
```
```python
def longest_run(nums):
    if not nums:
        return 0

    max_len = 1
    current_len = 1

    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1 or nums[i] == nums[i - 1] - 1:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1

    return max(max_len, current_len)

if __name__ == "__main__":
    print(longest_run([1, 2, 3, 5, 6, 7, 8, 9])) # 5
    print(longest_run([1, 2, 3, 10, 11, 15])) # 3
    print(longest_run([5, 4, 2, 1])) # 2
    print(longest_run([3, 5, 7, 10, 15])) # 1
    print(longest_run([1, 2, 3, 4, 5, 6, 7, 8, 9])) # 9
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Task163 {
public:
    static int longestRun(const std::vector<int>& nums) {
        if (nums.empty()) return 0;

        int maxLen = 1;
        int currentLen = 1;

        for (size_t i = 1; i < nums.size(); ++i) {
            if (nums[i] == nums[i - 1] + 1 || nums[i] == nums[i - 1] - 1) {
                currentLen++;
            } else {
                maxLen = std::max(maxLen, currentLen);
                currentLen = 1;
            }
        }

        return std::max(maxLen, currentLen);
    }
};

int main() {
    std::cout << Task163::longestRun({1, 2, 3, 5, 6, 7, 8, 9}) << std::endl; // 5
    std::cout << Task163::longestRun({1, 2, 3, 10, 11, 15}) << std::endl; // 3
    std::cout << Task163::longestRun({5, 4, 2, 1}) << std::endl; // 2
    std::cout << Task163::longestRun({3, 5, 7, 10, 15}) << std::endl; // 1
    std::cout << Task163::longestRun({1, 2, 3, 4, 5, 6, 7, 8, 9}) << std::endl; // 9
    return 0;
}
```
```c
#include <stdio.h>

int longestRun(int nums[], int size) {
    if (size == 0) return 0;

    int maxLen = 1;
    int currentLen = 1;

    for (int i = 1; i < size; i++) {
        if (nums[i] == nums[i - 1] + 1 || nums[i] == nums[i - 1] - 1) {
            currentLen++;
        } else {
            if (currentLen > maxLen) {
                maxLen = currentLen;
            }
            currentLen = 1;
        }
    }

    if (currentLen > maxLen) {
        maxLen = currentLen;
    }

    return maxLen;
}

int main() {
    int arr1[] = {1, 2, 3, 5, 6, 7, 8, 9};
    int arr2[] = {1, 2, 3, 10, 11, 15};
    int arr3[] = {5, 4, 2, 1};
    int arr4[] = {3, 5, 7, 10, 15};
    int arr5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    printf("%d\n", longestRun(arr1, 8)); // 5
    printf("%d\n", longestRun(arr2, 6)); // 3
    printf("%d\n", longestRun(arr3, 4)); // 2
    printf("%d\n", longestRun(arr4, 5)); // 1
    printf("%d\n", longestRun(arr5, 9)); // 9

    return 0;
}
```
Created file: Task163.java
Created file: Task163.py
Created file: Task163.cpp
Created file: Task163.c
Task164_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task164, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a function that takes an array of names in the format "First Name Last Name" (e.g. "John Doe"), and returns an array of these names sorted by the length of their last names. If the length of multiple last names are the same, then proceed to sort alphabetically by last name.

Examples
lastNameLensort([
  "Jennifer Figueroa",
  "Heather Mcgee",
  "Amanda Schwartz",
  "Nicole Yoder",
  "Melissa Hoffman"
])  ["Heather Mcgee", "Nicole Yoder", "Melissa Hoffman", "Jennifer Figueroa", "Amanda Schwartz"]
Notes
If last names are of the same length, sort alphabetically by last name.
```java
import java.util.Arrays;
import java.util.Comparator;

public class Task164 {
    public static String[] lastNameLensort(String[] names) {
        return Arrays.stream(names)
                .sorted(Comparator.comparingInt((String name) -> name.split(" ")[1].length())
                        .thenComparing(name -> name.split(" ")[1]))
                .toArray(String[]::new);
    }

    public static void main(String[] args) {
        String[] test1 = {"Jennifer Figueroa", "Heather Mcgee", "Amanda Schwartz", "Nicole Yoder", "Melissa Hoffman"};
        String[] test2 = {"John Doe", "Jane Roe", "Alice Wonderland", "Charlie Brown", "Daniel Craig"};
        String[] test3 = {"Anna Bell", "Bella Swan", "Edward Cullen", "Jacob Black", "Rosalie Hale"};
        String[] test4 = {"Harry Potter", "Hermione Granger", "Ron Weasley", "Draco Malfoy", "Albus Dumbledore"};
        String[] test5 = {"Tony Stark", "Bruce Banner", "Steve Rogers", "Natasha Romanoff", "Clint Barton"};

        System.out.println(Arrays.toString(lastNameLensort(test1)));
        System.out.println(Arrays.toString(lastNameLensort(test2)));
        System.out.println(Arrays.toString(lastNameLensort(test3)));
        System.out.println(Arrays.toString(lastNameLensort(test4)));
        System.out.println(Arrays.toString(lastNameLensort(test5)));
    }
}
```
```python
def lastNameLensort(names):
    return sorted(names, key=lambda name: (len(name.split()[1]), name.split()[1]))

def main():
    test1 = ["Jennifer Figueroa", "Heather Mcgee", "Amanda Schwartz", "Nicole Yoder", "Melissa Hoffman"]
    test2 = ["John Doe", "Jane Roe", "Alice Wonderland", "Charlie Brown", "Daniel Craig"]
    test3 = ["Anna Bell", "Bella Swan", "Edward Cullen", "Jacob Black", "Rosalie Hale"]
    test4 = ["Harry Potter", "Hermione Granger", "Ron Weasley", "Draco Malfoy", "Albus Dumbledore"]
    test5 = ["Tony Stark", "Bruce Banner", "Steve Rogers", "Natasha Romanoff", "Clint Barton"]

    print(lastNameLensort(test1))
    print(lastNameLensort(test2))
    print(lastNameLensort(test3))
    print(lastNameLensort(test4))
    print(lastNameLensort(test5))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> lastNameLensort(const std::vector<std::string>& names) {
    std::vector<std::string> sortedNames = names;
    std::sort(sortedNames.begin(), sortedNames.end(), [](const std::string& a, const std::string& b) {
        size_t lastNameStartA = a.find(' ') + 1;
        size_t lastNameStartB = b.find(' ') + 1;
        std::string lastNameA = a.substr(lastNameStartA);
        std::string lastNameB = b.substr(lastNameStartB);

        if (lastNameA.length() == lastNameB.length()) {
            return lastNameA < lastNameB;
        }
        return lastNameA.length() < lastNameB.length();
    });
    return sortedNames;
}

int main() {
    std::vector<std::string> test1 = {"Jennifer Figueroa", "Heather Mcgee", "Amanda Schwartz", "Nicole Yoder", "Melissa Hoffman"};
    std::vector<std::string> test2 = {"John Doe", "Jane Roe", "Alice Wonderland", "Charlie Brown", "Daniel Craig"};
    std::vector<std::string> test3 = {"Anna Bell", "Bella Swan", "Edward Cullen", "Jacob Black", "Rosalie Hale"};
    std::vector<std::string> test4 = {"Harry Potter", "Hermione Granger", "Ron Weasley", "Draco Malfoy", "Albus Dumbledore"};
    std::vector<std::string> test5 = {"Tony Stark", "Bruce Banner", "Steve Rogers", "Natasha Romanoff", "Clint Barton"};

    auto result1 = lastNameLensort(test1);
    auto result2 = lastNameLensort(test2);
    auto result3 = lastNameLensort(test3);
    auto result4 = lastNameLensort(test4);
    auto result5 = lastNameLensort(test5);

    for (const auto& name : result1) std::cout << name << " ";
    std::cout << std::endl;
    for (const auto& name : result2) std::cout << name << " ";
    std::cout << std::endl;
    for (const auto& name : result3) std::cout << name << " ";
    std::cout << std::endl;
    for (const auto& name : result4) std::cout << name << " ";
    std::cout << std::endl;
    for (const auto& name : result5) std::cout << name << " ";
    std::cout << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int compareLastNameLength(const void *a, const void *b) {
    const char *nameA = *(const char **)a;
    const char *nameB = *(const char **)b;

    const char *lastNameA = strchr(nameA, ' ') + 1;
    const char *lastNameB = strchr(nameB, ' ') + 1;

    size_t lenA = strlen(lastNameA);
    size_t lenB = strlen(lastNameB);

    if (lenA == lenB) {
        return strcmp(lastNameA, lastNameB);
    }
    return lenA - lenB;
}

void lastNameLensort(const char **names, size_t size) {
    qsort(names, size, sizeof(const char*), compareLastNameLength);
}

int main() {
    const char *test1[] = {"Jennifer Figueroa", "Heather Mcgee", "Amanda Schwartz", "Nicole Yoder", "Melissa Hoffman"};
    const char *test2[] = {"John Doe", "Jane Roe", "Alice Wonderland", "Charlie Brown", "Daniel Craig"};
    const char *test3[] = {"Anna Bell", "Bella Swan", "Edward Cullen", "Jacob Black", "Rosalie Hale"};
    const char *test4[] = {"Harry Potter", "Hermione Granger", "Ron Weasley", "Draco Malfoy", "Albus Dumbledore"};
    const char *test5[] = {"Tony Stark", "Bruce Banner", "Steve Rogers", "Natasha Romanoff", "Clint Barton"};

    lastNameLensort(test1, 5);
    lastNameLensort(test2, 5);
    lastNameLensort(test3, 5);
    lastNameLensort(test4, 5);
    lastNameLensort(test5, 5);

    for (int i = 0; i < 5; i++) printf("%s\n", test1[i]);
    printf("\n");
    for (int i = 0; i < 5; i++) printf("%s\n", test2[i]);
    printf("\n");
    for (int i = 0; i < 5; i++) printf("%s\n", test3[i]);
    printf("\n");
    for (int i = 0; i < 5; i++) printf("%s\n", test4[i]);
    printf("\n");
    for (int i = 0; i < 5; i++) printf("%s\n", test5[i]);
    printf("\n");

    return 0;
}
```
Created file: Task164.java
Created file: Task164.py
Created file: Task164.cpp
Created file: Task164.c
Task165_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task165, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a function that takes in two arrays and determines whether there exists a flush.

The first array represents the 5 cards dealt on the table.
The second array represents the 2 cards in your hand.
Notation: card number and suit (abbreviated as S = Spades, H = Hearts, D = Diamonds, C = Clubs) separated by an underscore.

Examples
checkFlush(["A_S", "J_H", "7_D", "8_D", "10_D"], ["J_D", "3_D"])  true // diamond flush

checkFlush(["10_S", "7_S", "9_H", "4_S", "3_S"], ["K_S", "Q_S"])  true // spade flush

checkFlush(["3_S", "10_H", "10_D", "10_C", "10_S"], ["3_S", "4_D"])  false
Notes
Hint: If there aren't at least 3 cards of the same suit on the table, there is zero chance of there being a flush.
```java
import java.util.HashMap;

public class Task165 {
    public static boolean checkFlush(String[] tableCards, String[] handCards) {
        HashMap<Character, Integer> suitCount = new HashMap<>();

        for (String card : tableCards) {
            char suit = card.split("_")[1].charAt(0);
            suitCount.put(suit, suitCount.getOrDefault(suit, 0) + 1);
        }

        for (String card : handCards) {
            char suit = card.split("_")[1].charAt(0);
            suitCount.put(suit, suitCount.getOrDefault(suit, 0) + 1);
        }

        for (int count : suitCount.values()) {
            if (count >= 5) {
                return true;
            }
        }

        return false;
    }

    public static void main(String[] args) {
        System.out.println(checkFlush(new String[]{"A_S", "J_H", "7_D", "8_D", "10_D"}, new String[]{"J_D", "3_D"})); // true
        System.out.println(checkFlush(new String[]{"10_S", "7_S", "9_H", "4_S", "3_S"}, new String[]{"K_S", "Q_S"})); // true
        System.out.println(checkFlush(new String[]{"3_S", "10_H", "10_D", "10_C", "10_S"}, new String[]{"3_S", "4_D"})); // false
        System.out.println(checkFlush(new String[]{"2_H", "4_H", "6_H", "8_H", "10_H"}, new String[]{"Q_H", "K_H"})); // true
        System.out.println(checkFlush(new String[]{"2_D", "3_C", "4_S", "5_H", "6_D"}, new String[]{"7_D", "8_D"})); // false
    }
}
```
```python
def check_flush(table_cards, hand_cards):
    suit_count = {}

    for card in table_cards:
        suit = card.split('_')[1]
        suit_count[suit] = suit_count.get(suit, 0) + 1

    for card in hand_cards:
        suit = card.split('_')[1]
        suit_count[suit] = suit_count.get(suit, 0) + 1

    return any(count >= 5 for count in suit_count.values())

if __name__ == "__main__":
    print(check_flush(["A_S", "J_H", "7_D", "8_D", "10_D"], ["J_D", "3_D"])) # True
    print(check_flush(["10_S", "7_S", "9_H", "4_S", "3_S"], ["K_S", "Q_S"])) # True
    print(check_flush(["3_S", "10_H", "10_D", "10_C", "10_S"], ["3_S", "4_D"])) # False
    print(check_flush(["2_H", "4_H", "6_H", "8_H", "10_H"], ["Q_H", "K_H"])) # True
    print(check_flush(["2_D", "3_C", "4_S", "5_H", "6_D"], ["7_D", "8_D"])) # False
```
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>

bool checkFlush(std::vector<std::string> tableCards, std::vector<std::string> handCards) {
    std::unordered_map<char, int> suitCount;

    for (const auto& card : tableCards) {
        char suit = card.substr(card.find('_') + 1)[0];
        suitCount[suit]++;
    }

    for (const auto& card : handCards) {
        char suit = card.substr(card.find('_') + 1)[0];
        suitCount[suit]++;
    }

    for (const auto& pair : suitCount) {
        if (pair.second >= 5) {
            return true;
        }
    }

    return false;
}

int main() {
    std::cout << std::boolalpha;
    std::cout << checkFlush({"A_S", "J_H", "7_D", "8_D", "10_D"}, {"J_D", "3_D"}) << std::endl; // true
    std::cout << checkFlush({"10_S", "7_S", "9_H", "4_S", "3_S"}, {"K_S", "Q_S"}) << std::endl; // true
    std::cout << checkFlush({"3_S", "10_H", "10_D", "10_C", "10_S"}, {"3_S", "4_D"}) << std::endl; // false
    std::cout << checkFlush({"2_H", "4_H", "6_H", "8_H", "10_H"}, {"Q_H", "K_H"}) << std::endl; // true
    std::cout << checkFlush({"2_D", "3_C", "4_S", "5_H", "6_D"}, {"7_D", "8_D"}) << std::endl; // false
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

int checkFlush(char* tableCards[], int tableSize, char* handCards[], int handSize) {
    int suitCount[4] = {0};
    char suits[] = "SHDC";

    for (int i = 0; i < tableSize; i++) {
        char* suit = strchr(tableCards[i], '_') + 1;
        suitCount[strchr(suits, suit[0]) - suits]++;
    }

    for (int i = 0; i < handSize; i++) {
        char* suit = strchr(handCards[i], '_') + 1;
        suitCount[strchr(suits, suit[0]) - suits]++;
    }

    for (int i = 0; i < 4; i++) {
        if (suitCount[i] >= 5) {
            return 1;
        }
    }

    return 0;
}

int main() {
    char* table1[] = {"A_S", "J_H", "7_D", "8_D", "10_D"};
    char* hand1[] = {"J_D", "3_D"};
    printf("%d\n", checkFlush(table1, 5, hand1, 2)); // 1 (true)

    char* table2[] = {"10_S", "7_S", "9_H", "4_S", "3_S"};
    char* hand2[] = {"K_S", "Q_S"};
    printf("%d\n", checkFlush(table2, 5, hand2, 2)); // 1 (true)

    char* table3[] = {"3_S", "10_H", "10_D", "10_C", "10_S"};
    char* hand3[] = {"3_S", "4_D"};
    printf("%d\n", checkFlush(table3, 5, hand3, 2)); // 0 (false)

    char* table4[] = {"2_H", "4_H", "6_H", "8_H", "10_H"};
    char* hand4[] = {"Q_H", "K_H"};
    printf("%d\n", checkFlush(table4, 5, hand4, 2)); // 1 (true)

    char* table5[] = {"2_D", "3_C", "4_S", "5_H", "6_D"};
    char* hand5[] = {"7_D", "8_D"};
    printf("%d\n", checkFlush(table5, 5, hand5, 2)); // 0 (false)

    return 0;
}
```
Created file: Task165.java
Created file: Task165.py
Created file: Task165.cpp
Created file: Task165.c
Task166_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task166, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a function that sorts the positive numbers in ascending order, and keeps the negative numbers untouched.

Examples
posNegSort([6, 3, -2, 5, -8, 2, -2])  [2, 3, -2, 5, -8, 6, -2]

posNegSort([6, 5, 4, -1, 3, 2, -1, 1])  [1, 2, 3, -1, 4, 5, -1, 6]

posNegSort([-5, -5, -5, -5, 7, -5])  [-5, -5, -5, -5, 7, -5]

posNegSort([])  []
Notes
If given an empty array, you should return an empty array.
Integers will always be either positive or negative (0 isn't included in the tests).
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class Task166 {

    public static int[] posNegSort(int[] arr) {
        ArrayList<Integer> positives = new ArrayList<>();
        for (int num : arr) {
            if (num > 0) {
                positives.add(num);
            }
        }
        Collections.sort(positives);

        int posIndex = 0;
        int[] result = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0) {
                result[i] = positives.get(posIndex++);
            } else {
                result[i] = arr[i];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(posNegSort(new int[]{6, 3, -2, 5, -8, 2, -2}))); // [2, 3, -2, 5, -8, 6, -2]
        System.out.println(Arrays.toString(posNegSort(new int[]{6, 5, 4, -1, 3, 2, -1, 1}))); // [1, 2, 3, -1, 4, 5, -1, 6]
        System.out.println(Arrays.toString(posNegSort(new int[]{-5, -5, -5, -5, 7, -5}))); // [-5, -5, -5, -5, 7, -5]
        System.out.println(Arrays.toString(posNegSort(new int[]{}))); // []
        System.out.println(Arrays.toString(posNegSort(new int[]{1, -1, 3, -2, 2}))); // [1, -1, 2, -2, 3]
    }
}
```
```python
def pos_neg_sort(arr):
    positives = sorted([num for num in arr if num > 0])
    pos_index = 0
    result = []
    for num in arr:
        if num > 0:
            result.append(positives[pos_index])
            pos_index += 1
        else:
            result.append(num)
    return result

if __name__ == "__main__":
    print(pos_neg_sort([6, 3, -2, 5, -8, 2, -2]))  # [2, 3, -2, 5, -8, 6, -2]
    print(pos_neg_sort([6, 5, 4, -1, 3, 2, -1, 1]))  # [1, 2, 3, -1, 4, 5, -1, 6]
    print(pos_neg_sort([-5, -5, -5, -5, 7, -5]))  # [-5, -5, -5, -5, 7, -5]
    print(pos_neg_sort([]))  # []
    print(pos_neg_sort([1, -1, 3, -2, 2]))  # [1, -1, 2, -2, 3]
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> posNegSort(const std::vector<int>& arr) {
    std::vector<int> positives;
    for (int num : arr) {
        if (num > 0) {
            positives.push_back(num);
        }
    }
    std::sort(positives.begin(), positives.end());

    std::vector<int> result;
    int posIndex = 0;
    for (int num : arr) {
        if (num > 0) {
            result.push_back(positives[posIndex++]);
        } else {
            result.push_back(num);
        }
    }
    return result;
}

int main() {
    auto printVector = [](const std::vector<int>& vec) {
        for (int num : vec) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    };

    printVector(posNegSort({6, 3, -2, 5, -8, 2, -2})); // [2, 3, -2, 5, -8, 6, -2]
    printVector(posNegSort({6, 5, 4, -1, 3, 2, -1, 1})); // [1, 2, 3, -1, 4, 5, -1, 6]
    printVector(posNegSort({-5, -5, -5, -5, 7, -5})); // [-5, -5, -5, -5, 7, -5]
    printVector(posNegSort({})); // []
    printVector(posNegSort({1, -1, 3, -2, 2})); // [1, -1, 2, -2, 3]

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int* posNegSort(const int* arr, int size) {
    int* positives = (int*)malloc(size * sizeof(int));
    int posCount = 0;

    for (int i = 0; i < size; ++i) {
        if (arr[i] > 0) {
            positives[posCount++] = arr[i];
        }
    }

    for (int i = 0; i < posCount - 1; ++i) {
        for (int j = 0; j < posCount - i - 1; ++j) {
            if (positives[j] > positives[j + 1]) {
                int temp = positives[j];
                positives[j] = positives[j + 1];
                positives[j + 1] = temp;
            }
        }
    }

    int* result = (int*)malloc(size * sizeof(int));
    int posIndex = 0;
    for (int i = 0; i < size; ++i) {
        if (arr[i] > 0) {
            result[i] = positives[posIndex++];
        } else {
            result[i] = arr[i];
        }
    }

    free(positives);
    return result;
}

void printArray(const int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr1[] = {6, 3, -2, 5, -8, 2, -2};
    int* sortedArr1 = posNegSort(arr1, 7);
    printArray(sortedArr1, 7);
    free(sortedArr1);

    int arr2[] = {6, 5, 4, -1, 3, 2, -1, 1};
    int* sortedArr2 = posNegSort(arr2, 8);
    printArray(sortedArr2, 8);
    free(sortedArr2);

    int arr3[] = {-5, -5, -5, -5, 7, -5};
    int* sortedArr3 = posNegSort(arr3, 6);
    printArray(sortedArr3, 6);
    free(sortedArr3);

    int arr4[] = {};
    int* sortedArr4 = posNegSort(arr4, 0);
    printArray(sortedArr4, 0);
    free(sortedArr4);

    int arr5[] = {1, -1, 3, -2, 2};
    int* sortedArr5 = posNegSort(arr5, 5);
    printArray(sortedArr5, 5);
    free(sortedArr5);

    return 0;
}
```
Created file: Task166.java
Created file: Task166.py
Created file: Task166.cpp
Created file: Task166.c
Task167_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task167, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a function that takes the volume of a cube and returns the length of the cube's main diagonal, rounded to two decimal places.

Examples
cubeDiagonal(8)  3.46

cubeDiagonal(343)  12.12

cubeDiagonal(1157.625)  18.19
```java
import java.lang.Math;

public class Task167 {
    public static double cubeDiagonal(double volume) {
        double sideLength = Math.cbrt(volume);
        double diagonal = sideLength * Math.sqrt(3);
        return Math.round(diagonal * 100.0) / 100.0;
    }

    public static void main(String[] args) {
        System.out.println(cubeDiagonal(8));        // 3.46
        System.out.println(cubeDiagonal(343));      // 12.12
        System.out.println(cubeDiagonal(1157.625)); // 18.19
        System.out.println(cubeDiagonal(1));        // 1.73
        System.out.println(cubeDiagonal(27));       // 5.20
    }
}
```
```python
import math

def cube_diagonal(volume):
    side_length = math.pow(volume, 1/3)
    diagonal = side_length * math.sqrt(3)
    return round(diagonal, 2)

if __name__ == "__main__":
    print(cube_diagonal(8))        # 3.46
    print(cube_diagonal(343))      # 12.12
    print(cube_diagonal(1157.625)) # 18.19
    print(cube_diagonal(1))        # 1.73
    print(cube_diagonal(27))       # 5.20
```
```cpp
#include <iostream>
#include <cmath>
#include <iomanip>

class Task167 {
public:
    static double cubeDiagonal(double volume) {
        double sideLength = std::cbrt(volume);
        double diagonal = sideLength * std::sqrt(3);
        return std::round(diagonal * 100.0) / 100.0;
    }
};

int main() {
    std::cout << std::fixed << std::setprecision(2);
    std::cout << Task167::cubeDiagonal(8) << std::endl;        // 3.46
    std::cout << Task167::cubeDiagonal(343) << std::endl;      // 12.12
    std::cout << Task167::cubeDiagonal(1157.625) << std::endl; // 18.19
    std::cout << Task167::cubeDiagonal(1) << std::endl;        // 1.73
    std::cout << Task167::cubeDiagonal(27) << std::endl;       // 5.20
    return 0;
}
```
```c
#include <stdio.h>
#include <math.h>

double cubeDiagonal(double volume) {
    double sideLength = cbrt(volume);
    double diagonal = sideLength * sqrt(3);
    return round(diagonal * 100.0) / 100.0;
}

int main() {
    printf("%.2f\n", cubeDiagonal(8));        // 3.46
    printf("%.2f\n", cubeDiagonal(343));      // 12.12
    printf("%.2f\n", cubeDiagonal(1157.625)); // 18.19
    printf("%.2f\n", cubeDiagonal(1));        // 1.73
    printf("%.2f\n", cubeDiagonal(27));       // 5.20
    return 0;
}
```
Created file: Task167.java
Created file: Task167.py
Created file: Task167.cpp
Created file: Task167.c
Task168_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task168, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a function that tweaks letters by one forward (+1) or backwards (-1) according to an array.

Examples
tweakLetters("apple", {0, 1, -1, 0, -1})  "aqold"
// "p" + 1 => "q"; "p" - 1 => "o"; "e" - 1 => "d"

tweakLetters("many", {0, 0, 0, -1})  "manx"

tweakLetters("rhino", {1, 1, 1, 1, 1})  "sijop"
Notes
Don't worry about capital letters.
```java
public class Task168 {
    public static String tweakLetters(String word, int[] tweaks) {
        if (word.length() != tweaks.length) {
            throw new IllegalArgumentException("Word length and tweaks array length must be the same.");
        }

        StringBuilder result = new StringBuilder();
        for (int i = 0; i < word.length(); i++) {
            char tweakedChar = (char) (word.charAt(i) + tweaks[i]);
            result.append(tweakedChar);
        }
        return result.toString();
    }

    public static void main(String[] args) {
        System.out.println(tweakLetters("apple", new int[]{0, 1, -1, 0, -1})); // "aqold"
        System.out.println(tweakLetters("many", new int[]{0, 0, 0, -1})); // "manx"
        System.out.println(tweakLetters("rhino", new int[]{1, 1, 1, 1, 1})); // "sijop"
        System.out.println(tweakLetters("java", new int[]{1, -1, 1, 0})); // "kbwb"
        System.out.println(tweakLetters("code", new int[]{0, 0, 1, -1})); // "codd"
    }
}
```
```python
def tweak_letters(word, tweaks):
    if len(word) != len(tweaks):
        raise ValueError("Word length and tweaks list length must be the same.")

    result = ''.join(chr(ord(c) + t) for c, t in zip(word, tweaks))
    return result

if __name__ == "__main__":
    print(tweak_letters("apple", [0, 1, -1, 0, -1]))  # "aqold"
    print(tweak_letters("many", [0, 0, 0, -1]))       # "manx"
    print(tweak_letters("rhino", [1, 1, 1, 1, 1]))    # "sijop"
    print(tweak_letters("java", [1, -1, 1, 0]))       # "kbwb"
    print(tweak_letters("code", [0, 0, 1, -1]))       # "codd"
```
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>

class Task168 {
public:
    static std::string tweakLetters(const std::string& word, const std::vector<int>& tweaks) {
        if (word.length() != tweaks.size()) {
            throw std::invalid_argument("Word length and tweaks array length must be the same.");
        }

        std::string result;
        for (size_t i = 0; i < word.length(); ++i) {
            char tweakedChar = word[i] + tweaks[i];
            result += tweakedChar;
        }
        return result;
    }
};

int main() {
    std::cout << Task168::tweakLetters("apple", {0, 1, -1, 0, -1}) << std::endl; // "aqold"
    std::cout << Task168::tweakLetters("many", {0, 0, 0, -1}) << std::endl;      // "manx"
    std::cout << Task168::tweakLetters("rhino", {1, 1, 1, 1, 1}) << std::endl;   // "sijop"
    std::cout << Task168::tweakLetters("java", {1, -1, 1, 0}) << std::endl;      // "kbwb"
    std::cout << Task168::tweakLetters("code", {0, 0, 1, -1}) << std::endl;      // "codd"
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* tweakLetters(const char* word, const int* tweaks, size_t length) {
    if (strlen(word) != length) {
        fprintf(stderr, "Word length and tweaks array length must be the same.\n");
        exit(EXIT_FAILURE);
    }

    char* result = (char*)malloc((length + 1) * sizeof(char));
    if (result == NULL) {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(EXIT_FAILURE);
    }

    for (size_t i = 0; i < length; i++) {
        result[i] = word[i] + tweaks[i];
    }
    result[length] = '\0';
    return result;
}

int main() {
    char* result;

    result = tweakLetters("apple", (int[]){0, 1, -1, 0, -1}, 5);
    printf("%s\n", result); // "aqold"
    free(result);

    result = tweakLetters("many", (int[]){0, 0, 0, -1}, 4);
    printf("%s\n", result); // "manx"
    free(result);

    result = tweakLetters("rhino", (int[]){1, 1, 1, 1, 1}, 5);
    printf("%s\n", result); // "sijop"
    free(result);

    result = tweakLetters("java", (int[]){1, -1, 1, 0}, 4);
    printf("%s\n", result); // "kbwb"
    free(result);

    result = tweakLetters("code", (int[]){0, 0, 1, -1}, 4);
    printf("%s\n", result); // "codd"
    free(result);

    return 0;
}
```
Created file: Task168.java
Created file: Task168.py
Created file: Task168.cpp
Created file: Task168.c
Task169_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task169, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].



Example 1:

Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.
Example 2:

Input: nums = [-1]
Output: [0]
Example 3:

Input: nums = [-1,-1]
Output: [0,0]


Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
```java
public class Task169 {
    public int[] countSmaller(int[] nums) {
        int[] counts = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] < nums[i]) {
                    counts[i]++;
                }
            }
        }
        return counts;
    }

    public static void main(String[] args) {
        Task169 task = new Task169();
        int[] result1 = task.countSmaller(new int[]{5, 2, 6, 1});
        int[] result2 = task.countSmaller(new int[]{-1});
        int[] result3 = task.countSmaller(new int[]{-1, -1});
        int[] result4 = task.countSmaller(new int[]{3, 2, 1, 0});
        int[] result5 = task.countSmaller(new int[]{0, 0, 0, 0});

        System.out.println(java.util.Arrays.toString(result1));
        System.out.println(java.util.Arrays.toString(result2));
        System.out.println(java.util.Arrays.toString(result3));
        System.out.println(java.util.Arrays.toString(result4));
        System.out.println(java.util.Arrays.toString(result5));
    }
}
```
```python
class Task169:
    def count_smaller(self, nums):
        counts = [0] * len(nums)
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[i]:
                    counts[i] += 1
        return counts

def main():
    task = Task169()
    result1 = task.count_smaller([5, 2, 6, 1])
    result2 = task.count_smaller([-1])
    result3 = task.count_smaller([-1, -1])
    result4 = task.count_smaller([3, 2, 1, 0])
    result5 = task.count_smaller([0, 0, 0, 0])

    print(result1)
    print(result2)
    print(result3)
    print(result4)
    print(result5)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>

class Task169 {
public:
    std::vector<int> countSmaller(std::vector<int>& nums) {
        std::vector<int> counts(nums.size(), 0);
        for (size_t i = 0; i < nums.size(); ++i) {
            for (size_t j = i + 1; j < nums.size(); ++j) {
                if (nums[j] < nums[i]) {
                    counts[i]++;
                }
            }
        }
        return counts;
    }
};

int main() {
    Task169 task;
    std::vector<int> nums1 = {5, 2, 6, 1};
    std::vector<int> nums2 = {-1};
    std::vector<int> nums3 = {-1, -1};
    std::vector<int> nums4 = {3, 2, 1, 0};
    std::vector<int> nums5 = {0, 0, 0, 0};

    std::vector<int> result1 = task.countSmaller(nums1);
    std::vector<int> result2 = task.countSmaller(nums2);
    std::vector<int> result3 = task.countSmaller(nums3);
    std::vector<int> result4 = task.countSmaller(nums4);
    std::vector<int> result5 = task.countSmaller(nums5);

    for (auto res : result1) std::cout << res << " ";
    std::cout << std::endl;
    for (auto res : result2) std::cout << res << " ";
    std::cout << std::endl;
    for (auto res : result3) std::cout << res << " ";
    std::cout << std::endl;
    for (auto res : result4) std::cout << res << " ";
    std::cout << std::endl;
    for (auto res : result5) std::cout << res << " ";
    std::cout << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void countSmaller(int* nums, int numsSize, int* counts) {
    for (int i = 0; i < numsSize; i++) {
        counts[i] = 0;
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[j] < nums[i]) {
                counts[i]++;
            }
        }
    }
}

int main() {
    int nums1[] = {5, 2, 6, 1};
    int nums2[] = {-1};
    int nums3[] = {-1, -1};
    int nums4[] = {3, 2, 1, 0};
    int nums5[] = {0, 0, 0, 0};

    int counts1[4];
    int counts2[1];
    int counts3[2];
    int counts4[4];
    int counts5[4];

    countSmaller(nums1, 4, counts1);
    countSmaller(nums2, 1, counts2);
    countSmaller(nums3, 2, counts3);
    countSmaller(nums4, 4, counts4);
    countSmaller(nums5, 4, counts5);

    for (int i = 0; i < 4; i++) printf("%d ", counts1[i]);
    printf("\n");
    for (int i = 0; i < 1; i++) printf("%d ", counts2[i]);
    printf("\n");
    for (int i = 0; i < 2; i++) printf("%d ", counts3[i]);
    printf("\n");
    for (int i = 0; i < 4; i++) printf("%d ", counts4[i]);
    printf("\n");
    for (int i = 0; i < 4; i++) printf("%d ", counts5[i]);
    printf("\n");

    return 0;
}
```
Created file: Task169.java
Created file: Task169.py
Created file: Task169.cpp
Created file: Task169.c
Task170_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task170, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.

Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.



Example 1:

Input: nums = [-2,5,-1], lower = -2, upper = 2
Output: 3
Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.
Example 2:

Input: nums = [0], lower = 0, upper = 0
Output: 1


Constraints:

1 <= nums.length <= 10^5
-2^31 <= nums[i] <= 2^31 - 1
-10^5 <= lower <= upper <= 10^5
The answer is guaranteed to fit in a 32-bit integer.
```java
public class Task170 {
    public static void main(String[] args) {
        int[] nums1 = {-2, 5, -1};
        System.out.println(countRangeSum(nums1, -2, 2)); // 3

        int[] nums2 = {0};
        System.out.println(countRangeSum(nums2, 0, 0)); // 1

        int[] nums3 = {1, 2, 3, 4, 5};
        System.out.println(countRangeSum(nums3, 3, 8)); // 6

        int[] nums4 = {0, 0, 0, 0};
        System.out.println(countRangeSum(nums4, 0, 0)); // 10

        int[] nums5 = {-3, 1, 2, -2, 2, -1};
        System.out.println(countRangeSum(nums5, -3, 1)); // 10
    }

    public static int countRangeSum(int[] nums, int lower, int upper) {
        return countRangeSumRecursive(nums, 0, nums.length - 1, lower, upper);
    }

    private static int countRangeSumRecursive(int[] nums, int left, int right, int lower, int upper) {
        if (left > right) return 0;
        if (left == right) return nums[left] >= lower && nums[left] <= upper ? 1 : 0;

        int mid = left + (right - left) / 2;
        int count = countRangeSumRecursive(nums, left, mid, lower, upper)
                  + countRangeSumRecursive(nums, mid + 1, right, lower, upper);

        long[] prefixSums = new long[right - left + 1];
        prefixSums[0] = nums[left];
        for (int i = left + 1; i <= right; i++) {
            prefixSums[i - left] = prefixSums[i - left - 1] + nums[i];
        }

        java.util.Arrays.sort(prefixSums);

        for (int i = 0; i < prefixSums.length; i++) {
            long prefixSumLeft = prefixSums[i] - upper;
            long prefixSumRight = prefixSums[i] - lower;
            count += countInRange(prefixSums, mid - left + 1, prefixSumLeft, prefixSumRight);
        }

        return count;
    }

    private static int countInRange(long[] prefixSums, int start, long left, long right) {
        int low = java.util.Arrays.binarySearch(prefixSums, start, prefixSums.length, left);
        int high = java.util.Arrays.binarySearch(prefixSums, start, prefixSums.length, right);

        if (low < 0) low = -low - 1;
        if (high < 0) high = -high - 1;
        else high++;

        return high - low;
    }
}
```
```python
def count_range_sum(nums, lower, upper):
    def count_and_merge_sort(sums, start, end):
        if end - start <= 1:
            return 0
        mid = (start + end) // 2
        count = count_and_merge_sort(sums, start, mid) + count_and_merge_sort(sums, mid, end)
        j = k = t = mid
        cache = []
        for i in range(start, mid):
            while k < end and sums[k] - sums[i] < lower:
                k += 1
            while j < end and sums[j] - sums[i] <= upper:
                j += 1
            while t < end and sums[t] < sums[i]:
                cache.append(sums[t])
                t += 1
            cache.append(sums[i])
            count += j - k
        sums[start:start + len(cache)] = cache
        return count

    sums = [0]
    for num in nums:
        sums.append(sums[-1] + num)
    return count_and_merge_sort(sums, 0, len(sums))

if __name__ == "__main__":
    nums1 = [-2, 5, -1]
    print(count_range_sum(nums1, -2, 2))  # 3

    nums2 = [0]
    print(count_range_sum(nums2, 0, 0))  # 1

    nums3 = [1, 2, 3, 4, 5]
    print(count_range_sum(nums3, 3, 8))  # 6

    nums4 = [0, 0, 0, 0]
    print(count_range_sum(nums4, 0, 0))  # 10

    nums5 = [-3, 1, 2, -2, 2, -1]
    print(count_range_sum(nums5, -3, 1))  # 10
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Task170 {
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        vector<long> sums(nums.size() + 1, 0);
        for (int i = 0; i < nums.size(); ++i) {
            sums[i + 1] = sums[i] + nums[i];
        }
        return countAndMergeSort(sums, 0, nums.size() + 1, lower, upper);
    }

    int countAndMergeSort(vector<long>& sums, int start, int end, int lower, int upper) {
        if (end - start <= 1) return 0;
        int mid = (start + end) / 2;
        int count = countAndMergeSort(sums, start, mid, lower, upper) + countAndMergeSort(sums, mid, end, lower, upper);

        int j = mid, k = mid, t = mid;
        vector<long> cache;
        for (int i = start; i < mid; ++i) {
            while (k < end && sums[k] - sums[i] < lower) k++;
            while (j < end && sums[j] - sums[i] <= upper) j++;
            while (t < end && sums[t] < sums[i]) cache.push_back(sums[t++]);
            cache.push_back(sums[i]);
            count += j - k;
        }
        move(cache.begin(), cache.end(), sums.begin() + start);
        return count;
    }
};

int main() {
    Task170 task;
    vector<int> nums1 = {-2, 5, -1};
    cout << task.countRangeSum(nums1, -2, 2) << endl; // 3

    vector<int> nums2 = {0};
    cout << task.countRangeSum(nums2, 0, 0) << endl; // 1

    vector<int> nums3 = {1, 2, 3, 4, 5};
    cout << task.countRangeSum(nums3, 3, 8) << endl; // 6

    vector<int> nums4 = {0, 0, 0, 0};
    cout << task.countRangeSum(nums4, 0, 0) << endl; // 10

    vector<int> nums5 = {-3, 1, 2, -2, 2, -1};
    cout << task.countRangeSum(nums5, -3, 1) << endl; // 10

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int countAndMergeSort(long* sums, int start, int end, int lower, int upper);
int countRangeSum(int* nums, int numsSize, int lower, int upper);

int countRangeSum(int* nums, int numsSize, int lower, int upper) {
    long* sums = (long*)calloc(numsSize + 1, sizeof(long));
    for (int i = 0; i < numsSize; ++i) {
        sums[i + 1] = sums[i] + nums[i];
    }
    int result = countAndMergeSort(sums, 0, numsSize + 1, lower, upper);
    free(sums);
    return result;
}

int countAndMergeSort(long* sums, int start, int end, int lower, int upper) {
    if (end - start <= 1) return 0;
    int mid = (start + end) / 2;
    int count = countAndMergeSort(sums, start, mid, lower, upper)
              + countAndMergeSort(sums, mid, end, lower, upper);

    int j = mid, k = mid, t = mid;
    long* cache = (long*)malloc((end - start) * sizeof(long));
    int cacheIndex = 0;
    for (int i = start; i < mid; ++i) {
        while (k < end && sums[k] - sums[i] < lower) k++;
        while (j < end && sums[j] - sums[i] <= upper) j++;
        while (t < end && sums[t] < sums[i]) cache[cacheIndex++] = sums[t++];
        cache[cacheIndex++] = sums[i];
        count += j - k;
    }
    for (int i = 0; i < cacheIndex; ++i) {
        sums[start + i] = cache[i];
    }
    free(cache);
    return count;
}

int main() {
    int nums1[] = {-2, 5, -1};
    printf("%d\n", countRangeSum(nums1, 3, -2, 2)); // 3

    int nums2[] = {0};
    printf("%d\n", countRangeSum(nums2, 1, 0, 0)); // 1

    int nums3[] = {1, 2, 3, 4, 5};
    printf("%d\n", countRangeSum(nums3, 5, 3, 8)); // 6

    int nums4[] = {0, 0, 0, 0};
    printf("%d\n", countRangeSum(nums4, 4, 0, 0)); // 10

    int nums5[] = {-3, 1, 2, -2, 2, -1};
    printf("%d\n", countRangeSum(nums5, 6, -3, 1)); // 10

    return 0;
}
```
Created file: Task170.java
Created file: Task170.py
Created file: Task170.cpp
Created file: Task170.c
Task171_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task171, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an integer array nums, return the number of reverse pairs in the array.

A reverse pair is a pair (i, j) where:

0 <= i < j < nums.length and
nums[i] > 2 * nums[j].


Example 1:

Input: nums = [1,3,2,3,1]
Output: 2
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1
Example 2:

Input: nums = [2,4,3,5,1]
Output: 3
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1
(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1


Constraints:

1 <= nums.length <= 5 * 10^4
-2^31 <= nums[i] <= 2^31 - 1
```java
public class Task171 {
    public static void main(String[] args) {
        System.out.println(reversePairs(new int[]{1, 3, 2, 3, 1})); // Output: 2
        System.out.println(reversePairs(new int[]{2, 4, 3, 5, 1})); // Output: 3
        System.out.println(reversePairs(new int[]{0, 0, 0, 0, 0})); // Output: 0
        System.out.println(reversePairs(new int[]{1, 1, 1, 1, 1})); // Output: 0
        System.out.println(reversePairs(new int[]{5, 4, 3, 2, 1})); // Output: 4
    }

    public static int reversePairs(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        return mergeSort(nums, 0, nums.length - 1);
    }

    private static int mergeSort(int[] nums, int left, int right) {
        if (left >= right) {
            return 0;
        }
        int mid = left + (right - left) / 2;
        int count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);
        int j = mid + 1;
        for (int i = left; i <= mid; i++) {
            while (j <= right && nums[i] > 2L * nums[j]) {
                j++;
            }
            count += j - (mid + 1);
        }
        merge(nums, left, mid, right);
        return count;
    }

    private static void merge(int[] nums, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            } else {
                temp[k++] = nums[j++];
            }
        }
        while (i <= mid) {
            temp[k++] = nums[i++];
        }
        while (j <= right) {
            temp[k++] = nums[j++];
        }
        System.arraycopy(temp, 0, nums, left, temp.length);
    }
}
```
```python
def reverse_pairs(nums):
    if not nums or len(nums) < 2:
        return 0

    def merge_sort(nums, left, right):
        if left >= right:
            return 0
        mid = (left + right) // 2
        count = merge_sort(nums, left, mid) + merge_sort(nums, mid + 1, right)
        j = mid + 1
        for i in range(left, mid + 1):
            while j <= right and nums[i] > 2 * nums[j]:
                j += 1
            count += j - (mid + 1)
        nums[left:right + 1] = sorted(nums[left:right + 1])
        return count

    return merge_sort(nums, 0, len(nums) - 1)

if __name__ == "__main__":
    print(reverse_pairs([1, 3, 2, 3, 1]))  # Output: 2
    print(reverse_pairs([2, 4, 3, 5, 1]))  # Output: 3
    print(reverse_pairs([0, 0, 0, 0, 0]))  # Output: 0
    print(reverse_pairs([1, 1, 1, 1, 1]))  # Output: 0
    print(reverse_pairs([5, 4, 3, 2, 1]))  # Output: 4
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Task171 {
public:
    static int reversePairs(vector<int>& nums) {
        if (nums.size() < 2) return 0;
        return mergeSort(nums, 0, nums.size() - 1);
    }

private:
    static int mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right) return 0;
        int mid = left + (right - left) / 2;
        int count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);
        int j = mid + 1;
        for (int i = left; i <= mid; i++) {
            while (j <= right && nums[i] > 2LL * nums[j]) {
                j++;
            }
            count += j - (mid + 1);
        }
        inplace_merge(nums.begin() + left, nums.begin() + mid + 1, nums.begin() + right + 1);
        return count;
    }
};

int main() {
    vector<int> nums1 = {1, 3, 2, 3, 1};
    cout << Task171::reversePairs(nums1) << endl; // Output: 2

    vector<int> nums2 = {2, 4, 3, 5, 1};
    cout << Task171::reversePairs(nums2) << endl; // Output: 3

    vector<int> nums3 = {0, 0, 0, 0, 0};
    cout << Task171::reversePairs(nums3) << endl; // Output: 0

    vector<int> nums4 = {1, 1, 1, 1, 1};
    cout << Task171::reversePairs(nums4) << endl; // Output: 0

    vector<int> nums5 = {5, 4, 3, 2, 1};
    cout << Task171::reversePairs(nums5) << endl; // Output: 4

    return 0;
}
```
```c
#include <stdio.h>

int merge(int* nums, int left, int mid, int right) {
    int count = 0;
    int j = mid + 1;
    for (int i = left; i <= mid; i++) {
        while (j <= right && nums[i] > 2L * nums[j]) {
            j++;
        }
        count += j - (mid + 1);
    }

    int temp[right - left + 1];
    int i = left, k = 0;
    j = mid + 1;
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp[k++] = nums[i++];
        } else {
            temp[k++] = nums[j++];
        }
    }
    while (i <= mid) {
        temp[k++] = nums[i++];
    }
    while (j <= right) {
        temp[k++] = nums[j++];
    }
    for (i = left, k = 0; i <= right; i++, k++) {
        nums[i] = temp[k];
    }
    return count;
}

int mergeSort(int* nums, int left, int right) {
    if (left >= right) return 0;
    int mid = left + (right - left) / 2;
    int count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);
    count += merge(nums, left, mid, right);
    return count;
}

int reversePairs(int* nums, int numsSize) {
    if (numsSize < 2) return 0;
    return mergeSort(nums, 0, numsSize - 1);
}

int main() {
    int nums1[] = {1, 3, 2, 3, 1};
    printf("%d\n", reversePairs(nums1, 5)); // Output: 2

    int nums2[] = {2, 4, 3, 5, 1};
    printf("%d\n", reversePairs(nums2, 5)); // Output: 3

    int nums3[] = {0, 0, 0, 0, 0};
    printf("%d\n", reversePairs(nums3, 5)); // Output: 0

    int nums4[] = {1, 1, 1, 1, 1};
    printf("%d\n", reversePairs(nums4, 5)); // Output: 0

    int nums5[] = {5, 4, 3, 2, 1};
    printf("%d\n", reversePairs(nums5, 5)); // Output: 4

    return 0;
}
```
Created file: Task171.java
Created file: Task171.py
Created file: Task171.cpp
Created file: Task171.c
Task172_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task172, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).



Example 1:

Input: text = "abcabcabc"
Output: 3
Explanation: The 3 substrings are "abcabc", "bcabca" and "cabcab".
Example 2:

Input: text = "leetcodeleetcode"
Output: 2
Explanation: The 2 substrings are "ee" and "leetcodeleetcode".


Constraints:

1 <= text.length <= 2000
text has only lowercase English letters.
```java
public class Task172 {
    public static int distinctEchoSubstrings(String text) {
        HashSet<String> result = new HashSet<>();
        for (int i = 0; i < text.length(); i++) {
            for (int len = 1; i + 2 * len <= text.length(); len++) {
                if (text.substring(i, i + len).equals(text.substring(i + len, i + 2 * len))) {
                    result.add(text.substring(i, i + 2 * len));
                }
            }
        }
        return result.size();
    }

    public static void main(String[] args) {
        System.out.println(distinctEchoSubstrings("abcabcabc")); // Output: 3
        System.out.println(distinctEchoSubstrings("leetcodeleetcode")); // Output: 2
        System.out.println(distinctEchoSubstrings("abab")); // Output: 1
        System.out.println(distinctEchoSubstrings("aaaa")); // Output: 2
        System.out.println(distinctEchoSubstrings("abcd")); // Output: 0
    }
}
```
```python
def distinct_echo_substrings(text):
    result = set()
    for i in range(len(text)):
        for length in range(1, (len(text) - i) // 2 + 1):
            if text[i:i+length] == text[i+length:i+2*length]:
                result.add(text[i:i+2*length])
    return len(result)

def main():
    print(distinct_echo_substrings("abcabcabc"))  # Output: 3
    print(distinct_echo_substrings("leetcodeleetcode"))  # Output: 2
    print(distinct_echo_substrings("abab"))  # Output: 1
    print(distinct_echo_substrings("aaaa"))  # Output: 2
    print(distinct_echo_substrings("abcd"))  # Output: 0

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <unordered_set>

class Task172 {
public:
    static int distinctEchoSubstrings(const std::string& text) {
        std::unordered_set<std::string> result;
        for (size_t i = 0; i < text.length(); ++i) {
            for (size_t len = 1; i + 2 * len <= text.length(); ++len) {
                if (text.substr(i, len) == text.substr(i + len, len)) {
                    result.insert(text.substr(i, 2 * len));
                }
            }
        }
        return result.size();
    }

    static void main() {
        std::cout << distinctEchoSubstrings("abcabcabc") << std::endl; // Output: 3
        std::cout << distinctEchoSubstrings("leetcodeleetcode") << std::endl; // Output: 2
        std::cout << distinctEchoSubstrings("abab") << std::endl; // Output: 1
        std::cout << distinctEchoSubstrings("aaaa") << std::endl; // Output: 2
        std::cout << distinctEchoSubstrings("abcd") << std::endl; // Output: 0
    }
};

int main() {
    Task172::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool areEqual(const char* s1, const char* s2, int length) {
    for (int i = 0; i < length; i++) {
        if (s1[i] != s2[i]) {
            return false;
        }
    }
    return true;
}

int distinctEchoSubstrings(const char* text) {
    int resultCount = 0;
    int textLength = strlen(text);
    bool found[textLength];
    memset(found, 0, sizeof(found));

    for (int i = 0; i < textLength; i++) {
        for (int len = 1; i + 2 * len <= textLength; len++) {
            if (areEqual(text + i, text + i + len, len)) {
                if (!found[i]) {
                    resultCount++;
                    found[i] = true;
                }
            }
        }
    }
    return resultCount;
}

int main() {
    printf("%d\n", distinctEchoSubstrings("abcabcabc")); // Output: 3
    printf("%d\n", distinctEchoSubstrings("leetcodeleetcode")); // Output: 2
    printf("%d\n", distinctEchoSubstrings("abab")); // Output: 1
    printf("%d\n", distinctEchoSubstrings("aaaa")); // Output: 2
    printf("%d\n", distinctEchoSubstrings("abcd")); // Output: 0
    return 0;
}
```
Created file: Task172.java
Created file: Task172.py
Created file: Task172.cpp
Created file: Task172.c
Task173_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task173, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.

Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is "".



Example 1:

Input: s = "banana"
Output: "ana"
Example 2:

Input: s = "abcd"
Output: ""


Constraints:

2 <= s.length <= 3 * 10^4
s consists of lowercase English letters.
```java
import java.util.HashSet;

public class Task173 {
    public static void main(String[] args) {
        System.out.println(longestDupSubstring("banana")); // Output: "ana"
        System.out.println(longestDupSubstring("abcd"));   // Output: ""
        System.out.println(longestDupSubstring("abcabc")); // Output: "abc"
        System.out.println(longestDupSubstring("aaaaa"));  // Output: "aaaa"
        System.out.println(longestDupSubstring("abcdefg")); // Output: ""
    }

    public static String longestDupSubstring(String s) {
        int left = 1, right = s.length();
        String result = "";
        while (left < right) {
            int mid = left + (right - left) / 2;
            String dup = search(s, mid);
            if (dup != null) {
                result = dup;
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return result;
    }

    private static String search(String s, int len) {
        HashSet<String> seen = new HashSet<>();
        for (int i = 0; i <= s.length() - len; i++) {
            String substring = s.substring(i, i + len);
            if (seen.contains(substring)) {
                return substring;
            }
            seen.add(substring);
        }
        return null;
    }
}
```
```python
def longestDupSubstring(s: str) -> str:
    def search(length: int) -> str:
        seen = set()
        for i in range(len(s) - length + 1):
            substring = s[i:i + length]
            if substring in seen:
                return substring
            seen.add(substring)
        return ""

    left, right = 1, len(s)
    result = ""
    while left < right:
        mid = left + (right - left) // 2
        dup = search(mid)
        if dup:
            result = dup
            left = mid + 1
        else:
            right = mid
    return result

if __name__ == "__main__":
    print(longestDupSubstring("banana"))  # Output: "ana"
    print(longestDupSubstring("abcd"))    # Output: ""
    print(longestDupSubstring("abcabc"))  # Output: "abc"
    print(longestDupSubstring("aaaaa"))   # Output: "aaaa"
    print(longestDupSubstring("abcdefg")) # Output: ""
```
```cpp
#include <iostream>
#include <unordered_set>
#include <string>

class Task173 {
public:
    static std::string longestDupSubstring(const std::string &s) {
        int left = 1, right = s.size();
        std::string result;
        while (left < right) {
            int mid = left + (right - left) / 2;
            std::string dup = search(s, mid);
            if (!dup.empty()) {
                result = dup;
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return result;
    }

    static void runTests() {
        std::cout << longestDupSubstring("banana") << std::endl; // Output: "ana"
        std::cout << longestDupSubstring("abcd") << std::endl;   // Output: ""
        std::cout << longestDupSubstring("abcabc") << std::endl; // Output: "abc"
        std::cout << longestDupSubstring("aaaaa") << std::endl;  // Output: "aaaa"
        std::cout << longestDupSubstring("abcdefg") << std::endl; // Output: ""
    }

private:
    static std::string search(const std::string &s, int len) {
        std::unordered_set<std::string> seen;
        for (size_t i = 0; i <= s.size() - len; ++i) {
            std::string substring = s.substr(i, len);
            if (seen.count(substring)) {
                return substring;
            }
            seen.insert(substring);
        }
        return "";
    }
};

int main() {
    Task173::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* search(const char* s, int len) {
    int s_len = strlen(s);
    char* seen[s_len];
    int seen_count = 0;

    for (int i = 0; i <= s_len - len; i++) {
        char* substring = (char*)malloc(len + 1);
        strncpy(substring, s + i, len);
        substring[len] = '\0';

        for (int j = 0; j < seen_count; j++) {
            if (strcmp(seen[j], substring) == 0) {
                for (int k = 0; k < seen_count; k++) {
                    free(seen[k]);
                }
                return substring;
            }
        }

        seen[seen_count++] = substring;
    }

    for (int i = 0; i < seen_count; i++) {
        free(seen[i]);
    }
    return NULL;
}

char* longestDupSubstring(const char* s) {
    int left = 1, right = strlen(s);
    char* result = "";

    while (left < right) {
        int mid = left + (right - left) / 2;
        char* dup = search(s, mid);

        if (dup != NULL) {
            result = dup;
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return result;
}

int main() {
    printf("%s\n", longestDupSubstring("banana")); // Output: "ana"
    printf("%s\n", longestDupSubstring("abcd"));   // Output: ""
    printf("%s\n", longestDupSubstring("abcabc")); // Output: "abc"
    printf("%s\n", longestDupSubstring("aaaaa"));  // Output: "aaaa"
    printf("%s\n", longestDupSubstring("abcdefg")); // Output: ""

    return 0;
}
```
Created file: Task173.java
Created file: Task173.py
Created file: Task173.cpp
Created file: Task173.c
Task174_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task174, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given a string s. You can convert s to a
palindrome
 by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.



Example 1:

Input: s = "aacecaaa"
Output: "aaacecaaa"
Example 2:

Input: s = "abcd"
Output: "dcbabcd"


Constraints:

0 <= s.length <= 5 * 10^4
s consists of lowercase English letters only.
```java
public class Task174 {
    public static String shortestPalindrome(String s) {
        if (s == null || s.length() == 0) return s;

        String rev = new StringBuilder(s).reverse().toString();
        String l = s + "#" + rev;

        int[] p = new int[l.length()];
        for (int i = 1; i < l.length(); i++) {
            int j = p[i - 1];
            while (j > 0 && l.charAt(i) != l.charAt(j)) {
                j = p[j - 1];
            }
            p[i] = j + (l.charAt(i) == l.charAt(j) ? 1 : 0);
        }

        return rev.substring(0, s.length() - p[l.length() - 1]) + s;
    }

    public static void main(String[] args) {
        System.out.println(shortestPalindrome("aacecaaa")); // Output: "aaacecaaa"
        System.out.println(shortestPalindrome("abcd"));     // Output: "dcbabcd"
        System.out.println(shortestPalindrome(""));         // Output: ""
        System.out.println(shortestPalindrome("a"));        // Output: "a"
        System.out.println(shortestPalindrome("racecar"));  // Output: "racecar"
    }
}
```
```python
def shortest_palindrome(s: str) -> str:
    if not s:
        return s

    rev = s[::-1]
    l = s + "#" + rev

    p = [0] * len(l)
    for i in range(1, len(l)):
        j = p[i - 1]
        while j > 0 and l[i] != l[j]:
            j = p[j - 1]
        p[i] = j + (l[i] == l[j])

    return rev[:len(s) - p[-1]] + s

if __name__ == "__main__":
    print(shortest_palindrome("aacecaaa")) # Output: "aaacecaaa"
    print(shortest_palindrome("abcd"))     # Output: "dcbabcd"
    print(shortest_palindrome(""))         # Output: ""
    print(shortest_palindrome("a"))        # Output: "a"
    print(shortest_palindrome("racecar"))  # Output: "racecar"
```
```cpp
#include <iostream>
#include <string>
#include <vector>

class Task174 {
public:
    static std::string shortestPalindrome(const std::string& s) {
        if (s.empty()) return s;

        std::string rev = std::string(s.rbegin(), s.rend());
        std::string l = s + "#" + rev;

        std::vector<int> p(l.size(), 0);
        for (size_t i = 1; i < l.size(); i++) {
            int j = p[i - 1];
            while (j > 0 && l[i] != l[j]) {
                j = p[j - 1];
            }
            p[i] = j + (l[i] == l[j]);
        }

        return rev.substr(0, s.size() - p.back()) + s;
    }
};

int main() {
    std::cout << Task174::shortestPalindrome("aacecaaa") << std::endl; // Output: "aaacecaaa"
    std::cout << Task174::shortestPalindrome("abcd") << std::endl;     // Output: "dcbabcd"
    std::cout << Task174::shortestPalindrome("") << std::endl;         // Output: ""
    std::cout << Task174::shortestPalindrome("a") << std::endl;        // Output: "a"
    std::cout << Task174::shortestPalindrome("racecar") << std::endl;  // Output: "racecar"
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

char* shortestPalindrome(const char* s) {
    if (s == NULL || strlen(s) == 0) return strdup(s);

    size_t len = strlen(s);
    char* rev = (char*)malloc(len + 1);
    for (size_t i = 0; i < len; ++i) {
        rev[i] = s[len - 1 - i];
    }
    rev[len] = '\0';

    char* l = (char*)malloc(2 * len + 2);
    snprintf(l, 2 * len + 2, "%s#%s", s, rev);

    int* p = (int*)calloc(strlen(l), sizeof(int));
    for (size_t i = 1; i < strlen(l); ++i) {
        int j = p[i - 1];
        while (j > 0 && l[i] != l[j]) {
            j = p[j - 1];
        }
        p[i] = j + (l[i] == l[j] ? 1 : 0);
    }

    size_t newLen = len - p[strlen(l) - 1];
    char* result = (char*)malloc(newLen + len + 1);
    snprintf(result, newLen + 1, "%s", rev + len - newLen);
    strcat(result, s);

    free(rev);
    free(l);
    free(p);

    return result;
}

int main() {
    printf("%s\n", shortestPalindrome("aacecaaa")); // Output: "aaacecaaa"
    printf("%s\n", shortestPalindrome("abcd"));     // Output: "dcbabcd"
    printf("%s\n", shortestPalindrome(""));         // Output: ""
    printf("%s\n", shortestPalindrome("a"));        // Output: "a"
    printf("%s\n", shortestPalindrome("racecar"));  // Output: "racecar"
    return 0;
}
```
Created file: Task174.java
Created file: Task174.py
Created file: Task174.cpp
Created file: Task174.c
Task175_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task175, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.



Example 1:

Input: array = [1,2,3,4,5,3,1], target = 3
Output: 2
Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.
Example 2:

Input: array = [0,1,2,4,2,1], target = 3
Output: -1
Explanation: 3 does not exist in the array, so we return -1.


Constraints:

3 <= mountain_arr.length() <= 10^4
0 <= target <= 10^9
0 <= mountain_arr.get(index) <= 10^9
```java
import java.util.*;

interface MountainArray {
    public int get(int index);
    public int length();
}

class Task175 {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int peak = findPeak(mountainArr);
        int index = binarySearch(mountainArr, target, 0, peak, true);
        if (index != -1) return index;
        return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false);
    }

    private int findPeak(MountainArray mountainArr) {
        int left = 0, right = mountainArr.length() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    private int binarySearch(MountainArray mountainArr, int target, int left, int right, boolean asc) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int value = mountainArr.get(mid);
            if (value == target) return mid;
            if (asc) {
                if (value < target) left = mid + 1;
                else right = mid - 1;
            } else {
                if (value > target) left = mid + 1;
                else right = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        // Test cases would be added here if an actual MountainArray implementation was provided
    }
}
```
```python
class MountainArray:
    def __init__(self, array):
        self.array = array

    def get(self, index: int) -> int:
        return self.array[index]

    def length(self) -> int:
        return len(self.array)

class Solution:
    def findInMountainArray(self, target: int, mountainArr: 'MountainArray') -> int:
        def find_peak():
            left, right = 0, mountainArr.length() - 1
            while left < right:
                mid = (left + right) // 2
                if mountainArr.get(mid) < mountainArr.get(mid + 1):
                    left = mid + 1
                else:
                    right = mid
            return left

        def binary_search(left, right, asc):
            while left <= right:
                mid = (left + right) // 2
                value = mountainArr.get(mid)
                if value == target:
                    return mid
                if asc:
                    if value < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                else:
                    if value > target:
                        left = mid + 1
                    else:
                        right = mid - 1
            return -1

        peak = find_peak()
        index = binary_search(0, peak, True)
        if index != -1:
            return index
        return binary_search(peak + 1, mountainArr.length() - 1, False)

# Test cases
mountainArr = MountainArray([1,2,3,4,5,3,1])
solution = Solution()
print(solution.findInMountainArray(3, mountainArr))  # Output: 2

mountainArr = MountainArray([0,1,2,4,2,1])
print(solution.findInMountainArray(3, mountainArr))  # Output: -1

mountainArr = MountainArray([0,5,3,1])
print(solution.findInMountainArray(5, mountainArr))  # Output: 1

mountainArr = MountainArray([0,1,0])
print(solution.findInMountainArray(0, mountainArr))  # Output: 0

mountainArr = MountainArray([1,5,2])
print(solution.findInMountainArray(2, mountainArr))  # Output: 2
```
```cpp
#include <vector>
#include <iostream>

using namespace std;

class MountainArray {
public:
    vector<int> array;
    MountainArray(vector<int> arr) : array(arr) {}

    int get(int index) {
        return array[index];
    }

    int length() {
        return array.size();
    }
};

class Task175 {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int peak = findPeak(mountainArr);
        int index = binarySearch(mountainArr, target, 0, peak, true);
        if (index != -1) return index;
        return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false);
    }

private:
    int findPeak(MountainArray &mountainArr) {
        int left = 0, right = mountainArr.length() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    int binarySearch(MountainArray &mountainArr, int target, int left, int right, bool asc) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int value = mountainArr.get(mid);
            if (value == target) return mid;
            if (asc) {
                if (value < target) left = mid + 1;
                else right = mid - 1;
            } else {
                if (value > target) left = mid + 1;
                else right = mid - 1;
            }
        }
        return -1;
    }
};

int main() {
    vector<int> arr1 = {1, 2, 3, 4, 5, 3, 1};
    MountainArray mountainArr1(arr1);
    Task175 solution;
    cout << solution.findInMountainArray(3, mountainArr1) << endl;  // Output: 2

    vector<int> arr2 = {0, 1, 2, 4, 2, 1};
    MountainArray mountainArr2(arr2);
    cout << solution.findInMountainArray(3, mountainArr2) << endl;  // Output: -1

    vector<int> arr3 = {0, 5, 3, 1};
    MountainArray mountainArr3(arr3);
    cout << solution.findInMountainArray(5, mountainArr3) << endl;  // Output: 1

    vector<int> arr4 = {0, 1, 0};
    MountainArray mountainArr4(arr4);
    cout << solution.findInMountainArray(0, mountainArr4) << endl;  // Output: 0

    vector<int> arr5 = {1, 5, 2};
    MountainArray mountainArr5(arr5);
    cout << solution.findInMountainArray(2, mountainArr5) << endl;  // Output: 2

    return 0;
}
```
```c
#include <stdio.h>

typedef struct {
    int *array;
    int length;
} MountainArray;

int get(MountainArray *mountainArr, int index) {
    return mountainArr->array[index];
}

int length(MountainArray *mountainArr) {
    return mountainArr->length;
}

int findPeak(MountainArray *mountainArr) {
    int left = 0, right = mountainArr->length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (get(mountainArr, mid) < get(mountainArr, mid + 1)) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

int binarySearch(MountainArray *mountainArr, int target, int left, int right, int asc) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int value = get(mountainArr, mid);
        if (value == target) return mid;
        if (asc) {
            if (value < target) left = mid + 1;
            else right = mid - 1;
        } else {
            if (value > target) left = mid + 1;
            else right = mid - 1;
        }
    }
    return -1;
}

int findInMountainArray(int target, MountainArray *mountainArr) {
    int peak = findPeak(mountainArr);
    int index = binarySearch(mountainArr, target, 0, peak, 1);
    if (index != -1) return index;
    return binarySearch(mountainArr, target, peak + 1, mountainArr->length - 1, 0);
}

int main() {
    int arr1[] = {1, 2, 3, 4, 5, 3, 1};
    MountainArray mountainArr1 = {arr1, 7};
    printf("%d\n", findInMountainArray(3, &mountainArr1));  // Output: 2

    int arr2[] = {0, 1, 2, 4, 2, 1};
    MountainArray mountainArr2 = {arr2, 6};
    printf("%d\n", findInMountainArray(3, &mountainArr2));  // Output: -1

    int arr3[] = {0, 5, 3, 1};
    MountainArray mountainArr3 = {arr3, 4};
    printf("%d\n", findInMountainArray(5, &mountainArr3));  // Output: 1

    int arr4[] = {0, 1, 0};
    MountainArray mountainArr4 = {arr4, 3};
    printf("%d\n", findInMountainArray(0, &mountainArr4));  // Output: 0

    int arr5[] = {1, 5, 2};
    MountainArray mountainArr5 = {arr5, 3};
    printf("%d\n", findInMountainArray(2, &mountainArr5));  // Output: 2

    return 0;
}
```
Created file: Task175.java
Created file: Task175.py
Created file: Task175.cpp
Created file: Task175.c
Task176_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task176, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.

Implement the ProductOfNumbers class:

ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.



Example:

Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32


Constraints:

0 <= num <= 100
1 <= k <= 4 * 10^4
At most 4 * 10^4 calls will be made to add and getProduct.
The product of the stream at any point in time will fit in a 32-bit integer.

 Hint 1
Keep all prefix products of numbers in an array, then calculate the product of last K elements in O(1) complexity.
 Hint 2
When a zero number is added, clean the array of prefix products.
```java
import java.util.*;

public class Task176 {
    public static class ProductOfNumbers {
        private List<Integer> prefixProducts;

        public ProductOfNumbers() {
            prefixProducts = new ArrayList<>();
            prefixProducts.add(1);
        }

        public void add(int num) {
            if (num == 0) {
                prefixProducts = new ArrayList<>();
                prefixProducts.add(1);
            } else {
                int lastProduct = prefixProducts.get(prefixProducts.size() - 1);
                prefixProducts.add(lastProduct * num);
            }
        }

        public int getProduct(int k) {
            int n = prefixProducts.size();
            return prefixProducts.get(n - 1) / prefixProducts.get(n - k - 1);
        }
    }

    public static void main(String[] args) {
        ProductOfNumbers productOfNumbers = new ProductOfNumbers();
        productOfNumbers.add(3);
        productOfNumbers.add(0);
        productOfNumbers.add(2);
        productOfNumbers.add(5);
        productOfNumbers.add(4);
        System.out.println(productOfNumbers.getProduct(2)); // 20
        System.out.println(productOfNumbers.getProduct(3)); // 40
        System.out.println(productOfNumbers.getProduct(4)); // 0
        productOfNumbers.add(8);
        System.out.println(productOfNumbers.getProduct(2)); // 32
    }
}
```
```python
class ProductOfNumbers:
    def __init__(self):
        self.prefix_products = [1]

    def add(self, num: int) -> None:
        if num == 0:
            self.prefix_products = [1]
        else:
            last_product = self.prefix_products[-1]
            self.prefix_products.append(last_product * num)

    def getProduct(self, k: int) -> int:
        n = len(self.prefix_products)
        return self.prefix_products[-1] // self.prefix_products[-k - 1]

if __name__ == "__main__":
    productOfNumbers = ProductOfNumbers()
    productOfNumbers.add(3)
    productOfNumbers.add(0)
    productOfNumbers.add(2)
    productOfNumbers.add(5)
    productOfNumbers.add(4)
    print(productOfNumbers.getProduct(2)) # 20
    print(productOfNumbers.getProduct(3)) # 40
    print(productOfNumbers.getProduct(4)) # 0
    productOfNumbers.add(8)
    print(productOfNumbers.getProduct(2)) # 32
```
```cpp
#include <iostream>
#include <vector>

using namespace std;

class ProductOfNumbers {
    vector<int> prefixProducts;

public:
    ProductOfNumbers() {
        prefixProducts.push_back(1);
    }

    void add(int num) {
        if (num == 0) {
            prefixProducts.clear();
            prefixProducts.push_back(1);
        } else {
            int lastProduct = prefixProducts.back();
            prefixProducts.push_back(lastProduct * num);
        }
    }

    int getProduct(int k) {
        int n = prefixProducts.size();
        return prefixProducts[n - 1] / prefixProducts[n - k - 1];
    }
};

int main() {
    ProductOfNumbers productOfNumbers;
    productOfNumbers.add(3);
    productOfNumbers.add(0);
    productOfNumbers.add(2);
    productOfNumbers.add(5);
    productOfNumbers.add(4);
    cout << productOfNumbers.getProduct(2) << endl; // 20
    cout << productOfNumbers.getProduct(3) << endl; // 40
    cout << productOfNumbers.getProduct(4) << endl; // 0
    productOfNumbers.add(8);
    cout << productOfNumbers.getProduct(2) << endl; // 32
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int* prefixProducts;
    int size;
    int capacity;
} ProductOfNumbers;

ProductOfNumbers* ProductOfNumbersCreate() {
    ProductOfNumbers* obj = (ProductOfNumbers*) malloc(sizeof(ProductOfNumbers));
    obj->capacity = 1000;
    obj->size = 1;
    obj->prefixProducts = (int*) malloc(obj->capacity * sizeof(int));
    obj->prefixProducts[0] = 1;
    return obj;
}

void ProductOfNumbersAdd(ProductOfNumbers* obj, int num) {
    if (num == 0) {
        obj->size = 1;
        obj->prefixProducts[0] = 1;
    } else {
        if (obj->size == obj->capacity) {
            obj->capacity *= 2;
            obj->prefixProducts = (int*) realloc(obj->prefixProducts, obj->capacity * sizeof(int));
        }
        int lastProduct = obj->prefixProducts[obj->size - 1];
        obj->prefixProducts[obj->size++] = lastProduct * num;
    }
}

int ProductOfNumbersGetProduct(ProductOfNumbers* obj, int k) {
    return obj->prefixProducts[obj->size - 1] / obj->prefixProducts[obj->size - k - 1];
}

void ProductOfNumbersFree(ProductOfNumbers* obj) {
    free(obj->prefixProducts);
    free(obj);
}

int main() {
    ProductOfNumbers* productOfNumbers = ProductOfNumbersCreate();
    ProductOfNumbersAdd(productOfNumbers, 3);
    ProductOfNumbersAdd(productOfNumbers, 0);
    ProductOfNumbersAdd(productOfNumbers, 2);
    ProductOfNumbersAdd(productOfNumbers, 5);
    ProductOfNumbersAdd(productOfNumbers, 4);
    printf("%d\n", ProductOfNumbersGetProduct(productOfNumbers, 2)); // 20
    printf("%d\n", ProductOfNumbersGetProduct(productOfNumbers, 3)); // 40
    printf("%d\n", ProductOfNumbersGetProduct(productOfNumbers, 4)); // 0
    ProductOfNumbersAdd(productOfNumbers, 8);
    printf("%d\n", ProductOfNumbersGetProduct(productOfNumbers, 2)); // 32
    ProductOfNumbersFree(productOfNumbers);
    return 0;
}
```
Created file: Task176.java
Created file: Task176.py
Created file: Task176.cpp
Created file: Task176.c
Task177_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task177, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.



Example 1:

Input: nums = [10,2,-10,5,20], k = 2
Output: 37
Explanation: The subsequence is [10, 2, 5, 20].
Example 2:

Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The subsequence must be non-empty, so we choose the largest number.
Example 3:

Input: nums = [10,-2,-10,-5,20], k = 2
Output: 23
Explanation: The subsequence is [10, -2, -5, 20].


Constraints:

1 <= k <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
```java
import java.util.Deque;
import java.util.LinkedList;

public class Task177 {
    public static int maxSumSubsequence(int[] nums, int k) {
        if (nums == null || nums.length == 0) return 0;
        int n = nums.length;
        int[] dp = new int[n];
        Deque<Integer> deque = new LinkedList<>();
        dp[0] = nums[0];
        deque.offer(0);

        for (int i = 1; i < n; i++) {
            while (!deque.isEmpty() && deque.peek() < i - k) {
                deque.poll();
            }
            dp[i] = nums[i] + (deque.isEmpty() ? 0 : dp[deque.peek()]);
            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);
        }

        int maxSum = Integer.MIN_VALUE;
        for (int sum : dp) {
            maxSum = Math.max(maxSum, sum);
        }
        return maxSum;
    }

    public static void main(String[] args) {
        System.out.println(maxSumSubsequence(new int[]{10, 2, -10, 5, 20}, 2)); // 37
        System.out.println(maxSumSubsequence(new int[]{-1, -2, -3}, 1)); // -1
        System.out.println(maxSumSubsequence(new int[]{10, -2, -10, -5, 20}, 2)); // 23
        System.out.println(maxSumSubsequence(new int[]{5, -1, 5, -2, 5}, 2)); // 15
        System.out.println(maxSumSubsequence(new int[]{-5, -1, -3, -4, -2}, 1)); // -1
    }
}
```
```python
from collections import deque

def max_sum_subsequence(nums, k):
    if not nums:
        return 0
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    deq = deque([0])

    for i in range(1, n):
        while deq and deq[0] < i - k:
            deq.popleft()
        dp[i] = nums[i] + (dp[deq[0]] if deq else 0)
        while deq and dp[i] >= dp[deq[-1]]:
            deq.pop()
        deq.append(i)

    return max(dp)

def main():
    print(max_sum_subsequence([10, 2, -10, 5, 20], 2)) # 37
    print(max_sum_subsequence([-1, -2, -3], 1)) # -1
    print(max_sum_subsequence([10, -2, -10, -5, 20], 2)) # 23
    print(max_sum_subsequence([5, -1, 5, -2, 5], 2)) # 15
    print(max_sum_subsequence([-5, -1, -3, -4, -2], 1)) # -1

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>

using namespace std;

class Task177 {
public:
    static int maxSumSubsequence(vector<int>& nums, int k) {
        if (nums.empty()) return 0;
        int n = nums.size();
        vector<int> dp(n);
        deque<int> deq;
        dp[0] = nums[0];
        deq.push_back(0);

        for (int i = 1; i < n; i++) {
            while (!deq.empty() && deq.front() < i - k) {
                deq.pop_front();
            }
            dp[i] = nums[i] + (deq.empty() ? 0 : dp[deq.front()]);
            while (!deq.empty() && dp[i] >= dp[deq.back()]) {
                deq.pop_back();
            }
            deq.push_back(i);
        }

        return *max_element(dp.begin(), dp.end());
    }
};

int main() {
    vector<int> nums1 = {10, 2, -10, 5, 20};
    vector<int> nums2 = {-1, -2, -3};
    vector<int> nums3 = {10, -2, -10, -5, 20};
    vector<int> nums4 = {5, -1, 5, -2, 5};
    vector<int> nums5 = {-5, -1, -3, -4, -2};

    cout << Task177::maxSumSubsequence(nums1, 2) << endl; // 37
    cout << Task177::maxSumSubsequence(nums2, 1) << endl; // -1
    cout << Task177::maxSumSubsequence(nums3, 2) << endl; // 23
    cout << Task177::maxSumSubsequence(nums4, 2) << endl; // 15
    cout << Task177::maxSumSubsequence(nums5, 1) << endl; // -1

    return 0;
}
```
```c
#include <stdio.h>
#include <limits.h>

int maxSumSubsequence(int* nums, int numsSize, int k) {
    if (numsSize == 0) return 0;
    int dp[numsSize];
    int deque[numsSize];
    int front = 0, back = 0;
    dp[0] = nums[0];
    deque[back++] = 0;

    for (int i = 1; i < numsSize; i++) {
        while (front < back && deque[front] < i - k) {
            front++;
        }
        dp[i] = nums[i] + (front < back ? dp[deque[front]] : 0);
        while (front < back && dp[i] >= dp[deque[back - 1]]) {
            back--;
        }
        deque[back++] = i;
    }

    int maxSum = INT_MIN;
    for (int i = 0; i < numsSize; i++) {
        if (dp[i] > maxSum) {
            maxSum = dp[i];
        }
    }
    return maxSum;
}

int main() {
    int nums1[] = {10, 2, -10, 5, 20};
    int nums2[] = {-1, -2, -3};
    int nums3[] = {10, -2, -10, -5, 20};
    int nums4[] = {5, -1, 5, -2, 5};
    int nums5[] = {-5, -1, -3, -4, -2};

    printf("%d\n", maxSumSubsequence(nums1, 5, 2)); // 37
    printf("%d\n", maxSumSubsequence(nums2, 3, 1)); // -1
    printf("%d\n", maxSumSubsequence(nums3, 5, 2)); // 23
    printf("%d\n", maxSumSubsequence(nums4, 5, 2)); // 15
    printf("%d\n", maxSumSubsequence(nums5, 5, 1)); // -1

    return 0;
}
```
Created file: Task177.java
Created file: Task177.py
Created file: Task177.cpp
Created file: Task177.c
Task178_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task178, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.

A subarray is a contiguous part of an array.



Example 1:

Input: nums = [1], k = 1
Output: 1
Example 2:

Input: nums = [1,2], k = 4
Output: -1
Example 3:

Input: nums = [2,-1,2], k = 3
Output: 3


Constraints:

1 <= nums.length <= 10^5
-10^5 <= nums[i] <= 10^5
1 <= k <= 10^9
```java
import java.util.Deque;
import java.util.LinkedList;

public class Task178 {
    public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        Deque<Integer> deque = new LinkedList<>();
        int minLength = n + 1;

        for (int i = 0; i <= n; i++) {
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
                minLength = Math.min(minLength, i - deque.pollFirst());
            }

            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {
                deque.pollLast();
            }

            deque.addLast(i);
        }

        return minLength <= n ? minLength : -1;
    }

    public static void main(String[] args) {
        Task178 task = new Task178();
        System.out.println(task.shortestSubarray(new int[]{1}, 1)); // Output: 1
        System.out.println(task.shortestSubarray(new int[]{1, 2}, 4)); // Output: -1
        System.out.println(task.shortestSubarray(new int[]{2, -1, 2}, 3)); // Output: 3
        System.out.println(task.shortestSubarray(new int[]{84, -37, 32, 40, 95}, 167)); // Output: 3
        System.out.println(task.shortestSubarray(new int[]{56, -21, 56, 35, -9}, 61)); // Output: 2
    }
}
```
```python
from collections import deque

class Task178:
    def shortest_subarray(self, nums, k):
        n = len(nums)
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + nums[i]

        dq = deque()
        min_length = n + 1

        for i in range(n + 1):
            while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
                min_length = min(min_length, i - dq.popleft())

            while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:
                dq.pop()

            dq.append(i)

        return min_length if min_length <= n else -1

# Test cases
task = Task178()
print(task.shortest_subarray([1], 1))  # Output: 1
print(task.shortest_subarray([1, 2], 4))  # Output: -1
print(task.shortest_subarray([2, -1, 2], 3))  # Output: 3
print(task.shortest_subarray([84, -37, 32, 40, 95], 167))  # Output: 3
print(task.shortest_subarray([56, -21, 56, 35, -9], 61))  # Output: 2
```
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <limits>

class Task178 {
public:
    int shortestSubarray(std::vector<int>& nums, int k) {
        int n = nums.size();
        std::vector<long long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        std::deque<int> dq;
        int minLength = n + 1;

        for (int i = 0; i <= n; ++i) {
            while (!dq.empty() && prefixSum[i] - prefixSum[dq.front()] >= k) {
                minLength = std::min(minLength, i - dq.front());
                dq.pop_front();
            }

            while (!dq.empty() && prefixSum[i] <= prefixSum[dq.back()]) {
                dq.pop_back();
            }

            dq.push_back(i);
        }

        return minLength <= n ? minLength : -1;
    }
};

int main() {
    Task178 task;
    std::cout << task.shortestSubarray(std::vector<int>{1}, 1) << std::endl; // Output: 1
    std::cout << task.shortestSubarray(std::vector<int>{1, 2}, 4) << std::endl; // Output: -1
    std::cout << task.shortestSubarray(std::vector<int>{2, -1, 2}, 3) << std::endl; // Output: 3
    std::cout << task.shortestSubarray(std::vector<int>{84, -37, 32, 40, 95}, 167) << std::endl; // Output: 3
    std::cout << task.shortestSubarray(std::vector<int>{56, -21, 56, 35, -9}, 61) << std::endl; // Output: 2
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int shortestSubarray(int* nums, int numsSize, int k) {
    long long* prefixSum = (long long*)malloc((numsSize + 1) * sizeof(long long));
    prefixSum[0] = 0;
    for (int i = 0; i < numsSize; ++i) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    int* deque = (int*)malloc((numsSize + 1) * sizeof(int));
    int front = 0, back = 0;
    int minLength = numsSize + 1;

    for (int i = 0; i <= numsSize; ++i) {
        while (front < back && prefixSum[i] - prefixSum[deque[front]] >= k) {
            minLength = (minLength < i - deque[front]) ? minLength : i - deque[front];
            front++;
        }

        while (front < back && prefixSum[i] <= prefixSum[deque[back - 1]]) {
            back--;
        }

        deque[back++] = i;
    }

    free(prefixSum);
    free(deque);

    return minLength <= numsSize ? minLength : -1;
}

int main() {
    int nums1[] = {1};
    int nums2[] = {1, 2};
    int nums3[] = {2, -1, 2};
    int nums4[] = {84, -37, 32, 40, 95};
    int nums5[] = {56, -21, 56, 35, -9};

    printf("%d\n", shortestSubarray(nums1, 1, 1)); // Output: 1
    printf("%d\n", shortestSubarray(nums2, 2, 4)); // Output: -1
    printf("%d\n", shortestSubarray(nums3, 3, 3)); // Output: 3
    printf("%d\n", shortestSubarray(nums4, 5, 167)); // Output: 3
    printf("%d\n", shortestSubarray(nums5, 5, 61)); // Output: 2

    return 0;
}
```
Created file: Task178.java
Created file: Task178.py
Created file: Task178.cpp
Created file: Task178.c
Task179_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task179, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.



Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Example 2:

Input: nums = [1], k = 1
Output: [1]


Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length
```java
import java.util.*;

public class Task179 {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) {
            return new int[0];
        }
        int n = nums.length;
        int[] result = new int[n - k + 1];
        int ri = 0;
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.offer(i);
            if (i >= k - 1) {
                result[ri++] = nums[deque.peek()];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] result1 = maxSlidingWindow(new int[]{1,3,-1,-3,5,3,6,7}, 3);
        System.out.println(Arrays.toString(result1)); // [3, 3, 5, 5, 6, 7]

        int[] result2 = maxSlidingWindow(new int[]{1}, 1);
        System.out.println(Arrays.toString(result2)); // [1]

        int[] result3 = maxSlidingWindow(new int[]{9,11}, 2);
        System.out.println(Arrays.toString(result3)); // [11]

        int[] result4 = maxSlidingWindow(new int[]{4, -2}, 2);
        System.out.println(Arrays.toString(result4)); // [4]

        int[] result5 = maxSlidingWindow(new int[]{1,3,1,2,0,5}, 3);
        System.out.println(Arrays.toString(result5)); // [3, 3, 2, 5]
    }
}
```
```python
from collections import deque

def max_sliding_window(nums, k):
    if not nums or k == 0:
        return []

    result = []
    dq = deque()

    for i in range(len(nums)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

if __name__ == "__main__":
    print(max_sliding_window([1,3,-1,-3,5,3,6,7], 3))  # [3, 3, 5, 5, 6, 7]
    print(max_sliding_window([1], 1))                  # [1]
    print(max_sliding_window([9,11], 2))               # [11]
    print(max_sliding_window([4, -2], 2))              # [4]
    print(max_sliding_window([1,3,1,2,0,5], 3))        # [3, 3, 2, 5]
```
```cpp
#include <iostream>
#include <vector>
#include <deque>

using namespace std;

class Task179 {
public:
    static vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> dq;

        for (int i = 0; i < nums.size(); ++i) {
            if (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }

        return result;
    }
};

int main() {
    vector<int> nums1 = {1,3,-1,-3,5,3,6,7};
    vector<int> result1 = Task179::maxSlidingWindow(nums1, 3);
    for (int n : result1) cout << n << " "; // 3 3 5 5 6 7
    cout << endl;

    vector<int> nums2 = {1};
    vector<int> result2 = Task179::maxSlidingWindow(nums2, 1);
    for (int n : result2) cout << n << " "; // 1
    cout << endl;

    vector<int> nums3 = {9, 11};
    vector<int> result3 = Task179::maxSlidingWindow(nums3, 2);
    for (int n : result3) cout << n << " "; // 11
    cout << endl;

    vector<int> nums4 = {4, -2};
    vector<int> result4 = Task179::maxSlidingWindow(nums4, 2);
    for (int n : result4) cout << n << " "; // 4
    cout << endl;

    vector<int> nums5 = {1,3,1,2,0,5};
    vector<int> result5 = Task179::maxSlidingWindow(nums5, 3);
    for (int n : result5) cout << n << " "; // 3 3 2 5
    cout << endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if (!nums || k <= 0) {
        *returnSize = 0;
        return NULL;
    }

    int* result = (int*)malloc((numsSize - k + 1) * sizeof(int));
    int* deque = (int*)malloc(numsSize * sizeof(int));
    int front = 0, back = 0;

    for (int i = 0; i < numsSize; ++i) {
        if (front < back && deque[front] < i - k + 1) {
            ++front;
        }
        while (front < back && nums[deque[back - 1]] < nums[i]) {
            --back;
        }
        deque[back++] = i;
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque[front]];
        }
    }

    *returnSize = numsSize - k + 1;
    free(deque);
    return result;
}

int main() {
    int nums1[] = {1,3,-1,-3,5,3,6,7};
    int size1;
    int* result1 = maxSlidingWindow(nums1, 8, 3, &size1);
    for (int i = 0; i < size1; ++i) printf("%d ", result1[i]); // 3 3 5 5 6 7
    printf("\n");
    free(result1);

    int nums2[] = {1};
    int size2;
    int* result2 = maxSlidingWindow(nums2, 1, 1, &size2);
    for (int i = 0; i < size2; ++i) printf("%d ", result2[i]); // 1
    printf("\n");
    free(result2);

    int nums3[] = {9, 11};
    int size3;
    int* result3 = maxSlidingWindow(nums3, 2, 2, &size3);
    for (int i = 0; i < size3; ++i) printf("%d ", result3[i]); // 11
    printf("\n");
    free(result3);

    int nums4[] = {4, -2};
    int size4;
    int* result4 = maxSlidingWindow(nums4, 2, 2, &size4);
    for (int i = 0; i < size4; ++i) printf("%d ", result4[i]); // 4
    printf("\n");
    free(result4);

    int nums5[] = {1,3,1,2,0,5};
    int size5;
    int* result5 = maxSlidingWindow(nums5, 6, 3, &size5);
    for (int i = 0; i < size5; ++i) printf("%d ", result5[i]); // 3 3 2 5
    printf("\n");
    free(result5);

    return 0;
}
```
Created file: Task179.java
Created file: Task179.py
Created file: Task179.cpp
Created file: Task179.c
Task180_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task180, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Instructions
Reparent a tree on a selected node.

A tree is a special type of graph where all nodes are connected but there are no cycles. That means, there is exactly one path to get from one node to another for any pair of nodes.

This exercise is all about re-orientating a tree to see things from a different point of view. For example family trees are usually presented from the ancestor's perspective:

    +------0------+
    |      |      |
  +-1-+  +-2-+  +-3-+
  |   |  |   |  |   |
  4   5  6   7  8   9
But there is no inherent direction in a tree. The same information can be presented from the perspective of any other node in the tree, by pulling it up to the root and dragging its relationships along with it. So the same tree from 6's perspective would look like:

        6
        |
  +-----2-----+
  |           |
  7     +-----0-----+
        |           |
      +-1-+       +-3-+
      |   |       |   |
      4   5       8   9
This lets us more simply describe the paths between two nodes. So for example the path from 6-9 (which in the first tree goes up to the root and then down to a different leaf node) can be seen to follow the path 6-2-0-3-9.

This exercise involves taking an input tree and re-orientating it from the point of view of one of the nodes.


```java
import java.util.*;

public class Task180 {
    static class TreeNode {
        int val;
        List<TreeNode> children = new ArrayList<>();

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static TreeNode reparentTree(TreeNode root, int newRootVal) {
        Map<Integer, TreeNode> nodeMap = new HashMap<>();
        Map<TreeNode, TreeNode> parentMap = new HashMap<>();
        buildParentMap(root, null, nodeMap, parentMap);

        TreeNode newRoot = nodeMap.get(newRootVal);
        reorientTree(newRoot, parentMap);

        return newRoot;
    }

    private static void buildParentMap(TreeNode node, TreeNode parent, Map<Integer, TreeNode> nodeMap, Map<TreeNode, TreeNode> parentMap) {
        if (node == null) return;
        nodeMap.put(node.val, node);
        parentMap.put(node, parent);
        for (TreeNode child : node.children) {
            buildParentMap(child, node, nodeMap, parentMap);
        }
    }

    private static void reorientTree(TreeNode node, Map<TreeNode, TreeNode> parentMap) {
        TreeNode parent = parentMap.get(node);
        if (parent != null) {
            node.children.add(parent);
            parent.children.remove(node);
            reorientTree(parent, parentMap);
        }
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(0);
        TreeNode node1 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node5 = new TreeNode(5);
        TreeNode node6 = new TreeNode(6);
        TreeNode node7 = new TreeNode(7);
        TreeNode node8 = new TreeNode(8);
        TreeNode node9 = new TreeNode(9);

        root.children.add(node1);
        root.children.add(node2);
        root.children.add(node3);
        node1.children.add(node4);
        node1.children.add(node5);
        node2.children.add(node6);
        node2.children.add(node7);
        node3.children.add(node8);
        node3.children.add(node9);

        TreeNode newRoot = reparentTree(root, 6);
        System.out.println(newRoot.val); // Test output
    }
}
```

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.children = []

def reparent_tree(root, new_root_val):
    node_map = {}
    parent_map = {}

    def build_parent_map(node, parent):
        if node is None:
            return
        node_map[node.val] = node
        parent_map[node] = parent
        for child in node.children:
            build_parent_map(child, node)

    def reorient_tree(node):
        parent = parent_map[node]
        if parent:
            node.children.append(parent)
            parent.children.remove(node)
            reorient_tree(parent)

    build_parent_map(root, None)
    new_root = node_map.get(new_root_val)
    reorient_tree(new_root)

    return new_root

if __name__ == "__main__":
    root = TreeNode(0)
    node1 = TreeNode(1)
    node2 = TreeNode(2)
    node3 = TreeNode(3)
    node4 = TreeNode(4)
    node5 = TreeNode(5)
    node6 = TreeNode(6)
    node7 = TreeNode(7)
    node8 = TreeNode(8)
    node9 = TreeNode(9)

    root.children.extend([node1, node2, node3])
    node1.children.extend([node4, node5])
    node2.children.extend([node6, node7])
    node3.children.extend([node8, node9])

    new_root = reparent_tree(root, 6)
    print(new_root.val)  # Test output
```

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class TreeNode {
public:
    int val;
    vector<TreeNode*> children;
    TreeNode(int v) : val(v) {}
};

void buildParentMap(TreeNode* node, TreeNode* parent, unordered_map<int, TreeNode*>& nodeMap, unordered_map<TreeNode*, TreeNode*>& parentMap) {
    if (!node) return;
    nodeMap[node->val] = node;
    parentMap[node] = parent;
    for (TreeNode* child : node->children) {
        buildParentMap(child, node, nodeMap, parentMap);
    }
}

void reorientTree(TreeNode* node, unordered_map<TreeNode*, TreeNode*>& parentMap) {
    TreeNode* parent = parentMap[node];
    if (parent) {
        node->children.push_back(parent);
        auto it = find(parent->children.begin(), parent->children.end(), node);
        if (it != parent->children.end()) parent->children.erase(it);
        reorientTree(parent, parentMap);
    }
}

TreeNode* reparentTree(TreeNode* root, int newRootVal) {
    unordered_map<int, TreeNode*> nodeMap;
    unordered_map<TreeNode*, TreeNode*> parentMap;
    buildParentMap(root, nullptr, nodeMap, parentMap);

    TreeNode* newRoot = nodeMap[newRootVal];
    reorientTree(newRoot, parentMap);

    return newRoot;
}

int main() {
    TreeNode* root = new TreeNode(0);
    TreeNode* node1 = new TreeNode(1);
    TreeNode* node2 = new TreeNode(2);
    TreeNode* node3 = new TreeNode(3);
    TreeNode* node4 = new TreeNode(4);
    TreeNode* node5 = new TreeNode(5);
    TreeNode* node6 = new TreeNode(6);
    TreeNode* node7 = new TreeNode(7);
    TreeNode* node8 = new TreeNode(8);
    TreeNode* node9 = new TreeNode(9);

    root->children = {node1, node2, node3};
    node1->children = {node4, node5};
    node2->children = {node6, node7};
    node3->children = {node8, node9};

    TreeNode* newRoot = reparentTree(root, 6);
    cout << newRoot->val << endl; // Test output

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int val;
    struct TreeNode** children;
    int childCount;
} TreeNode;

void buildParentMap(TreeNode* node, TreeNode* parent, TreeNode** nodeMap, TreeNode** parentMap) {
    if (!node) return;
    nodeMap[node->val] = node;
    parentMap[node->val] = parent;
    for (int i = 0; i < node->childCount; i++) {
        buildParentMap(node->children[i], node, nodeMap, parentMap);
    }
}

void reorientTree(TreeNode* node, TreeNode** parentMap) {
    TreeNode* parent = parentMap[node->val];
    if (parent) {
        node->children[node->childCount++] = parent;
        for (int i = 0; i < parent->childCount; i++) {
            if (parent->children[i] == node) {
                parent->children[i] = parent->children[parent->childCount - 1];
                parent->childCount--;
                break;
            }
        }
        reorientTree(parent, parentMap);
    }
}

TreeNode* reparentTree(TreeNode* root, int newRootVal) {
    TreeNode* nodeMap[10] = {NULL}; // Assuming max nodes are 10
    TreeNode* parentMap[10] = {NULL};

    buildParentMap(root, NULL, nodeMap, parentMap);

    TreeNode* newRoot = nodeMap[newRootVal];
    reorientTree(newRoot, parentMap);

    return newRoot;
}

TreeNode* createNode(int val, int capacity) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->children = (TreeNode**)malloc(sizeof(TreeNode*) * capacity);
    node->childCount = 0;
    return node;
}

int main() {
    TreeNode* root = createNode(0, 3);
    TreeNode* node1 = createNode(1, 2);
    TreeNode* node2 = createNode(2, 2);
    TreeNode* node3 = createNode(3, 2);
    TreeNode* node4 = createNode(4, 0);
    TreeNode* node5 = createNode(5, 0);
    TreeNode* node6 = createNode(6, 0);
    TreeNode* node7 = createNode(7, 0);
    TreeNode* node8 = createNode(8, 0);
    TreeNode* node9 = createNode(9, 0);

    root->children[0] = node1;
    root->children[1] = node2;
    root->children[2] = node3;
    root->childCount = 3;

    node1->children[0] = node4;
    node1->children[1] = node5;
    node1->childCount = 2;

    node2->children[0] = node6;
    node2->children[1] = node7;
    node2->childCount = 2;

    node3->children[0] = node8;
    node3->children[1] = node9;
    node3->childCount = 2;

    TreeNode* newRoot = reparentTree(root, 6);
    printf("%d\n", newRoot->val); // Test output

    return 0;
}
```
Created file: Task180.java
Created file: Task180.py
Created file: Task180.cpp
Created file: Task180.c
Task181_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task181, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You have recently acquired a banking license and need to implement a thread-safe system for managing bank accounts. The system should support operations like opening, closing, withdrawing, and depositing money. Due to the nature of banking operations, accounts must be accessible safely from multiple threads or processes to handle concurrent transactions. It should be ensured that there are no race conditions between reading the account balance and updating it. Additionally, operations against closed accounts must fail gracefully.
```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Task181 {

    private final Map<Integer, BankAccount> accounts = new HashMap<>();
    private final Lock lock = new ReentrantLock();

    private static class BankAccount {
        private double balance;
        private boolean isOpen;

        public BankAccount() {
            this.balance = 0.0;
            this.isOpen = true;
        }

        public synchronized boolean deposit(double amount) {
            if (!isOpen || amount < 0) return false;
            balance += amount;
            return true;
        }

        public synchronized boolean withdraw(double amount) {
            if (!isOpen || amount < 0 || balance < amount) return false;
            balance -= amount;
            return true;
        }

        public synchronized double getBalance() {
            return isOpen ? balance : -1;
        }

        public synchronized boolean closeAccount() {
            if (!isOpen) return false;
            isOpen = false;
            return true;
        }
    }

    public int openAccount() {
        lock.lock();
        try {
            int accountId = accounts.size() + 1;
            accounts.put(accountId, new BankAccount());
            return accountId;
        } finally {
            lock.unlock();
        }
    }

    public boolean deposit(int accountId, double amount) {
        lock.lock();
        try {
            BankAccount account = accounts.get(accountId);
            return account != null && account.deposit(amount);
        } finally {
            lock.unlock();
        }
    }

    public boolean withdraw(int accountId, double amount) {
        lock.lock();
        try {
            BankAccount account = accounts.get(accountId);
            return account != null && account.withdraw(amount);
        } finally {
            lock.unlock();
        }
    }

    public double getBalance(int accountId) {
        lock.lock();
        try {
            BankAccount account = accounts.get(accountId);
            return account != null ? account.getBalance() : -1;
        } finally {
            lock.unlock();
        }
    }

    public boolean closeAccount(int accountId) {
        lock.lock();
        try {
            BankAccount account = accounts.get(accountId);
            return account != null && account.closeAccount();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Task181 bank = new Task181();
        int acc1 = bank.openAccount();
        int acc2 = bank.openAccount();
        System.out.println(bank.deposit(acc1, 100)); // true
        System.out.println(bank.withdraw(acc1, 50)); // true
        System.out.println(bank.getBalance(acc1));   // 50.0
        System.out.println(bank.closeAccount(acc1)); // true
        System.out.println(bank.deposit(acc1, 50));  // false
    }
}
```
```python
import threading

class BankAccount:
    def __init__(self):
        self.balance = 0.0
        self.is_open = True
        self.lock = threading.Lock()

    def deposit(self, amount):
        with self.lock:
            if not self.is_open or amount < 0:
                return False
            self.balance += amount
            return True

    def withdraw(self, amount):
        with self.lock:
            if not self.is_open or amount < 0 or self.balance < amount:
                return False
            self.balance -= amount
            return True

    def get_balance(self):
        with self.lock:
            return self.balance if self.is_open else -1

    def close_account(self):
        with self.lock:
            if not self.is_open:
                return False
            self.is_open = False
            return True

class Task181:
    def __init__(self):
        self.accounts = {}
        self.lock = threading.Lock()
        self.account_id_counter = 0

    def open_account(self):
        with self.lock:
            self.account_id_counter += 1
            account_id = self.account_id_counter
            self.accounts[account_id] = BankAccount()
            return account_id

    def deposit(self, account_id, amount):
        with self.lock:
            account = self.accounts.get(account_id)
            return account.deposit(amount) if account else False

    def withdraw(self, account_id, amount):
        with self.lock:
            account = self.accounts.get(account_id)
            return account.withdraw(amount) if account else False

    def get_balance(self, account_id):
        with self.lock:
            account = self.accounts.get(account_id)
            return account.get_balance() if account else -1

    def close_account(self, account_id):
        with self.lock:
            account = self.accounts.get(account_id)
            return account.close_account() if account else False

def main():
    bank = Task181()
    acc1 = bank.open_account()
    acc2 = bank.open_account()
    print(bank.deposit(acc1, 100))  # True
    print(bank.withdraw(acc1, 50))  # True
    print(bank.get_balance(acc1))   # 50.0
    print(bank.close_account(acc1)) # True
    print(bank.deposit(acc1, 50))   # False

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <map>
#include <mutex>

class BankAccount {
public:
    BankAccount() : balance(0.0), isOpen(true) {}

    bool deposit(double amount) {
        std::lock_guard<std::mutex> guard(accountMutex);
        if (!isOpen || amount < 0) return false;
        balance += amount;
        return true;
    }

    bool withdraw(double amount) {
        std::lock_guard<std::mutex> guard(accountMutex);
        if (!isOpen || amount < 0 || balance < amount) return false;
        balance -= amount;
        return true;
    }

    double getBalance() {
        std::lock_guard<std::mutex> guard(accountMutex);
        return isOpen ? balance : -1;
    }

    bool closeAccount() {
        std::lock_guard<std::mutex> guard(accountMutex);
        if (!isOpen) return false;
        isOpen = false;
        return true;
    }

private:
    double balance;
    bool isOpen;
    std::mutex accountMutex;
};

class Task181 {
public:
    Task181() : accountIdCounter(0) {}

    int openAccount() {
        std::lock_guard<std::mutex> guard(taskMutex);
        int accountId = ++accountIdCounter;
        accounts[accountId] = BankAccount();
        return accountId;
    }

    bool deposit(int accountId, double amount) {
        std::lock_guard<std::mutex> guard(taskMutex);
        auto it = accounts.find(accountId);
        if (it != accounts.end()) {
            return it->second.deposit(amount);
        }
        return false;
    }

    bool withdraw(int accountId, double amount) {
        std::lock_guard<std::mutex> guard(taskMutex);
        auto it = accounts.find(accountId);
        if (it != accounts.end()) {
            return it->second.withdraw(amount);
        }
        return false;
    }

    double getBalance(int accountId) {
        std::lock_guard<std::mutex> guard(taskMutex);
        auto it = accounts.find(accountId);
        if (it != accounts.end()) {
            return it->second.getBalance();
        }
        return -1;
    }

    bool closeAccount(int accountId) {
        std::lock_guard<std::mutex> guard(taskMutex);
        auto it = accounts.find(accountId);
        if (it != accounts.end()) {
            return it->second.closeAccount();
        }
        return false;
    }

private:
    std::map<int, BankAccount> accounts;
    std::mutex taskMutex;
    int accountIdCounter;
};

int main() {
    Task181 bank;
    int acc1 = bank.openAccount();
    int acc2 = bank.openAccount();
    std::cout << bank.deposit(acc1, 100) << std::endl; // true
    std::cout << bank.withdraw(acc1, 50) << std::endl; // true
    std::cout << bank.getBalance(acc1) << std::endl;   // 50.0
    std::cout << bank.closeAccount(acc1) << std::endl; // true
    std::cout << bank.deposit(acc1, 50) << std::endl;  // false
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct {
    double balance;
    int isOpen;
    pthread_mutex_t lock;
} BankAccount;

BankAccount* create_account() {
    BankAccount* account = (BankAccount*)malloc(sizeof(BankAccount));
    account->balance = 0.0;
    account->isOpen = 1;
    pthread_mutex_init(&account->lock, NULL);
    return account;
}

int deposit(BankAccount* account, double amount) {
    pthread_mutex_lock(&account->lock);
    if (!account->isOpen || amount < 0) {
        pthread_mutex_unlock(&account->lock);
        return 0;
    }
    account->balance += amount;
    pthread_mutex_unlock(&account->lock);
    return 1;
}

int withdraw(BankAccount* account, double amount) {
    pthread_mutex_lock(&account->lock);
    if (!account->isOpen || amount < 0 || account->balance < amount) {
        pthread_mutex_unlock(&account->lock);
        return 0;
    }
    account->balance -= amount;
    pthread_mutex_unlock(&account->lock);
    return 1;
}

double get_balance(BankAccount* account) {
    pthread_mutex_lock(&account->lock);
    double balance = account->isOpen ? account->balance : -1;
    pthread_mutex_unlock(&account->lock);
    return balance;
}

int close_account(BankAccount* account) {
    pthread_mutex_lock(&account->lock);
    if (!account->isOpen) {
        pthread_mutex_unlock(&account->lock);
        return 0;
    }
    account->isOpen = 0;
    pthread_mutex_unlock(&account->lock);
    return 1;
}

void delete_account(BankAccount* account) {
    pthread_mutex_destroy(&account->lock);
    free(account);
}

int main() {
    BankAccount* acc1 = create_account();
    BankAccount* acc2 = create_account();
    printf("%d\n", deposit(acc1, 100)); // true
    printf("%d\n", withdraw(acc1, 50)); // true
    printf("%f\n", get_balance(acc1));   // 50.0
    printf("%d\n", close_account(acc1)); // true
    printf("%d\n", deposit(acc1, 50));   // false
    delete_account(acc1);
    delete_account(acc2);
    return 0;
}
```
Created file: Task181.java
Created file: Task181.py
Created file: Task181.cpp
Created file: Task181.c
Task182_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task182, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Instructions
Clean up user-entered phone numbers so that they can be sent SMS messages.

The North American Numbering Plan (NANP) is a telephone numbering system used by many countries in North America like the United States, Canada or Bermuda. All NANP-countries share the same international country code: 1.

NANP numbers are ten-digit numbers consisting of a three-digit Numbering Plan Area code, commonly known as area code, followed by a seven-digit local number. The first three digits of the local number represent the exchange code, followed by the unique four-digit number which is the subscriber number.

The format is usually represented as

NXX NXX-XXXX
where N is any digit from 2 through 9 and X is any digit from 0 through 9.

Sometimes they also have the country code (represented as 1 or +1) prefixed.

Your task is to clean up differently formatted telephone numbers by removing punctuation and the country code if present.

For example, the inputs

+1 (613)-995-0253
613-995-0253
1 613 995 0253
613.995.0253
should all produce the output

6139950253

Note: As this exercise only deals with telephone numbers used in NANP-countries, only 1 is considered a valid country code.
```java
import java.util.regex.*;

public class Task182 {
    public static String cleanPhoneNumber(String phoneNumber) {
        if (phoneNumber == null) {
            return null;
        }
        // Remove all non-digit characters
        String cleaned = phoneNumber.replaceAll("\\D", "");
        // Remove leading 1 if present
        if (cleaned.startsWith("1") && cleaned.length() == 11) {
            cleaned = cleaned.substring(1);
        }
        // Validate if the cleaned number is a valid NANP number
        if (cleaned.matches("[2-9]\\d{2}[2-9]\\d{6}")) {
            return cleaned;
        }
        return null; // Return null for invalid numbers
    }

    public static void main(String[] args) {
        System.out.println(cleanPhoneNumber("+1 (613)-995-0253")); // 6139950253
        System.out.println(cleanPhoneNumber("613-995-0253"));      // 6139950253
        System.out.println(cleanPhoneNumber("1 613 995 0253"));    // 6139950253
        System.out.println(cleanPhoneNumber("613.995.0253"));      // 6139950253
        System.out.println(cleanPhoneNumber("123-456-7890"));      // null (invalid)
    }
}
```
```python
import re

def clean_phone_number(phone_number):
    if phone_number is None:
        return None
    # Remove all non-digit characters
    cleaned = re.sub(r'\D', '', phone_number)
    # Remove leading 1 if present
    if cleaned.startswith('1') and len(cleaned) == 11:
        cleaned = cleaned[1:]
    # Validate if the cleaned number is a valid NANP number
    if re.match(r'^[2-9]\d{2}[2-9]\d{6}$', cleaned):
        return cleaned
    return None  # Return None for invalid numbers

if __name__ == "__main__":
    print(clean_phone_number("+1 (613)-995-0253"))  # 6139950253
    print(clean_phone_number("613-995-0253"))       # 6139950253
    print(clean_phone_number("1 613 995 0253"))     # 6139950253
    print(clean_phone_number("613.995.0253"))       # 6139950253
    print(clean_phone_number("123-456-7890"))       # None (invalid)
```
```cpp
#include <iostream>
#include <regex>
#include <string>

class Task182 {
public:
    static std::string cleanPhoneNumber(const std::string& phoneNumber) {
        if (phoneNumber.empty()) {
            return "";
        }
        // Remove all non-digit characters
        std::string cleaned = std::regex_replace(phoneNumber, std::regex("\\D"), "");
        // Remove leading 1 if present
        if (cleaned.length() == 11 && cleaned[0] == '1') {
            cleaned.erase(0, 1);
        }
        // Validate if the cleaned number is a valid NANP number
        if (std::regex_match(cleaned, std::regex("^[2-9]\\d{2}[2-9]\\d{6}$"))) {
            return cleaned;
        }
        return ""; // Return empty string for invalid numbers
    }
};

int main() {
    std::cout << Task182::cleanPhoneNumber("+1 (613)-995-0253") << std::endl; // 6139950253
    std::cout << Task182::cleanPhoneNumber("613-995-0253") << std::endl;      // 6139950253
    std::cout << Task182::cleanPhoneNumber("1 613 995 0253") << std::endl;    // 6139950253
    std::cout << Task182::cleanPhoneNumber("613.995.0253") << std::endl;      // 6139950253
    std::cout << Task182::cleanPhoneNumber("123-456-7890") << std::endl;      // empty (invalid)
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

char* cleanPhoneNumber(const char* phoneNumber, char* result) {
    if (phoneNumber == NULL) {
        return NULL;
    }
    int j = 0;
    // Remove all non-digit characters
    for (int i = 0; phoneNumber[i] != '\0'; i++) {
        if (isdigit(phoneNumber[i])) {
            result[j++] = phoneNumber[i];
        }
    }
    result[j] = '\0';
    // Remove leading 1 if present
    if (result[0] == '1' && strlen(result) == 11) {
        memmove(result, result + 1, strlen(result));
    }
    // Validate if the cleaned number is a valid NANP number
    if (strlen(result) == 10 && result[0] >= '2' && result[3] >= '2') {
        return result;
    }
    return NULL; // Return NULL for invalid numbers
}

int main() {
    char result[12]; // To store the cleaned number
    printf("%s\n", cleanPhoneNumber("+1 (613)-995-0253", result)); // 6139950253
    printf("%s\n", cleanPhoneNumber("613-995-0253", result));      // 6139950253
    printf("%s\n", cleanPhoneNumber("1 613 995 0253", result));    // 6139950253
    printf("%s\n", cleanPhoneNumber("613.995.0253", result));      // 6139950253
    printf("%s\n", cleanPhoneNumber("123-456-7890", result));      // (null)
    return 0;
}
```
Created file: Task182.java
Created file: Task182.py
Created file: Task182.cpp
Created file: Task182.c
Task183_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task183, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are analyzing a sequence of digits intercepted from encrypted communication signals. Your task is to find the largest product of a series of adjacent digits of a specified span within the sequence.

Given:

input: A sequence of digits to analyze.
series: A sequence of adjacent digits of length equal to a specified span.
span: The number of digits in each series.
product: The result of multiplying the digits in a series.
Implement a function that computes the largest product among all possible series of a given span in the input sequence.

Example:

For the input "63915" and a span of 3:

Possible series: "639", "391", "915"
Products: 162 (6  3  9), 27 (3  9  1), 45 (9  1  5)
The largest product is 162.
```java
public class Task183 {

    public static int largestProduct(String input, int span) {
        if (input == null || input.length() < span || span <= 0) {
            throw new IllegalArgumentException("Invalid input or span");
        }

        int maxProduct = 0;
        for (int i = 0; i <= input.length() - span; i++) {
            int product = 1;
            for (int j = 0; j < span; j++) {
                product *= Character.getNumericValue(input.charAt(i + j));
            }
            if (product > maxProduct) {
                maxProduct = product;
            }
        }

        return maxProduct;
    }

    public static void main(String[] args) {
        System.out.println(largestProduct("63915", 3)); // Output: 162
        System.out.println(largestProduct("123456789", 2)); // Output: 72
        System.out.println(largestProduct("111111111", 3)); // Output: 1
        System.out.println(largestProduct("987654321", 4)); // Output: 3024
        System.out.println(largestProduct("00000000", 5)); // Output: 0
    }
}
```
```python
def largest_product(input_sequence, span):
    if input_sequence is None or len(input_sequence) < span or span <= 0:
        raise ValueError("Invalid input or span")

    max_product = 0
    for i in range(len(input_sequence) - span + 1):
        product = 1
        for j in range(span):
            product *= int(input_sequence[i + j])
        if product > max_product:
            max_product = product

    return max_product

if __name__ == "__main__":
    print(largest_product("63915", 3)) # Output: 162
    print(largest_product("123456789", 2)) # Output: 72
    print(largest_product("111111111", 3)) # Output: 1
    print(largest_product("987654321", 4)) # Output: 3024
    print(largest_product("00000000", 5)) # Output: 0
```
```cpp
#include <iostream>
#include <string>
#include <stdexcept>

class Task183 {
public:
    static int largestProduct(const std::string &input, int span) {
        if (input.empty() || input.size() < span || span <= 0) {
            throw std::invalid_argument("Invalid input or span");
        }

        int maxProduct = 0;
        for (size_t i = 0; i <= input.size() - span; ++i) {
            int product = 1;
            for (int j = 0; j < span; ++j) {
                product *= input[i + j] - '0';
            }
            if (product > maxProduct) {
                maxProduct = product;
            }
        }

        return maxProduct;
    }
};

int main() {
    std::cout << Task183::largestProduct("63915", 3) << std::endl; // Output: 162
    std::cout << Task183::largestProduct("123456789", 2) << std::endl; // Output: 72
    std::cout << Task183::largestProduct("111111111", 3) << std::endl; // Output: 1
    std::cout << Task183::largestProduct("987654321", 4) << std::endl; // Output: 3024
    std::cout << Task183::largestProduct("00000000", 5) << std::endl; // Output: 0
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int largestProduct(const char *input, int span) {
    if (input == NULL || strlen(input) < span || span <= 0) {
        fprintf(stderr, "Invalid input or span\n");
        exit(EXIT_FAILURE);
    }

    int maxProduct = 0;
    int length = strlen(input);
    for (int i = 0; i <= length - span; i++) {
        int product = 1;
        for (int j = 0; j < span; j++) {
            product *= input[i + j] - '0';
        }
        if (product > maxProduct) {
            maxProduct = product;
        }
    }

    return maxProduct;
}

int main() {
    printf("%d\n", largestProduct("63915", 3)); // Output: 162
    printf("%d\n", largestProduct("123456789", 2)); // Output: 72
    printf("%d\n", largestProduct("111111111", 3)); // Output: 1
    printf("%d\n", largestProduct("987654321", 4)); // Output: 3024
    printf("%d\n", largestProduct("00000000", 5)); // Output: 0

    return 0;
}
```
Created file: Task183.java
Created file: Task183.py
Created file: Task183.cpp
Created file: Task183.c
Task184_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task184, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
When a robot comes off the factory floor, it has no name.

The first time you turn on a robot, a random name is generated in the format of two uppercase letters followed by three digits, such as RX837 or BC811.

Every once in a while we need to reset a robot to its factory settings, which means that its name gets wiped. The next time you ask, that robot will respond with a new random name.

The names must be random: they should not follow a predictable sequence. Using random names means a risk of collisions. Your solution must ensure that every existing robot has a unique name.
```java
import java.util.HashSet;
import java.util.Random;

public class Task184 {

    public static class Robot {
        private static final HashSet<String> usedNames = new HashSet<>();
        private String name;
        private static final Random random = new Random();

        public Robot() {
            reset();
        }

        public String getName() {
            return name;
        }

        public void reset() {
            do {
                name = generateName();
            } while (usedNames.contains(name));
            usedNames.add(name);
        }

        private String generateName() {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 2; i++) {
                sb.append((char) ('A' + random.nextInt(26)));
            }
            for (int i = 0; i < 3; i++) {
                sb.append(random.nextInt(10));
            }
            return sb.toString();
        }
    }

    public static void main(String[] args) {
        Robot robot1 = new Robot();
        Robot robot2 = new Robot();
        Robot robot3 = new Robot();
        Robot robot4 = new Robot();
        Robot robot5 = new Robot();

        System.out.println(robot1.getName());
        System.out.println(robot2.getName());
        System.out.println(robot3.getName());
        System.out.println(robot4.getName());
        System.out.println(robot5.getName());

        robot1.reset();
        System.out.println(robot1.getName());
    }
}
```
```python
import random
import string

class Robot:
    used_names = set()

    def __init__(self):
        self.reset()

    def reset(self):
        while True:
            name = self.generate_name()
            if name not in self.used_names:
                self.name = name
                self.used_names.add(name)
                break

    def generate_name(self):
        letters = ''.join(random.choices(string.ascii_uppercase, k=2))
        digits = ''.join(random.choices(string.digits, k=3))
        return letters + digits

    def get_name(self):
        return self.name

def main():
    robot1 = Robot()
    robot2 = Robot()
    robot3 = Robot()
    robot4 = Robot()
    robot5 = Robot()

    print(robot1.get_name())
    print(robot2.get_name())
    print(robot3.get_name())
    print(robot4.get_name())
    print(robot5.get_name())

    robot1.reset()
    print(robot1.get_name())

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <cstdlib>
#include <ctime>

class Robot {
public:
    Robot() {
        reset();
    }

    std::string getName() const {
        return name;
    }

    void reset() {
        do {
            name = generateName();
        } while (usedNames.find(name) != usedNames.end());
        usedNames.insert(name);
    }

private:
    std::string name;
    static std::unordered_set<std::string> usedNames;

    std::string generateName() {
        std::string letters;
        for (int i = 0; i < 2; ++i) {
            letters += static_cast<char>('A' + rand() % 26);
        }
        std::string digits;
        for (int i = 0; i < 3; ++i) {
            digits += std::to_string(rand() % 10);
        }
        return letters + digits;
    }
};

std::unordered_set<std::string> Robot::usedNames;

int main() {
    srand(time(0));

    Robot robot1;
    Robot robot2;
    Robot robot3;
    Robot robot4;
    Robot robot5;

    std::cout << robot1.getName() << std::endl;
    std::cout << robot2.getName() << std::endl;
    std::cout << robot3.getName() << std::endl;
    std::cout << robot4.getName() << std::endl;
    std::cout << robot5.getName() << std::endl;

    robot1.reset();
    std::cout << robot1.getName() << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define NAME_LENGTH 5
#define MAX_ROBOTS 10000

typedef struct Robot {
    char name[NAME_LENGTH + 1];
} Robot;

char usedNames[MAX_ROBOTS][NAME_LENGTH + 1];
int usedCount = 0;

void generateName(char *name) {
    for (int i = 0; i < 2; i++) {
        name[i] = 'A' + rand() % 26;
    }
    for (int i = 2; i < 5; i++) {
        name[i] = '0' + rand() % 10;
    }
    name[5] = '\0';
}

int isUniqueName(const char *name) {
    for (int i = 0; i < usedCount; i++) {
        if (strcmp(usedNames[i], name) == 0) {
            return 0;
        }
    }
    return 1;
}

void resetRobot(Robot *robot) {
    do {
        generateName(robot->name);
    } while (!isUniqueName(robot->name));

    strcpy(usedNames[usedCount++], robot->name);
}

char* getRobotName(Robot *robot) {
    return robot->name;
}

int main() {
    srand(time(0));

    Robot robot1, robot2, robot3, robot4, robot5;

    resetRobot(&robot1);
    resetRobot(&robot2);
    resetRobot(&robot3);
    resetRobot(&robot4);
    resetRobot(&robot5);

    printf("%s\n", getRobotName(&robot1));
    printf("%s\n", getRobotName(&robot2));
    printf("%s\n", getRobotName(&robot3));
    printf("%s\n", getRobotName(&robot4));
    printf("%s\n", getRobotName(&robot5));

    resetRobot(&robot1);
    printf("%s\n", getRobotName(&robot1));

    return 0;
}
```
Created file: Task184.java
Created file: Task184.py
Created file: Task184.cpp
Created file: Task184.c
Task185_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task185, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).



Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.


Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 10^6
```java
public class Task185 {
    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        int m = nums1.length;
        int n = nums2.length;
        int imin = 0, imax = m, halfLen = (m + n + 1) / 2;
        while (imin <= imax) {
            int i = (imin + imax) / 2;
            int j = halfLen - i;
            if (i < m && nums2[j-1] > nums1[i]) {
                imin = i + 1;
            } else if (i > 0 && nums1[i-1] > nums2[j]) {
                imax = i - 1;
            } else {
                int maxOfLeft;
                if (i == 0) { maxOfLeft = nums2[j-1]; }
                else if (j == 0) { maxOfLeft = nums1[i-1]; }
                else { maxOfLeft = Math.max(nums1[i-1], nums2[j-1]); }
                if ((m + n) % 2 == 1) {
                    return maxOfLeft;
                }

                int minOfRight;
                if (i == m) { minOfRight = nums2[j]; }
                else if (j == n) { minOfRight = nums1[i]; }
                else { minOfRight = Math.min(nums1[i], nums2[j]); }

                return (maxOfLeft + minOfRight) / 2.0;
            }
        }
        return 0.0;
    }

    public static void main(String[] args) {
        System.out.println(findMedianSortedArrays(new int[]{1, 3}, new int[]{2})); // 2.0
        System.out.println(findMedianSortedArrays(new int[]{1, 2}, new int[]{3, 4})); // 2.5
        System.out.println(findMedianSortedArrays(new int[]{0, 0}, new int[]{0, 0})); // 0.0
        System.out.println(findMedianSortedArrays(new int[]{}, new int[]{1})); // 1.0
        System.out.println(findMedianSortedArrays(new int[]{2}, new int[]{1, 3})); // 2.0
    }
}
```
```python
def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0: max_of_left = nums2[j - 1]
            elif j == 0: max_of_left = nums1[i - 1]
            else: max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m: min_of_right = nums2[j]
            elif j == n: min_of_right = nums1[i]
            else: min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2.0

print(findMedianSortedArrays([1, 3], [2])) # 2.0
print(findMedianSortedArrays([1, 2], [3, 4])) # 2.5
print(findMedianSortedArrays([0, 0], [0, 0])) # 0.0
print(findMedianSortedArrays([], [1])) # 1.0
print(findMedianSortedArrays([2], [1, 3])) # 2.0
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Task185 {
public:
    static double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            swap(nums1, nums2);
        }
        int m = nums1.size(), n = nums2.size();
        int imin = 0, imax = m, half_len = (m + n + 1) / 2;
        while (imin <= imax) {
            int i = (imin + imax) / 2;
            int j = half_len - i;
            if (i < m && nums2[j - 1] > nums1[i]) {
                imin = i + 1;
            } else if (i > 0 && nums1[i - 1] > nums2[j]) {
                imax = i - 1;
            } else {
                int max_of_left;
                if (i == 0) { max_of_left = nums2[j - 1]; }
                else if (j == 0) { max_of_left = nums1[i - 1]; }
                else { max_of_left = max(nums1[i - 1], nums2[j - 1]); }
                if ((m + n) % 2 == 1) {
                    return max_of_left;
                }

                int min_of_right;
                if (i == m) { min_of_right = nums2[j]; }
                else if (j == n) { min_of_right = nums1[i]; }
                else { min_of_right = min(nums1[i], nums2[j]); }

                return (max_of_left + min_of_right) / 2.0;
            }
        }
        return 0.0;
    }
};

int main() {
    cout << Task185::findMedianSortedArrays(vector<int>{1, 3}, vector<int>{2}) << endl; // 2.0
    cout << Task185::findMedianSortedArrays(vector<int>{1, 2}, vector<int>{3, 4}) << endl; // 2.5
    cout << Task185::findMedianSortedArrays(vector<int>{0, 0}, vector<int>{0, 0}) << endl; // 0.0
    cout << Task185::findMedianSortedArrays(vector<int>{}, vector<int>{1}) << endl; // 1.0
    cout << Task185::findMedianSortedArrays(vector<int>{2}, vector<int>{1, 3}) << endl; // 2.0
    return 0;
}
```
```c
#include <stdio.h>
#include <limits.h>

double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    if (nums1Size > nums2Size) {
        return findMedianSortedArrays(nums2, nums2Size, nums1, nums1Size);
    }
    int m = nums1Size, n = nums2Size;
    int imin = 0, imax = m, half_len = (m + n + 1) / 2;
    while (imin <= imax) {
        int i = (imin + imax) / 2;
        int j = half_len - i;
        if (i < m && nums2[j - 1] > nums1[i]) {
            imin = i + 1;
        } else if (i > 0 && nums1[i - 1] > nums2[j]) {
            imax = i - 1;
        } else {
            int max_of_left;
            if (i == 0) { max_of_left = nums2[j - 1]; }
            else if (j == 0) { max_of_left = nums1[i - 1]; }
            else { max_of_left = (nums1[i - 1] > nums2[j - 1]) ? nums1[i - 1] : nums2[j - 1]; }
            if ((m + n) % 2 == 1) {
                return max_of_left;
            }

            int min_of_right;
            if (i == m) { min_of_right = nums2[j]; }
            else if (j == n) { min_of_right = nums1[i]; }
            else { min_of_right = (nums1[i] < nums2[j]) ? nums1[i] : nums2[j]; }

            return (max_of_left + min_of_right) / 2.0;
        }
    }
    return 0.0;
}

int main() {
    int nums1[] = {1, 3};
    int nums2[] = {2};
    printf("%f\n", findMedianSortedArrays(nums1, 2, nums2, 1)); // 2.0

    int nums3[] = {1, 2};
    int nums4[] = {3, 4};
    printf("%f\n", findMedianSortedArrays(nums3, 2, nums4, 2)); // 2.5

    int nums5[] = {0, 0};
    int nums6[] = {0, 0};
    printf("%f\n", findMedianSortedArrays(nums5, 2, nums6, 2)); // 0.0

    int nums7[] = {};
    int nums8[] = {1};
    printf("%f\n", findMedianSortedArrays(nums7, 0, nums8, 1)); // 1.0

    int nums9[] = {2};
    int nums10[] = {1, 3};
    printf("%f\n", findMedianSortedArrays(nums9, 1, nums10, 2)); // 2.0

    return 0;
}
```
Created file: Task185.java
Created file: Task185.py
Created file: Task185.cpp
Created file: Task185.c
Task186_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task186, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.



Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
Example 2:

Input: lists = []
Output: []
Example 3:

Input: lists = [[]]
Output: []


Constraints:

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] is sorted in ascending order.
The sum of lists[i].length will not exceed 10^4.
```java
import java.util.PriorityQueue;
import java.util.Comparator;

class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public class Task186 {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val));

        for (ListNode node : lists) {
            if (node != null) {
                pq.offer(node);
            }
        }

        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (!pq.isEmpty()) {
            current.next = pq.poll();
            current = current.next;
            if (current.next != null) {
                pq.offer(current.next);
            }
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        Task186 task = new Task186();

        ListNode[] lists1 = {createList(new int[]{1, 4, 5}), createList(new int[]{1, 3, 4}), createList(new int[]{2, 6})};
        ListNode result1 = task.mergeKLists(lists1);
        printList(result1);

        ListNode[] lists2 = {};
        ListNode result2 = task.mergeKLists(lists2);
        printList(result2);

        ListNode[] lists3 = {createList(new int[]{})};
        ListNode result3 = task.mergeKLists(lists3);
        printList(result3);

        ListNode[] lists4 = {createList(new int[]{1, 2}), createList(new int[]{3, 4}), createList(new int[]{5, 6})};
        ListNode result4 = task.mergeKLists(lists4);
        printList(result4);

        ListNode[] lists5 = {createList(new int[]{0}), createList(new int[]{-1, 1}), createList(new int[]{})};
        ListNode result5 = task.mergeKLists(lists5);
        printList(result5);
    }

    private static ListNode createList(int[] arr) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    private static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val + " ");
            node = node.next;
        }
        System.out.println();
    }
}
```
```python
from heapq import heappush, heappop

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Task186:
    def mergeKLists(self, lists):
        heap = []
        for node in lists:
            if node:
                heappush(heap, (node.val, node))

        dummy = ListNode(0)
        current = dummy
        while heap:
            val, node = heappop(heap)
            current.next = node
            current = current.next
            if node.next:
                heappush(heap, (node.next.val, node.next))

        return dummy.next

def create_list(arr):
    dummy = ListNode(0)
    current = dummy
    for val in arr:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def print_list(node):
    while node:
        print(node.val, end=' ')
        node = node.next
    print()

if __name__ == "__main__":
    task = Task186()

    lists1 = [create_list([1, 4, 5]), create_list([1, 3, 4]), create_list([2, 6])]
    result1 = task.mergeKLists(lists1)
    print_list(result1)

    lists2 = []
    result2 = task.mergeKLists(lists2)
    print_list(result2)

    lists3 = [create_list([])]
    result3 = task.mergeKLists(lists3)
    print_list(result3)

    lists4 = [create_list([1, 2]), create_list([3, 4]), create_list([5, 6])]
    result4 = task.mergeKLists(lists4)
    print_list(result4)

    lists5 = [create_list([0]), create_list([-1, 1]), create_list([])]
    result5 = task.mergeKLists(lists5)
    print_list(result5)
```
```cpp
#include <iostream>
#include <vector>
#include <queue>

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct compare {
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};

class Task186 {
public:
    ListNode* mergeKLists(std::vector<ListNode*>& lists) {
        std::priority_queue<ListNode*, std::vector<ListNode*>, compare> pq;

        for (auto node : lists) {
            if (node) {
                pq.push(node);
            }
        }

        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        while (!pq.empty()) {
            current->next = pq.top();
            pq.pop();
            current = current->next;
            if (current->next) {
                pq.push(current->next);
            }
        }

        return dummy->next;
    }
};

ListNode* createList(const std::vector<int>& arr) {
    ListNode* dummy = new ListNode(0);
    ListNode* current = dummy;
    for (int val : arr) {
        current->next = new ListNode(val);
        current = current->next;
    }
    return dummy->next;
}

void printList(ListNode* node) {
    while (node) {
        std::cout << node->val << " ";
        node = node->next;
    }
    std::cout << std::endl;
}

int main() {
    Task186 task;

    std::vector<ListNode*> lists1 = {createList({1, 4, 5}), createList({1, 3, 4}), createList({2, 6})};
    ListNode* result1 = task.mergeKLists(lists1);
    printList(result1);

    std::vector<ListNode*> lists2 = {};
    ListNode* result2 = task.mergeKLists(lists2);
    printList(result2);

    std::vector<ListNode*> lists3 = {createList({})};
    ListNode* result3 = task.mergeKLists(lists3);
    printList(result3);

    std::vector<ListNode*> lists4 = {createList({1, 2}), createList({3, 4}), createList({5, 6})};
    ListNode* result4 = task.mergeKLists(lists4);
    printList(result4);

    std::vector<ListNode*> lists5 = {createList({0}), createList({-1, 1}), createList({})};
    ListNode* result5 = task.mergeKLists(lists5);
    printList(result5);

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode* next;
};

struct ListNode* createList(const int* arr, int size) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->next = NULL;
    struct ListNode* current = dummy;
    for (int i = 0; i < size; i++) {
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current = current->next;
        current->val = arr[i];
        current->next = NULL;
    }
    struct ListNode* head = dummy->next;
    free(dummy);
    return head;
}

void printList(struct ListNode* node) {
    while (node != NULL) {
        printf("%d ", node->val);
        node = node->next;
    }
    printf("\n");
}

struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->next = NULL;
    struct ListNode* current = dummy;

    struct ListNode** heap = (struct ListNode**)malloc(listsSize * sizeof(struct ListNode*));
    int heapSize = 0;

    for (int i = 0; i < listsSize; i++) {
        if (lists[i] != NULL) {
            heap[heapSize++] = lists[i];
        }
    }

    while (heapSize > 0) {
        int minIndex = 0;
        for (int i = 1; i < heapSize; i++) {
            if (heap[i]->val < heap[minIndex]->val) {
                minIndex = i;
            }
        }
        current->next = heap[minIndex];
        current = current->next;
        if (heap[minIndex]->next != NULL) {
            heap[minIndex] = heap[minIndex]->next;
        } else {
            heap[minIndex] = heap[--heapSize];
        }
    }

    struct ListNode* head = dummy->next;
    free(dummy);
    free(heap);
    return head;
}

int main() {
    struct ListNode* lists1[] = {createList((int[]){1, 4, 5}, 3), createList((int[]){1, 3, 4}, 3), createList((int[]){2, 6}, 2)};
    struct ListNode* result1 = mergeKLists(lists1, 3);
    printList(result1);

    struct ListNode* lists2[] = {};
    struct ListNode* result2 = mergeKLists(lists2, 0);
    printList(result2);

    struct ListNode* lists3[] = {createList((int[]){}, 0)};
    struct ListNode* result3 = mergeKLists(lists3, 1);
    printList(result3);

    struct ListNode* lists4[] = {createList((int[]){1, 2}, 2), createList((int[]){3, 4}, 2), createList((int[]){5, 6}, 2)};
    struct ListNode* result4 = mergeKLists(lists4, 3);
    printList(result4);

    struct ListNode* lists5[] = {createList((int[]){0}, 1), createList((int[]){-1, 1}, 2), createList((int[]){}, 0)};
    struct ListNode* result5 = mergeKLists(lists5, 3);
    printList(result5);

    return 0;
}
```
Created file: Task186.java
Created file: Task186.py
Created file: Task186.cpp
Created file: Task186.c
Task187_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task187, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules.

There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.

In other words:

If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.
If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread.
We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.

Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.



Example 1:

Input: water = "HOH"
Output: "HHO"
Explanation: "HOH" and "OHH" are also valid answers.
Example 2:

Input: water = "OOHHHH"
Output: "HHOHHO"
Explanation: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" and "OHHOHH" are also valid answers.


Constraints:

3 * n == water.length
1 <= n <= 20
water[i] is either 'H' or 'O'.
There will be exactly 2 * n 'H' in water.
There will be exactly n 'O' in water.
```java
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

public class Task187 {
    class H2O {
        private Semaphore hSem = new Semaphore(2);
        private Semaphore oSem = new Semaphore(1);
        private AtomicInteger hCount = new AtomicInteger(0);

        public H2O() {}

        public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {
            hSem.acquire();
            releaseHydrogen.run();
            if (hCount.incrementAndGet() == 2) {
                oSem.release();
            }
        }

        public void oxygen(Runnable releaseOxygen) throws InterruptedException {
            oSem.acquire();
            releaseOxygen.run();
            hCount.set(0);
            hSem.release(2);
        }
    }

    public static void main(String[] args) {
        Task187 task = new Task187();
        H2O h2o = task.new H2O();

        String water = "OOHHHH";
        Runnable releaseHydrogen = () -> System.out.print("H");
        Runnable releaseOxygen = () -> System.out.print("O");

        for (char c : water.toCharArray()) {
            if (c == 'H') {
                new Thread(() -> {
                    try {
                        h2o.hydrogen(releaseHydrogen);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            } else {
                new Thread(() -> {
                    try {
                        h2o.oxygen(releaseOxygen);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            }
        }
    }
}
```
```python
from threading import Semaphore

class H2O:
    def __init__(self):
        self.hSem = Semaphore(2)
        self.oSem = Semaphore(1)
        self.hCount = 0

    def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:
        self.hSem.acquire()
        releaseHydrogen()
        self.hCount += 1
        if self.hCount == 2:
            self.oSem.release()

    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:
        self.oSem.acquire()
        releaseOxygen()
        self.hCount = 0
        self.hSem.release(2)

if __name__ == "__main__":
    import threading

    h2o = H2O()
    water = "OOHHHH"
    releaseHydrogen = lambda: print("H", end="")
    releaseOxygen = lambda: print("O", end="")

    threads = []
    for c in water:
        if c == 'H':
            thread = threading.Thread(target=h2o.hydrogen, args=(releaseHydrogen,))
        else:
            thread = threading.Thread(target=h2o.oxygen, args=(releaseOxygen,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()
```
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class H2O {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int hCount = 0;
    int oCount = 0;

public:
    void hydrogen(std::function<void()> releaseHydrogen) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] { return hCount < 2; });
        releaseHydrogen();
        hCount++;
        if (hCount == 2 && oCount == 1) {
            hCount = 0;
            oCount = 0;
            cv.notify_all();
        } else {
            cv.notify_one();
        }
    }

    void oxygen(std::function<void()> releaseOxygen) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] { return oCount < 1; });
        releaseOxygen();
        oCount++;
        if (hCount == 2 && oCount == 1) {
            hCount = 0;
            oCount = 0;
            cv.notify_all();
        } else {
            cv.notify_one();
        }
    }
};

void runTest(H2O &h2o, const std::string &water) {
    std::vector<std::thread> threads;
    for (char c : water) {
        if (c == 'H') {
            threads.push_back(std::thread([&h2o] {
                h2o.hydrogen([] { std::cout << "H"; });
            }));
        } else {
            threads.push_back(std::thread([&h2o] {
                h2o.oxygen([] { std::cout << "O"; });
            }));
        }
    }

    for (auto &t : threads) {
        t.join();
    }
}

int main() {
    H2O h2o;
    std::string water = "OOHHHH";
    runTest(h2o, water);
    std::cout << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

sem_t hSem, oSem;
int hCount = 0;

void *hydrogen(void *arg) {
    sem_wait(&hSem);
    printf("H");
    hCount++;
    if (hCount == 2) {
        sem_post(&oSem);
    }
    return NULL;
}

void *oxygen(void *arg) {
    sem_wait(&oSem);
    printf("O");
    hCount = 0;
    sem_post(&hSem);
    sem_post(&hSem);
    return NULL;
}

int main() {
    sem_init(&hSem, 0, 2);
    sem_init(&oSem, 0, 1);

    char *water = "OOHHHH";
    pthread_t threads[6];

    for (int i = 0; i < 6; ++i) {
        if (water[i] == 'H') {
            pthread_create(&threads[i], NULL, hydrogen, NULL);
        } else {
            pthread_create(&threads[i], NULL, oxygen, NULL);
        }
    }

    for (int i = 0; i < 6; ++i) {
        pthread_join(threads[i], NULL);
    }

    sem_destroy(&hSem);
    sem_destroy(&oSem);

    return 0;
}
```
Created file: Task187.java
Created file: Task187.py
Created file: Task187.cpp
Created file: Task187.c
Task188_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task188, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Suppose you are given the following code:

class FooBar {
  public void foo() {
    for (int i = 0; i < n; i++) {
      print("foo");
    }
  }

  public void bar() {
    for (int i = 0; i < n; i++) {
      print("bar");
    }
  }
}
The same instance of FooBar will be passed to two different threads:

thread A will call foo(), while
thread B will call bar().
Modify the given program to output "foobar" n times.



Example 1:

Input: n = 1
Output: "foobar"
Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar().
"foobar" is being output 1 time.
Example 2:

Input: n = 2
Output: "foobarfoobar"
Explanation: "foobar" is being output 2 times.


Constraints:

1 <= n <= 1000
```java
import java.util.concurrent.Semaphore;

class Task188 {
    private int n;
    private Semaphore fooSemaphore = new Semaphore(1);
    private Semaphore barSemaphore = new Semaphore(0);

    public Task188(int n) {
        this.n = n;
    }

    public void foo() throws InterruptedException {
        for (int i = 0; i < n; i++) {
            fooSemaphore.acquire();
            System.out.print("foo");
            barSemaphore.release();
        }
    }

    public void bar() throws InterruptedException {
        for (int i = 0; i < n; i++) {
            barSemaphore.acquire();
            System.out.print("bar");
            fooSemaphore.release();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for (int test = 1; test <= 5; test++) {
            System.out.println("Test case " + test + ":");
            Task188 task = new Task188(test);
            Thread threadA = new Thread(() -> {
                try {
                    task.foo();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            Thread threadB = new Thread(() -> {
                try {
                    task.bar();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            threadA.start();
            threadB.start();
            threadA.join();
            threadB.join();
            System.out.println();
        }
    }
}
```
```python
from threading import Semaphore, Thread

class Task188:
    def __init__(self, n):
        self.n = n
        self.foo_semaphore = Semaphore(1)
        self.bar_semaphore = Semaphore(0)

    def foo(self):
        for _ in range(self.n):
            self.foo_semaphore.acquire()
            print("foo", end='')
            self.bar_semaphore.release()

    def bar(self):
        for _ in range(self.n):
            self.bar_semaphore.acquire()
            print("bar", end='')
            self.foo_semaphore.release()

def main():
    for test in range(1, 6):
        print(f"Test case {test}:")
        task = Task188(test)
        thread_a = Thread(target=task.foo)
        thread_b = Thread(target=task.bar)
        thread_a.start()
        thread_b.start()
        thread_a.join()
        thread_b.join()
        print()

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class Task188 {
private:
    int n;
    std::mutex mtx;
    std::condition_variable cv;
    bool foo_turn = true;

public:
    Task188(int n) : n(n) {}

    void foo() {
        for (int i = 0; i < n; ++i) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [&]() { return foo_turn; });
            std::cout << "foo";
            foo_turn = false;
            cv.notify_one();
        }
    }

    void bar() {
        for (int i = 0; i < n; ++i) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [&]() { return !foo_turn; });
            std::cout << "bar";
            foo_turn = true;
            cv.notify_one();
        }
    }
};

int main() {
    for (int test = 1; test <= 5; ++test) {
        std::cout << "Test case " << test << ":" << std::endl;
        Task188 task(test);
        std::thread threadA(&Task188::foo, &task);
        std::thread threadB(&Task188::bar, &task);
        threadA.join();
        threadB.join();
        std::cout << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <pthread.h>

typedef struct {
    int n;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int turn;
} Task188;

void* foo(void* arg) {
    Task188* task = (Task188*)arg;
    for (int i = 0; i < task->n; ++i) {
        pthread_mutex_lock(&task->mutex);
        while (task->turn != 0)
            pthread_cond_wait(&task->cond, &task->mutex);
        printf("foo");
        task->turn = 1;
        pthread_cond_signal(&task->cond);
        pthread_mutex_unlock(&task->mutex);
    }
    return NULL;
}

void* bar(void* arg) {
    Task188* task = (Task188*)arg;
    for (int i = 0; i < task->n; ++i) {
        pthread_mutex_lock(&task->mutex);
        while (task->turn != 1)
            pthread_cond_wait(&task->cond, &task->mutex);
        printf("bar");
        task->turn = 0;
        pthread_cond_signal(&task->cond);
        pthread_mutex_unlock(&task->mutex);
    }
    return NULL;
}

int main() {
    for (int test = 1; test <= 5; ++test) {
        printf("Test case %d:\n", test);
        Task188 task = {test, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};
        pthread_t threadA, threadB;
        pthread_create(&threadA, NULL, foo, &task);
        pthread_create(&threadB, NULL, bar, &task);
        pthread_join(threadA, NULL);
        pthread_join(threadB, NULL);
        printf("\n");
    }
    return 0;
}
```
Created file: Task188.java
Created file: Task188.py
Created file: Task188.cpp
Created file: Task188.c
Task189_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task189, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You have a function printNumber that can be called with an integer parameter and prints it to the console.

For example, calling printNumber(7) prints 7 to the console.
You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads:

Thread A: calls zero() that should only output 0's.
Thread B: calls even() that should only output even numbers.
Thread C: calls odd() that should only output odd numbers.
Modify the given class to output the series "010203040506..." where the length of the series must be 2n.

Implement the ZeroEvenOdd class:

ZeroEvenOdd(int n) Initializes the object with the number n that represents the numbers that should be printed.
void zero(printNumber) Calls printNumber to output one zero.
void even(printNumber) Calls printNumber to output one even number.
void odd(printNumber) Calls printNumber to output one odd number.


Example 1:

Input: n = 2
Output: "0102"
Explanation: There are three threads being fired asynchronously.
One of them calls zero(), the other calls even(), and the last one calls odd().
"0102" is the correct output.
Example 2:

Input: n = 5
Output: "0102030405"


Constraints:

1 <= n <= 1000
```java
import java.util.concurrent.Semaphore;

class Task189 {
    private int n;
    private Semaphore zeroSem = new Semaphore(1);
    private Semaphore evenSem = new Semaphore(0);
    private Semaphore oddSem = new Semaphore(0);

    public Task189(int n) {
        this.n = n;
    }

    public void zero(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            zeroSem.acquire();
            printNumber.accept(0);
            if (i % 2 == 0) {
                oddSem.release();
            } else {
                evenSem.release();
            }
        }
    }

    public void even(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 2; i <= n; i += 2) {
            evenSem.acquire();
            printNumber.accept(i);
            zeroSem.release();
        }
    }

    public void odd(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i += 2) {
            oddSem.acquire();
            printNumber.accept(i);
            zeroSem.release();
        }
    }

    public static void main(String[] args) {
        Task189 zeo = new Task189(5);

        Thread t1 = new Thread(() -> {
            try {
                zeo.zero(System.out::print);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread t2 = new Thread(() -> {
            try {
                zeo.even(System.out::print);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread t3 = new Thread(() -> {
            try {
                zeo.odd(System.out::print);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```
```python
from threading import Thread, Semaphore

class ZeroEvenOdd:
    def __init__(self, n):
        self.n = n
        self.zero_semaphore = Semaphore(1)
        self.even_semaphore = Semaphore(0)
        self.odd_semaphore = Semaphore(0)

    def zero(self, printNumber):
        for i in range(self.n):
            self.zero_semaphore.acquire()
            printNumber(0)
            if i % 2 == 0:
                self.odd_semaphore.release()
            else:
                self.even_semaphore.release()

    def even(self, printNumber):
        for i in range(2, self.n + 1, 2):
            self.even_semaphore.acquire()
            printNumber(i)
            self.zero_semaphore.release()

    def odd(self, printNumber):
        for i in range(1, self.n + 1, 2):
            self.odd_semaphore.acquire()
            printNumber(i)
            self.zero_semaphore.release()

def printNumber(x):
    print(x, end='')

def main():
    zeo = ZeroEvenOdd(5)

    t1 = Thread(target=zeo.zero, args=(printNumber,))
    t2 = Thread(target=zeo.even, args=(printNumber,))
    t3 = Thread(target=zeo.odd, args=(printNumber,))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()

if __name__ == '__main__':
    main()
```
```cpp
#include <iostream>
#include <thread>
#include <semaphore.h>

class ZeroEvenOdd {
private:
    int n;
    std::binary_semaphore zeroSem{1}, evenSem{0}, oddSem{0};

public:
    ZeroEvenOdd(int n) : n(n) {}

    void zero(std::function<void(int)> printNumber) {
        for (int i = 0; i < n; ++i) {
            zeroSem.acquire();
            printNumber(0);
            if (i % 2 == 0) {
                oddSem.release();
            } else {
                evenSem.release();
            }
        }
    }

    void even(std::function<void(int)> printNumber) {
        for (int i = 2; i <= n; i += 2) {
            evenSem.acquire();
            printNumber(i);
            zeroSem.release();
        }
    }

    void odd(std::function<void(int)> printNumber) {
        for (int i = 1; i <= n; i += 2) {
            oddSem.acquire();
            printNumber(i);
            zeroSem.release();
        }
    }
};

void printNumber(int x) {
    std::cout << x;
}

int main() {
    ZeroEvenOdd zeo(5);

    std::thread t1(&ZeroEvenOdd::zero, &zeo, printNumber);
    std::thread t2(&ZeroEvenOdd::even, &zeo, printNumber);
    std::thread t3(&ZeroEvenOdd::odd, &zeo, printNumber);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}
```
```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

typedef struct {
    int n;
    sem_t zeroSem;
    sem_t evenSem;
    sem_t oddSem;
} ZeroEvenOdd;

void initZeroEvenOdd(ZeroEvenOdd* obj, int n) {
    obj->n = n;
    sem_init(&obj->zeroSem, 0, 1);
    sem_init(&obj->evenSem, 0, 0);
    sem_init(&obj->oddSem, 0, 0);
}

void* zero(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 0; i < obj->n; ++i) {
        sem_wait(&obj->zeroSem);
        printf("%d", 0);
        if (i % 2 == 0) {
            sem_post(&obj->oddSem);
        } else {
            sem_post(&obj->evenSem);
        }
    }
    return NULL;
}

void* even(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 2; i <= obj->n; i += 2) {
        sem_wait(&obj->evenSem);
        printf("%d", i);
        sem_post(&obj->zeroSem);
    }
    return NULL;
}

void* odd(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 1; i <= obj->n; i += 2) {
        sem_wait(&obj->oddSem);
        printf("%d", i);
        sem_post(&obj->zeroSem);
    }
    return NULL;
}

int main() {
    ZeroEvenOdd zeo;
    initZeroEvenOdd(&zeo, 5);

    pthread_t t1, t2, t3;

    pthread_create(&t1, NULL, zero, &zeo);
    pthread_create(&t2, NULL, even, &zeo);
    pthread_create(&t3, NULL, odd, &zeo);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);

    sem_destroy(&zeo.zeroSem);
    sem_destroy(&zeo.evenSem);
    sem_destroy(&zeo.oddSem);

    return 0;
}
```
Created file: Task189.java
Created file: Task189.py
Created file: Task189.cpp
Created file: Task189.c
Task190_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task190, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given a text file file.txt, transpose its content.

You may assume that each row has the same number of columns, and each field is separated by the ' ' character.

Example:

If file.txt has the following content:

name age
alice 21
ryan 30
Output the following:

name alice ryan
age 21 30
```java
import java.io.*;
import java.util.*;

public class Task190 {
    public static List<String> transposeFileContent(String filePath) throws IOException {
        List<List<String>> lines = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(Arrays.asList(line.split(" ")));
            }
        }
        if (lines.isEmpty()) return Collections.emptyList();

        List<String> result = new ArrayList<>();
        for (int i = 0; i < lines.get(0).size(); i++) {
            StringBuilder sb = new StringBuilder();
            for (List<String> row : lines) {
                if (sb.length() > 0) sb.append(" ");
                sb.append(row.get(i));
            }
            result.add(sb.toString());
        }
        return result;
    }

    public static void main(String[] args) {
        try {
            List<String> output = transposeFileContent("file.txt");
            for (String line : output) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
```python
def transpose_file_content(file_path):
    with open(file_path, 'r') as file:
        lines = [line.strip().split() for line in file]

    if not lines:
        return []

    transposed = zip(*lines)
    return [' '.join(row) for row in transposed]

def main():
    output = transpose_file_content("file.txt")
    for line in output:
        print(line)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>

void transposeFileContent(const std::string &filePath) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Could not open the file!" << std::endl;
        return;
    }

    std::vector<std::vector<std::string>> lines;
    std::string line;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::vector<std::string> row;
        std::string word;
        while (iss >> word) {
            row.push_back(word);
        }
        lines.push_back(row);
    }

    if (lines.empty()) return;

    for (size_t i = 0; i < lines[0].size(); ++i) {
        for (size_t j = 0; j < lines.size(); ++j) {
            if (j > 0) std::cout << " ";
            std::cout << lines[j][i];
        }
        std::cout << std::endl;
    }
}

int main() {
    transposeFileContent("file.txt");
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void transposeFileContent(const char *filePath) {
    FILE *file = fopen(filePath, "r");
    if (!file) {
        fprintf(stderr, "Could not open the file!\n");
        return;
    }

    char buffer[1024];
    char *lines[100][100];
    int row = 0, col = 0;

    while (fgets(buffer, sizeof(buffer), file)) {
        col = 0;
        char *token = strtok(buffer, " \n");
        while (token) {
            lines[row][col++] = strdup(token);
            token = strtok(NULL, " \n");
        }
        row++;
    }
    fclose(file);

    if (row == 0) return;

    for (int i = 0; i < col; ++i) {
        for (int j = 0; j < row; ++j) {
            if (j > 0) printf(" ");
            printf("%s", lines[j][i]);
        }
        printf("\n");
    }

    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < col; ++j) {
            free(lines[i][j]);
        }
    }
}

int main() {
    transposeFileContent("file.txt");
    return 0;
}
```
Created file: Task190.java
Created file: Task190.py
Created file: Task190.cpp
Created file: Task190.c
Task191_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task191, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses
substring
.



Example 1:

Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".
Example 2:

Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".
Example 3:

Input: s = ""
Output: 0


Constraints:

0 <= s.length <= 3 * 10^4
s[i] is '(', or ')'.
```java
public class Task191 {
    public int longestValidParentheses(String s) {
        int maxLength = 0;
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    maxLength = Math.max(maxLength, i - stack.peek());
                }
            }
        }
        return maxLength;
    }

    public static void main(String[] args) {
        Task191 task = new Task191();
        System.out.println(task.longestValidParentheses("(()")); // Output: 2
        System.out.println(task.longestValidParentheses(")()())")); // Output: 4
        System.out.println(task.longestValidParentheses("")); // Output: 0
        System.out.println(task.longestValidParentheses("()(()")); // Output: 2
        System.out.println(task.longestValidParentheses("()(()())")); // Output: 8
    }
}
```
```python
def longestValidParentheses(s: str) -> int:
    max_length = 0
    stack = [-1]
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length

if __name__ == "__main__":
    print(longestValidParentheses("(()"))  # Output: 2
    print(longestValidParentheses(")()())"))  # Output: 4
    print(longestValidParentheses(""))  # Output: 0
    print(longestValidParentheses("()(()"))  # Output: 2
    print(longestValidParentheses("()(()())"))  # Output: 8
```
```cpp
#include <iostream>
#include <stack>
#include <string>
#include <algorithm>

class Task191 {
public:
    int longestValidParentheses(const std::string &s) {
        int maxLength = 0;
        std::stack<int> stack;
        stack.push(-1);
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.empty()) {
                    stack.push(i);
                } else {
                    maxLength = std::max(maxLength, i - stack.top());
                }
            }
        }
        return maxLength;
    }
};

int main() {
    Task191 task;
    std::cout << task.longestValidParentheses("(()") << std::endl; // Output: 2
    std::cout << task.longestValidParentheses(")()())") << std::endl; // Output: 4
    std::cout << task.longestValidParentheses("") << std::endl; // Output: 0
    std::cout << task.longestValidParentheses("()(()") << std::endl; // Output: 2
    std::cout << task.longestValidParentheses("()(()())") << std::endl; // Output: 8
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

int longestValidParentheses(const char* s) {
    int maxLength = 0;
    int stack[strlen(s) + 1];
    int top = -1;
    stack[++top] = -1;

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '(') {
            stack[++top] = i;
        } else {
            top--;
            if (top == -1) {
                stack[++top] = i;
            } else {
                int currentLength = i - stack[top];
                if (currentLength > maxLength) {
                    maxLength = currentLength;
                }
            }
        }
    }

    return maxLength;
}

int main() {
    printf("%d\n", longestValidParentheses("(()")); // Output: 2
    printf("%d\n", longestValidParentheses(")()())")); // Output: 4
    printf("%d\n", longestValidParentheses("")); // Output: 0
    printf("%d\n", longestValidParentheses("()(()")); // Output: 2
    printf("%d\n", longestValidParentheses("()(()())")); // Output: 8
    return 0;
}
```
Created file: Task191.java
Created file: Task191.py
Created file: Task191.cpp
Created file: Task191.c
Task192_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task192, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array of integers nums represents the numbers written on a chalkboard.

Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.

Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return true if and only if Alice wins the game, assuming both players play optimally.



Example 1:

Input: nums = [1,1,2]
Output: false
Explanation:
Alice has two choices: erase 1 or erase 2.
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.
If Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.
Example 2:

Input: nums = [0,1]
Output: true
Example 3:

Input: nums = [1,2,3]
Output: true


Constraints:

1 <= nums.length <= 1000
0 <= nums[i] < 2^16
```java
public class Task192 {
    public static boolean xorGame(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        return xor == 0 || nums.length % 2 == 0;
    }

    public static void main(String[] args) {
        System.out.println(xorGame(new int[]{1, 1, 2})); // false
        System.out.println(xorGame(new int[]{0, 1})); // true
        System.out.println(xorGame(new int[]{1, 2, 3})); // true
        System.out.println(xorGame(new int[]{5, 5, 5, 5})); // true
        System.out.println(xorGame(new int[]{1, 2, 3, 4})); // false
    }
}
```
```python
def xor_game(nums):
    xor = 0
    for num in nums:
        xor ^= num
    return xor == 0 or len(nums) % 2 == 0

def main():
    print(xor_game([1, 1, 2]))  # false
    print(xor_game([0, 1]))     # true
    print(xor_game([1, 2, 3]))  # true
    print(xor_game([5, 5, 5, 5]))  # true
    print(xor_game([1, 2, 3, 4]))  # false

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>

class Task192 {
public:
    static bool xorGame(const std::vector<int>& nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        return xor == 0 || nums.size() % 2 == 0;
    }

    static void runTests() {
        std::cout << std::boolalpha;
        std::cout << xorGame({1, 1, 2}) << std::endl; // false
        std::cout << xorGame({0, 1}) << std::endl;    // true
        std::cout << xorGame({1, 2, 3}) << std::endl; // true
        std::cout << xorGame({5, 5, 5, 5}) << std::endl; // true
        std::cout << xorGame({1, 2, 3, 4}) << std::endl; // false
    }
};

int main() {
    Task192::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>

bool xorGame(int* nums, int numsSize) {
    int xor = 0;
    for (int i = 0; i < numsSize; i++) {
        xor ^= nums[i];
    }
    return xor == 0 || numsSize % 2 == 0;
}

int main() {
    int nums1[] = {1, 1, 2};
    int nums2[] = {0, 1};
    int nums3[] = {1, 2, 3};
    int nums4[] = {5, 5, 5, 5};
    int nums5[] = {1, 2, 3, 4};

    printf("%s\n", xorGame(nums1, 3) ? "true" : "false"); // false
    printf("%s\n", xorGame(nums2, 2) ? "true" : "false"); // true
    printf("%s\n", xorGame(nums3, 3) ? "true" : "false"); // true
    printf("%s\n", xorGame(nums4, 4) ? "true" : "false"); // true
    printf("%s\n", xorGame(nums5, 4) ? "true" : "false"); // false

    return 0;
}
```
Created file: Task192.java
Created file: Task192.py
Created file: Task192.cpp
Created file: Task192.c
Task193_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task193, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array of integers nums represents the numbers written on a chalkboard.

Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.

Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return true if and only if Alice wins the game, assuming both players play optimally.



Example 1:

Input: nums = [1,1,2]
Output: false
Explanation:
Alice has two choices: erase 1 or erase 2.
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.
If Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.
Example 2:

Input: nums = [0,1]
Output: true
Example 3:

Input: nums = [1,2,3]
Output: true


Constraints:

1 <= nums.length <= 1000
0 <= nums[i] < 2^16
```java
public class Task193 {
    public static boolean xorGame(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        return xor == 0 || nums.length % 2 == 0;
    }

    public static void main(String[] args) {
        System.out.println(xorGame(new int[]{1, 1, 2})); // false
        System.out.println(xorGame(new int[]{0, 1}));    // true
        System.out.println(xorGame(new int[]{1, 2, 3})); // true
        System.out.println(xorGame(new int[]{2, 2, 3})); // true
        System.out.println(xorGame(new int[]{1, 1, 1, 1})); // true
    }
}
```
```python
class Task193:
    @staticmethod
    def xor_game(nums):
        xor = 0
        for num in nums:
            xor ^= num
        return xor == 0 or len(nums) % 2 == 0

if __name__ == "__main__":
    print(Task193.xor_game([1, 1, 2]))  # False
    print(Task193.xor_game([0, 1]))     # True
    print(Task193.xor_game([1, 2, 3]))  # True
    print(Task193.xor_game([2, 2, 3]))  # True
    print(Task193.xor_game([1, 1, 1, 1])) # True
```
```cpp
#include <iostream>
#include <vector>

class Task193 {
public:
    static bool xorGame(std::vector<int>& nums) {
        int xorSum = 0;
        for (int num : nums) {
            xorSum ^= num;
        }
        return xorSum == 0 || nums.size() % 2 == 0;
    }
};

int main() {
    std::vector<int> nums1 = {1, 1, 2};
    std::vector<int> nums2 = {0, 1};
    std::vector<int> nums3 = {1, 2, 3};
    std::vector<int> nums4 = {2, 2, 3};
    std::vector<int> nums5 = {1, 1, 1, 1};

    std::cout << Task193::xorGame(nums1) << std::endl; // false
    std::cout << Task193::xorGame(nums2) << std::endl; // true
    std::cout << Task193::xorGame(nums3) << std::endl; // true
    std::cout << Task193::xorGame(nums4) << std::endl; // true
    std::cout << Task193::xorGame(nums5) << std::endl; // true

    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>

bool xorGame(int* nums, int numsSize) {
    int xorSum = 0;
    for (int i = 0; i < numsSize; i++) {
        xorSum ^= nums[i];
    }
    return xorSum == 0 || numsSize % 2 == 0;
}

int main() {
    int nums1[] = {1, 1, 2};
    int nums2[] = {0, 1};
    int nums3[] = {1, 2, 3};
    int nums4[] = {2, 2, 3};
    int nums5[] = {1, 1, 1, 1};

    printf("%d\n", xorGame(nums1, 3)); // false
    printf("%d\n", xorGame(nums2, 2)); // true
    printf("%d\n", xorGame(nums3, 3)); // true
    printf("%d\n", xorGame(nums4, 3)); // true
    printf("%d\n", xorGame(nums5, 4)); // true

    return 0;
}
```
Created file: Task193.java
Created file: Task193.py
Created file: Task193.cpp
Created file: Task193.c
Task194_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task194, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word.

You are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns:

-1 if word is not from words, or
an integer representing the number of exact matches (value and position) of your guess to the secret word.
There is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word).

For each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get:

"Either you took too many guesses, or you did not find the secret word." if you called Master.guess more than allowedGuesses times or if you did not call Master.guess with the secret word, or
"You guessed the secret word correctly." if you called Master.guess with the secret word with the number of calls to Master.guess less than or equal to allowedGuesses.
The test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).



Example 1:

Input: secret = "acckzz", words = ["acckzz","ccbazz","eiowzz","abcczz"], allowedGuesses = 10
Output: You guessed the secret word correctly.
Explanation:
master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
master.guess("abcczz") returns 4, because "abcczz" has 4 matches.
We made 5 calls to master.guess, and one of them was the secret, so we pass the test case.
Example 2:

Input: secret = "hamada", words = ["hamada","khaled"], allowedGuesses = 10
Output: You guessed the secret word correctly.
Explanation: Since there are two words, you can guess both.


Constraints:

1 <= words.length <= 100
words[i].length == 6
words[i] consist of lowercase English letters.
All the strings of wordlist are unique.
secret exists in words.
10 <= allowedGuesses <= 30
```java
import java.util.Arrays;
import java.util.List;

class Master {
    private String secret;
    private int guesses;
    private int allowedGuesses;

    public Master(String secret, int allowedGuesses) {
        this.secret = secret;
        this.guesses = 0;
        this.allowedGuesses = allowedGuesses;
    }

    public int guess(String word) {
        if (guesses >= allowedGuesses) {
            throw new RuntimeException("Either you took too many guesses, or you did not find the secret word.");
        }
        guesses++;
        if (!Arrays.asList(Task194.words).contains(word)) {
            return -1;
        }
        if (word.equals(secret)) {
            System.out.println("You guessed the secret word correctly.");
            return 6;
        }
        return match(secret, word);
    }

    private int match(String a, String b) {
        int matches = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) == b.charAt(i)) {
                matches++;
            }
        }
        return matches;
    }
}

public class Task194 {
    public static String[] words = {};

    public static void findSecretWord(String[] words, Master master) {
        Task194.words = words;
        for (String word : words) {
            if (master.guess(word) == 6) {
                return;
            }
        }
        throw new RuntimeException("Either you took too many guesses, or you did not find the secret word.");
    }

    public static void main(String[] args) {
        String[] words1 = {"acckzz", "ccbazz", "eiowzz", "abcczz"};
        Master master1 = new Master("acckzz", 10);
        findSecretWord(words1, master1);

        String[] words2 = {"hamada", "khaled"};
        Master master2 = new Master("hamada", 10);
        findSecretWord(words2, master2);

        String[] words3 = {"abcdef", "ghijkl", "mnopqr", "stuvwx", "yzabcd", "efghij"};
        Master master3 = new Master("mnopqr", 10);
        findSecretWord(words3, master3);

        String[] words4 = {"secret", "random", "string"};
        Master master4 = new Master("secret", 10);
        findSecretWord(words4, master4);

        String[] words5 = {"unique", "secret", "wordss"};
        Master master5 = new Master("wordss", 10);
        findSecretWord(words5, master5);
    }
}
```
```python
class Master:
    def __init__(self, secret, allowed_guesses):
        self.secret = secret
        self.guesses = 0
        self.allowed_guesses = allowed_guesses

    def guess(self, word):
        if self.guesses >= self.allowed_guesses:
            raise Exception("Either you took too many guesses, or you did not find the secret word.")
        self.guesses += 1
        if word not in Task194.words:
            return -1
        if word == self.secret:
            print("You guessed the secret word correctly.")
            return 6
        return self.match(self.secret, word)

    def match(self, a, b):
        return sum(c1 == c2 for c1, c2 in zip(a, b))

class Task194:
    words = []

    @staticmethod
    def findSecretWord(words, master):
        Task194.words = words
        for word in words:
            if master.guess(word) == 6:
                return
        raise Exception("Either you took too many guesses, or you did not find the secret word.")

if __name__ == '__main__':
    words1 = ["acckzz", "ccbazz", "eiowzz", "abcczz"]
    master1 = Master("acckzz", 10)
    Task194.findSecretWord(words1, master1)

    words2 = ["hamada", "khaled"]
    master2 = Master("hamada", 10)
    Task194.findSecretWord(words2, master2)

    words3 = ["abcdef", "ghijkl", "mnopqr", "stuvwx", "yzabcd", "efghij"]
    master3 = Master("mnopqr", 10)
    Task194.findSecretWord(words3, master3)

    words4 = ["secret", "random", "string"]
    master4 = Master("secret", 10)
    Task194.findSecretWord(words4, master4)

    words5 = ["unique", "secret", "wordss"]
    master5 = Master("wordss", 10)
    Task194.findSecretWord(words5, master5)
```
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <stdexcept>

class Master {
public:
    Master(std::string secret, int allowedGuesses)
        : secret(secret), guesses(0), allowedGuesses(allowedGuesses) {}

    int guess(std::string word) {
        if (guesses >= allowedGuesses) {
            throw std::runtime_error("Either you took too many guesses, or you did not find the secret word.");
        }
        guesses++;
        if (std::find(Task194::words.begin(), Task194::words.end(), word) == Task194::words.end()) {
            return -1;
        }
        if (word == secret) {
            std::cout << "You guessed the secret word correctly." << std::endl;
            return 6;
        }
        return match(secret, word);
    }

private:
    std::string secret;
    int guesses;
    int allowedGuesses;

    int match(const std::string &a, const std::string &b) {
        int matches = 0;
        for (size_t i = 0; i < a.size(); ++i) {
            if (a[i] == b[i]) {
                matches++;
            }
        }
        return matches;
    }
};

class Task194 {
public:
    static std::vector<std::string> words;

    static void findSecretWord(std::vector<std::string> words, Master &master) {
        Task194::words = words;
        for (const auto &word : words) {
            if (master.guess(word) == 6) {
                return;
            }
        }
        throw std::runtime_error("Either you took too many guesses, or you did not find the secret word.");
    }
};

std::vector<std::string> Task194::words;

int main() {
    std::vector<std::string> words1 = {"acckzz", "ccbazz", "eiowzz", "abcczz"};
    Master master1("acckzz", 10);
    Task194::findSecretWord(words1, master1);

    std::vector<std::string> words2 = {"hamada", "khaled"};
    Master master2("hamada", 10);
    Task194::findSecretWord(words2, master2);

    std::vector<std::string> words3 = {"abcdef", "ghijkl", "mnopqr", "stuvwx", "yzabcd", "efghij"};
    Master master3("mnopqr", 10);
    Task194::findSecretWord(words3, master3);

    std::vector<std::string> words4 = {"secret", "random", "string"};
    Master master4("secret", 10);
    Task194::findSecretWord(words4, master4);

    std::vector<std::string> words5 = {"unique", "secret", "wordss"};
    Master master5("wordss", 10);
    Task194::findSecretWord(words5, master5);

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char *secret;
    int guesses;
    int allowedGuesses;
} Master;

int guess(Master *master, char *word, char **words, int wordCount) {
    if (master->guesses >= master->allowedGuesses) {
        printf("Either you took too many guesses, or you did not find the secret word.\n");
        exit(1);
    }
    master->guesses++;
    int found = 0;
    for (int i = 0; i < wordCount; i++) {
        if (strcmp(words[i], word) == 0) {
            found = 1;
            break;
        }
    }
    if (!found) {
        return -1;
    }
    if (strcmp(word, master->secret) == 0) {
        printf("You guessed the secret word correctly.\n");
        return 6;
    }
    int matches = 0;
    for (int i = 0; i < 6; i++) {
        if (word[i] == master->secret[i]) {
            matches++;
        }
    }
    return matches;
}

void findSecretWord(char **words, int wordCount, Master *master) {
    for (int i = 0; i < wordCount; i++) {
        if (guess(master, words[i], words, wordCount) == 6) {
            return;
        }
    }
    printf("Either you took too many guesses, or you did not find the secret word.\n");
    exit(1);
}

int main() {
    char *words1[] = {"acckzz", "ccbazz", "eiowzz", "abcczz"};
    Master master1 = {"acckzz", 0, 10};
    findSecretWord(words1, 4, &master1);

    char *words2[] = {"hamada", "khaled"};
    Master master2 = {"hamada", 0, 10};
    findSecretWord(words2, 2, &master2);

    char *words3[] = {"abcdef", "ghijkl", "mnopqr", "stuvwx", "yzabcd", "efghij"};
    Master master3 = {"mnopqr", 0, 10};
    findSecretWord(words3, 6, &master3);

    char *words4[] = {"secret", "random", "string"};
    Master master4 = {"secret", 0, 10};
    findSecretWord(words4, 3, &master4);

    char *words5[] = {"unique", "secret", "wordss"};
    Master master5 = {"wordss", 0, 10};
    findSecretWord(words5, 3, &master5);

    return 0;
}
```
Created file: Task194.java
Created file: Task194.py
Created file: Task194.cpp
Created file: Task194.c
Task195_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task195, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.

For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
Implement the MedianFinder class:

MedianFinder() initializes the MedianFinder object.
void addNum(int num) adds the integer num from the data stream to the data structure.
double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.


Example 1:

Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0


Constraints:

-105 <= num <= 105
There will be at least one element in the data structure before calling findMedian.
At most 5 * 104 calls will be made to addNum and findMedian.
```java
import java.util.PriorityQueue;
import java.util.Collections;

class Task195 {
    static class MedianFinder {
        private PriorityQueue<Integer> lowerHalf;
        private PriorityQueue<Integer> upperHalf;

        public MedianFinder() {
            lowerHalf = new PriorityQueue<>(Collections.reverseOrder());
            upperHalf = new PriorityQueue<>();
        }

        public void addNum(int num) {
            lowerHalf.offer(num);
            upperHalf.offer(lowerHalf.poll());
            if (lowerHalf.size() < upperHalf.size()) {
                lowerHalf.offer(upperHalf.poll());
            }
        }

        public double findMedian() {
            if (lowerHalf.size() > upperHalf.size()) {
                return lowerHalf.peek();
            } else {
                return (lowerHalf.peek() + upperHalf.peek()) / 2.0;
            }
        }
    }

    public static void main(String[] args) {
        MedianFinder medianFinder = new MedianFinder();
        medianFinder.addNum(1);
        medianFinder.addNum(2);
        System.out.println(medianFinder.findMedian()); // 1.5
        medianFinder.addNum(3);
        System.out.println(medianFinder.findMedian()); // 2.0
        medianFinder.addNum(4);
        System.out.println(medianFinder.findMedian()); // 2.5
        medianFinder.addNum(5);
        System.out.println(medianFinder.findMedian()); // 3.0
    }
}
```
```python
import heapq

class MedianFinder:
    def __init__(self):
        self.lower_half = [] # max heap
        self.upper_half = [] # min heap

    def addNum(self, num: int) -> None:
        heapq.heappush(self.lower_half, -num)
        heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half))
        if len(self.lower_half) < len(self.upper_half):
            heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half))

    def findMedian(self) -> float:
        if len(self.lower_half) > len(self.upper_half):
            return -self.lower_half[0]
        else:
            return (-self.lower_half[0] + self.upper_half[0]) / 2.0

if __name__ == "__main__":
    medianFinder = MedianFinder()
    medianFinder.addNum(1)
    medianFinder.addNum(2)
    print(medianFinder.findMedian()) # 1.5
    medianFinder.addNum(3)
    print(medianFinder.findMedian()) # 2.0
    medianFinder.addNum(4)
    print(medianFinder.findMedian()) # 2.5
    medianFinder.addNum(5)
    print(medianFinder.findMedian()) # 3.0
```
```cpp
#include <iostream>
#include <queue>

class MedianFinder {
private:
    std::priority_queue<int> lowerHalf;
    std::priority_queue<int, std::vector<int>, std::greater<int>> upperHalf;

public:
    MedianFinder() {}

    void addNum(int num) {
        lowerHalf.push(num);
        upperHalf.push(lowerHalf.top());
        lowerHalf.pop();
        if (lowerHalf.size() < upperHalf.size()) {
            lowerHalf.push(upperHalf.top());
            upperHalf.pop();
        }
    }

    double findMedian() {
        if (lowerHalf.size() > upperHalf.size()) {
            return lowerHalf.top();
        } else {
            return (lowerHalf.top() + upperHalf.top()) / 2.0;
        }
    }
};

int main() {
    MedianFinder medianFinder;
    medianFinder.addNum(1);
    medianFinder.addNum(2);
    std::cout << medianFinder.findMedian() << std::endl; // 1.5
    medianFinder.addNum(3);
    std::cout << medianFinder.findMedian() << std::endl; // 2.0
    medianFinder.addNum(4);
    std::cout << medianFinder.findMedian() << std::endl; // 2.5
    medianFinder.addNum(5);
    std::cout << medianFinder.findMedian() << std::endl; // 3.0

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;
    int size;
    int capacity;
} MedianFinder;

MedianFinder* medianFinderCreate() {
    MedianFinder* obj = (MedianFinder*)malloc(sizeof(MedianFinder));
    obj->data = (int*)malloc(sizeof(int) * 100);
    obj->size = 0;
    obj->capacity = 100;
    return obj;
}

void addNum(MedianFinder* obj, int num) {
    if (obj->size == obj->capacity) {
        obj->capacity *= 2;
        obj->data = (int*)realloc(obj->data, sizeof(int) * obj->capacity);
    }
    obj->data[obj->size++] = num;

    for (int i = 0; i < obj->size - 1; i++) {
        for (int j = i + 1; j < obj->size; j++) {
            if (obj->data[i] > obj->data[j]) {
                int temp = obj->data[i];
                obj->data[i] = obj->data[j];
                obj->data[j] = temp;
            }
        }
    }
}

double findMedian(MedianFinder* obj) {
    if (obj->size % 2 == 1) {
        return obj->data[obj->size / 2];
    } else {
        return (obj->data[obj->size / 2] + obj->data[obj->size / 2 - 1]) / 2.0;
    }
}

void medianFinderFree(MedianFinder* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    MedianFinder* medianFinder = medianFinderCreate();
    addNum(medianFinder, 1);
    addNum(medianFinder, 2);
    printf("%.1f\n", findMedian(medianFinder)); // 1.5
    addNum(medianFinder, 3);
    printf("%.1f\n", findMedian(medianFinder)); // 2.0
    addNum(medianFinder, 4);
    printf("%.1f\n", findMedian(medianFinder)); // 2.5
    addNum(medianFinder, 5);
    printf("%.1f\n", findMedian(medianFinder)); // 3.0
    medianFinderFree(medianFinder);
    return 0;
}
```
Created file: Task195.java
Created file: Task195.py
Created file: Task195.cpp
Created file: Task195.c
Task196_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task196, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You have a function printNumber that can be called with an integer parameter and prints it to the console.

For example, calling printNumber(7) prints 7 to the console.
You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads:

Thread A: calls zero() that should only output 0's.
Thread B: calls even() that should only output even numbers.
Thread C: calls odd() that should only output odd numbers.
Modify the given class to output the series "010203040506..." where the length of the series must be 2n.

Implement the ZeroEvenOdd class:

ZeroEvenOdd(int n) Initializes the object with the number n that represents the numbers that should be printed.
void zero(printNumber) Calls printNumber to output one zero.
void even(printNumber) Calls printNumber to output one even number.
void odd(printNumber) Calls printNumber to output one odd number.


Example 1:

Input: n = 2
Output: "0102"
Explanation: There are three threads being fired asynchronously.
One of them calls zero(), the other calls even(), and the last one calls odd().
"0102" is the correct output.
Example 2:

Input: n = 5
Output: "0102030405"


Constraints:

1 <= n <= 1000
```java
import java.util.concurrent.Semaphore;

class Task196 {
    private int n;
    private Semaphore zeroSem = new Semaphore(1);
    private Semaphore evenSem = new Semaphore(0);
    private Semaphore oddSem = new Semaphore(0);

    public Task196(int n) {
        this.n = n;
    }

    public void zero(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            zeroSem.acquire();
            printNumber.accept(0);
            if (i % 2 == 0) {
                evenSem.release();
            } else {
                oddSem.release();
            }
        }
    }

    public void even(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 2; i <= n; i += 2) {
            evenSem.acquire();
            printNumber.accept(i);
            zeroSem.release();
        }
    }

    public void odd(java.util.function.IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i += 2) {
            oddSem.acquire();
            printNumber.accept(i);
            zeroSem.release();
        }
    }

    public static void main(String[] args) {
        Task196 zeroEvenOdd = new Task196(5);

        java.util.function.IntConsumer printNumber = System.out::print;

        Thread threadA = new Thread(() -> {
            try {
                zeroEvenOdd.zero(printNumber);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread threadB = new Thread(() -> {
            try {
                zeroEvenOdd.even(printNumber);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread threadC = new Thread(() -> {
            try {
                zeroEvenOdd.odd(printNumber);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```
```python
import threading

class ZeroEvenOdd:
    def __init__(self, n):
        self.n = n
        self.zero_lock = threading.Semaphore(1)
        self.even_lock = threading.Semaphore(0)
        self.odd_lock = threading.Semaphore(0)

    def zero(self, printNumber):
        for i in range(1, self.n + 1):
            self.zero_lock.acquire()
            printNumber(0)
            if i % 2 == 0:
                self.even_lock.release()
            else:
                self.odd_lock.release()

    def even(self, printNumber):
        for i in range(2, self.n + 1, 2):
            self.even_lock.acquire()
            printNumber(i)
            self.zero_lock.release()

    def odd(self, printNumber):
        for i in range(1, self.n + 1, 2):
            self.odd_lock.acquire()
            printNumber(i)
            self.zero_lock.release()

def printNumber(x):
    print(x, end='')

if __name__ == "__main__":
    n = 5
    zeroEvenOdd = ZeroEvenOdd(n)

    threadA = threading.Thread(target=zeroEvenOdd.zero, args=(printNumber,))
    threadB = threading.Thread(target=zeroEvenOdd.even, args=(printNumber,))
    threadC = threading.Thread(target=zeroEvenOdd.odd, args=(printNumber,))

    threadA.start()
    threadB.start()
    threadC.start()

    threadA.join()
    threadB.join()
    threadC.join()
```
```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <semaphore.h>

class Task196 {
private:
    int n;
    sem_t zeroSem, evenSem, oddSem;

public:
    Task196(int n) : n(n) {
        sem_init(&zeroSem, 0, 1);
        sem_init(&evenSem, 0, 0);
        sem_init(&oddSem, 0, 0);
    }

    void zero(std::function<void(int)> printNumber) {
        for (int i = 1; i <= n; ++i) {
            sem_wait(&zeroSem);
            printNumber(0);
            if (i % 2 == 0) {
                sem_post(&evenSem);
            } else {
                sem_post(&oddSem);
            }
        }
    }

    void even(std::function<void(int)> printNumber) {
        for (int i = 2; i <= n; i += 2) {
            sem_wait(&evenSem);
            printNumber(i);
            sem_post(&zeroSem);
        }
    }

    void odd(std::function<void(int)> printNumber) {
        for (int i = 1; i <= n; i += 2) {
            sem_wait(&oddSem);
            printNumber(i);
            sem_post(&zeroSem);
        }
    }
};

void printNumber(int x) {
    std::cout << x;
}

int main() {
    Task196 zeroEvenOdd(5);

    std::thread threadA(&Task196::zero, &zeroEvenOdd, printNumber);
    std::thread threadB(&Task196::even, &zeroEvenOdd, printNumber);
    std::thread threadC(&Task196::odd, &zeroEvenOdd, printNumber);

    threadA.join();
    threadB.join();
    threadC.join();

    return 0;
}
```
```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

typedef struct {
    int n;
    sem_t zeroSem;
    sem_t evenSem;
    sem_t oddSem;
} ZeroEvenOdd;

void init(ZeroEvenOdd* obj, int n) {
    obj->n = n;
    sem_init(&(obj->zeroSem), 0, 1);
    sem_init(&(obj->evenSem), 0, 0);
    sem_init(&(obj->oddSem), 0, 0);
}

void* zero(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 1; i <= obj->n; ++i) {
        sem_wait(&(obj->zeroSem));
        printf("0");
        if (i % 2 == 0) {
            sem_post(&(obj->evenSem));
        } else {
            sem_post(&(obj->oddSem));
        }
    }
    return NULL;
}

void* even(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 2; i <= obj->n; i += 2) {
        sem_wait(&(obj->evenSem));
        printf("%d", i);
        sem_post(&(obj->zeroSem));
    }
    return NULL;
}

void* odd(void* arg) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*)arg;
    for (int i = 1; i <= obj->n; i += 2) {
        sem_wait(&(obj->oddSem));
        printf("%d", i);
        sem_post(&(obj->zeroSem));
    }
    return NULL;
}

int main() {
    ZeroEvenOdd zeroEvenOdd;
    init(&zeroEvenOdd, 5);

    pthread_t threadA, threadB, threadC;

    pthread_create(&threadA, NULL, zero, &zeroEvenOdd);
    pthread_create(&threadB, NULL, even, &zeroEvenOdd);
    pthread_create(&threadC, NULL, odd, &zeroEvenOdd);

    pthread_join(threadA, NULL);
    pthread_join(threadB, NULL);
    pthread_join(threadC, NULL);

    return 0;
}
```
Created file: Task196.java
Created file: Task196.py
Created file: Task196.cpp
Created file: Task196.c
Task197_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task197, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.

Implement the Solution class:

Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].


Example 1:

Input
["Solution", "randPoint", "randPoint", "randPoint"]
[[1.0, 0.0, 0.0], [], [], []]
Output
[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]

Explanation
Solution solution = new Solution(1.0, 0.0, 0.0);
solution.randPoint(); // return [-0.02493, -0.38077]
solution.randPoint(); // return [0.82314, 0.38945]
solution.randPoint(); // return [0.36572, 0.17248]


Constraints:

0 < radius <= 108
-107 <= x_center, y_center <= 107
At most 3 * 104 calls will be made to randPoint.
```java
import java.util.Random;

class Task197 {
    static class Solution {
        private double radius, x_center, y_center;
        private Random rand;

        public Solution(double radius, double x_center, double y_center) {
            this.radius = radius;
            this.x_center = x_center;
            this.y_center = y_center;
            this.rand = new Random();
        }

        public double[] randPoint() {
            while (true) {
                double x = (rand.nextDouble() * 2 - 1) * radius;
                double y = (rand.nextDouble() * 2 - 1) * radius;
                if (x * x + y * y <= radius * radius) {
                    return new double[]{x_center + x, y_center + y};
                }
            }
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution(1.0, 0.0, 0.0);
        for (int i = 0; i < 5; i++) {
            double[] point = solution.randPoint();
            System.out.printf("[%f, %f]\n", point[0], point[1]);
        }
    }
}
```
```python
import random
import math

class Solution:
    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self) -> [float, float]:
        while True:
            x = random.uniform(-self.radius, self.radius)
            y = random.uniform(-self.radius, self.radius)
            if x*x + y*y <= self.radius*self.radius:
                return [self.x_center + x, self.y_center + y]

if __name__ == "__main__":
    solution = Solution(1.0, 0.0, 0.0)
    for _ in range(5):
        print(solution.randPoint())
```
```cpp
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <ctime>

class Solution {
private:
    double radius, x_center, y_center;

public:
    Solution(double radius, double x_center, double y_center) : radius(radius), x_center(x_center), y_center(y_center) {
        std::srand(std::time(nullptr));
    }

    std::pair<double, double> randPoint() {
        while (true) {
            double x = ((double)std::rand() / RAND_MAX) * 2 * radius - radius;
            double y = ((double)std::rand() / RAND_MAX) * 2 * radius - radius;
            if (x * x + y * y <= radius * radius) {
                return {x_center + x, y_center + y};
            }
        }
    }
};

int main() {
    Solution solution(1.0, 0.0, 0.0);
    for (int i = 0; i < 5; i++) {
        auto point = solution.randPoint();
        std::cout << "[" << point.first << ", " << point.second << "]" << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

typedef struct {
    double radius, x_center, y_center;
} Solution;

Solution* solutionCreate(double radius, double x_center, double y_center) {
    Solution* sol = (Solution*)malloc(sizeof(Solution));
    sol->radius = radius;
    sol->x_center = x_center;
    sol->y_center = y_center;
    return sol;
}

void randPoint(Solution* obj, double* point) {
    while (1) {
        double x = ((double)rand() / RAND_MAX) * 2 * obj->radius - obj->radius;
        double y = ((double)rand() / RAND_MAX) * 2 * obj->radius - obj->radius;
        if (x * x + y * y <= obj->radius * obj->radius) {
            point[0] = obj->x_center + x;
            point[1] = obj->y_center + y;
            return;
        }
    }
}

int main() {
    srand((unsigned int)time(NULL));
    Solution* solution = solutionCreate(1.0, 0.0, 0.0);
    for (int i = 0; i < 5; i++) {
        double point[2];
        randPoint(solution, point);
        printf("[%f, %f]\n", point[0], point[1]);
    }
    free(solution);
    return 0;
}
```
Created file: Task197.java
Created file: Task197.py
Created file: Task197.cpp
Created file: Task197.c
Task198_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task198, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.

Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().



Example 1:

Input: n = 1
Output: [2]
Example 2:

Input: n = 2
Output: [2,8]
Example 3:

Input: n = 3
Output: [3,8,10]


Constraints:

1 <= n <= 105
```java
import java.util.ArrayList;
import java.util.List;

public class Task198 {
    public static int rand7() {
        return 1 + (int)(Math.random() * 7);
    }

    public static int rand10() {
        while (true) {
            int row = rand7();
            int col = rand7();
            int idx = (row - 1) * 7 + col;
            if (idx <= 40) {
                return 1 + (idx - 1) % 10;
            }
        }
    }

    public static List<Integer> testRand10(int n) {
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            results.add(rand10());
        }
        return results;
    }

    public static void main(String[] args) {
        System.out.println(testRand10(1)); // Example output: [2]
        System.out.println(testRand10(2)); // Example output: [2, 8]
        System.out.println(testRand10(3)); // Example output: [3, 8, 10]
        System.out.println(testRand10(5)); // Example output: [2, 3, 10, 1, 7]
        System.out.println(testRand10(10)); // Example output: [5, 8, 9, 6, 1, 7, 10, 4, 2, 3]
    }
}
```
```python
import random

def rand7():
    return random.randint(1, 7)

def rand10():
    while True:
        row = rand7()
        col = rand7()
        idx = (row - 1) * 7 + col
        if idx <= 40:
            return 1 + (idx - 1) % 10

def test_rand10(n):
    results = []
    for _ in range(n):
        results.append(rand10())
    return results

if __name__ == "__main__":
    print(test_rand10(1))  # Example output: [2]
    print(test_rand10(2))  # Example output: [2, 8]
    print(test_rand10(3))  # Example output: [3, 8, 10]
    print(test_rand10(5))  # Example output: [2, 3, 10, 1, 7]
    print(test_rand10(10)) # Example output: [5, 8, 9, 6, 1, 7, 10, 4, 2, 3]
```
```cpp
#include <iostream>
#include <vector>
#include <cstdlib>

class Task198 {
public:
    static int rand7() {
        return 1 + std::rand() % 7;
    }

    static int rand10() {
        while (true) {
            int row = rand7();
            int col = rand7();
            int idx = (row - 1) * 7 + col;
            if (idx <= 40) {
                return 1 + (idx - 1) % 10;
            }
        }
    }

    static std::vector<int> testRand10(int n) {
        std::vector<int> results;
        for (int i = 0; i < n; ++i) {
            results.push_back(rand10());
        }
        return results;
    }
};

int main() {
    auto printResults = [](const std::vector<int>& results) {
        for (int num : results) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    };

    printResults(Task198::testRand10(1)); // Example output: [2]
    printResults(Task198::testRand10(2)); // Example output: [2, 8]
    printResults(Task198::testRand10(3)); // Example output: [3, 8, 10]
    printResults(Task198::testRand10(5)); // Example output: [2, 3, 10, 1, 7]
    printResults(Task198::testRand10(10)); // Example output: [5, 8, 9, 6, 1, 7, 10, 4, 2, 3]

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int rand7() {
    return 1 + rand() % 7;
}

int rand10() {
    while (1) {
        int row = rand7();
        int col = rand7();
        int idx = (row - 1) * 7 + col;
        if (idx <= 40) {
            return 1 + (idx - 1) % 10;
        }
    }
}

void testRand10(int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", rand10());
    }
    printf("\n");
}

int main() {
    srand(time(NULL));

    testRand10(1); // Example output: [2]
    testRand10(2); // Example output: [2, 8]
    testRand10(3); // Example output: [3, 8, 10]
    testRand10(5); // Example output: [2, 3, 10, 1, 7]
    testRand10(10); // Example output: [5, 8, 9, 6, 1, 7, 10, 4, 2, 3]

    return 0;
}
```
Created file: Task198.java
Created file: Task198.py
Created file: Task198.cpp
Created file: Task198.c
Task199_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task199, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that Implement a clock that handles times without dates. You should be able to add and subtract minutes to it. Two clocks that represent the same time should be equal to each other.
```java
import java.util.Objects;

public class Task199 {

    private int hours;
    private int minutes;

    public Task199(int hours, int minutes) {
        this.hours = (hours + (minutes / 60)) % 24;
        this.minutes = minutes % 60;
    }

    public void addMinutes(int minutesToAdd) {
        int totalMinutes = this.hours * 60 + this.minutes + minutesToAdd;
        this.hours = (totalMinutes / 60) % 24;
        this.minutes = totalMinutes % 60;
    }

    public void subtractMinutes(int minutesToSubtract) {
        int totalMinutes = this.hours * 60 + this.minutes - minutesToSubtract;
        this.hours = ((totalMinutes / 60) % 24 + 24) % 24;
        this.minutes = ((totalMinutes % 60) + 60) % 60;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task199 task199 = (Task199) o;
        return hours == task199.hours && minutes == task199.minutes;
    }

    @Override
    public int hashCode() {
        return Objects.hash(hours, minutes);
    }

    @Override
    public String toString() {
        return String.format("%02d:%02d", hours, minutes);
    }

    public static void main(String[] args) {
        Task199 clock1 = new Task199(14, 30);
        Task199 clock2 = new Task199(14, 30);
        Task199 clock3 = new Task199(10, 0);
        Task199 clock4 = new Task199(23, 59);
        Task199 clock5 = new Task199(0, 0);

        clock3.addMinutes(90);
        clock4.addMinutes(2);
        clock5.subtractMinutes(1);

        System.out.println(clock1.equals(clock2)); // true
        System.out.println(clock1.equals(clock3)); // false
        System.out.println(clock3); // 11:30
        System.out.println(clock4); // 00:01
        System.out.println(clock5); // 23:59
    }
}
```
```python
class Clock:
    def __init__(self, hours, minutes):
        self.hours = (hours + (minutes // 60)) % 24
        self.minutes = minutes % 60

    def add_minutes(self, minutes_to_add):
        total_minutes = self.hours * 60 + self.minutes + minutes_to_add
        self.hours = (total_minutes // 60) % 24
        self.minutes = total_minutes % 60

    def subtract_minutes(self, minutes_to_subtract):
        total_minutes = self.hours * 60 + self.minutes - minutes_to_subtract
        self.hours = ((total_minutes // 60) % 24 + 24) % 24
        self.minutes = ((total_minutes % 60) + 60) % 60

    def __eq__(self, other):
        return self.hours == other.hours and self.minutes == other.minutes

    def __str__(self):
        return f"{self.hours:02}:{self.minutes:02}"

if __name__ == "__main__":
    clock1 = Clock(14, 30)
    clock2 = Clock(14, 30)
    clock3 = Clock(10, 0)
    clock4 = Clock(23, 59)
    clock5 = Clock(0, 0)

    clock3.add_minutes(90)
    clock4.add_minutes(2)
    clock5.subtract_minutes(1)

    print(clock1 == clock2)  # True
    print(clock1 == clock3)  # False
    print(clock3)            # 11:30
    print(clock4)            # 00:01
    print(clock5)            # 23:59
```
```cpp
#include <iostream>
#include <iomanip>

class Clock {
private:
    int hours;
    int minutes;

public:
    Clock(int hours, int minutes) {
        this->hours = (hours + (minutes / 60)) % 24;
        this->minutes = minutes % 60;
    }

    void addMinutes(int minutesToAdd) {
        int totalMinutes = this->hours * 60 + this->minutes + minutesToAdd;
        this->hours = (totalMinutes / 60) % 24;
        this->minutes = totalMinutes % 60;
    }

    void subtractMinutes(int minutesToSubtract) {
        int totalMinutes = this->hours * 60 + this->minutes - minutesToSubtract;
        this->hours = ((totalMinutes / 60) % 24 + 24) % 24;
        this->minutes = ((totalMinutes % 60) + 60) % 60;
    }

    bool operator==(const Clock& other) const {
        return hours == other.hours && minutes == other.minutes;
    }

    friend std::ostream& operator<<(std::ostream& os, const Clock& clock) {
        os << std::setw(2) << std::setfill('0') << clock.hours << ":"
           << std::setw(2) << std::setfill('0') << clock.minutes;
        return os;
    }
};

int main() {
    Clock clock1(14, 30);
    Clock clock2(14, 30);
    Clock clock3(10, 0);
    Clock clock4(23, 59);
    Clock clock5(0, 0);

    clock3.addMinutes(90);
    clock4.addMinutes(2);
    clock5.subtractMinutes(1);

    std::cout << (clock1 == clock2) << std::endl; // 1 (true)
    std::cout << (clock1 == clock3) << std::endl; // 0 (false)
    std::cout << clock3 << std::endl;             // 11:30
    std::cout << clock4 << std::endl;             // 00:01
    std::cout << clock5 << std::endl;             // 23:59

    return 0;
}
```
```c
#include <stdio.h>

typedef struct {
    int hours;
    int minutes;
} Clock;

Clock createClock(int hours, int minutes) {
    Clock clock;
    clock.hours = (hours + (minutes / 60)) % 24;
    clock.minutes = minutes % 60;
    return clock;
}

void addMinutes(Clock* clock, int minutesToAdd) {
    int totalMinutes = clock->hours * 60 + clock->minutes + minutesToAdd;
    clock->hours = (totalMinutes / 60) % 24;
    clock->minutes = totalMinutes % 60;
}

void subtractMinutes(Clock* clock, int minutesToSubtract) {
    int totalMinutes = clock->hours * 60 + clock->minutes - minutesToSubtract;
    clock->hours = ((totalMinutes / 60) % 24 + 24) % 24;
    clock->minutes = ((totalMinutes % 60) + 60) % 60;
}

int equals(Clock* clock1, Clock* clock2) {
    return clock1->hours == clock2->hours && clock1->minutes == clock2->minutes;
}

void printClock(Clock* clock) {
    printf("%02d:%02d\n", clock->hours, clock->minutes);
}

int main() {
    Clock clock1 = createClock(14, 30);
    Clock clock2 = createClock(14, 30);
    Clock clock3 = createClock(10, 0);
    Clock clock4 = createClock(23, 59);
    Clock clock5 = createClock(0, 0);

    addMinutes(&clock3, 90);
    addMinutes(&clock4, 2);
    subtractMinutes(&clock5, 1);

    printf("%d\n", equals(&clock1, &clock2)); // 1 (true)
    printf("%d\n", equals(&clock1, &clock3)); // 0 (false)
    printClock(&clock3);                      // 11:30
    printClock(&clock4);                      // 00:01
    printClock(&clock5);                      // 23:59

    return 0;
}
```
Created file: Task199.java
Created file: Task199.py
Created file: Task199.cpp
Created file: Task199.c
All files processed.

Process finished with exit code 0


D:\Programs\Python312\python.exe D:\sourceCode\PhD\paper2\code_generation\main_ZeroShot.py
Task0_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task0, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You have been tasked with developing a program that processes large files concurrently. The program should allow multiple threads to access and process the files simultaneously, while ensuring data integrity and avoiding deadlocks.
Question:
Write a program that implements a concurrent file processing system with the following requirements:
The program should allow multiple threads to access and process files in a shared directory.
Each file should be processed by only one thread at a time to maintain data integrity.
```java
import java.io.*;
import java.nio.file.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class Task0 {
    private static final String DIRECTORY_PATH = "shared_directory"; // replace with your directory
    private static final ConcurrentHashMap<String, ReentrantLock> fileLocks = new ConcurrentHashMap<>();

    public static void processFileConcurrently(String fileName) {
        ReentrantLock lock = fileLocks.computeIfAbsent(fileName, k -> new ReentrantLock());
        lock.lock();
        try {
            // Simulate file processing
            System.out.println("Processing file: " + fileName + " by " + Thread.currentThread().getName());
            Thread.sleep(1000); // simulate time taken to process
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(Paths.get(DIRECTORY_PATH))) {
            for (Path path : directoryStream) {
                String fileName = path.getFileName().toString();
                executor.submit(() -> processFileConcurrently(fileName));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```
```python
import os
import threading
from concurrent.futures import ThreadPoolExecutor

directory_path = 'shared_directory' # replace with your directory
file_locks = {}
file_locks_lock = threading.Lock()

def process_file_concurrently(file_name):
    lock = None
    with file_locks_lock:
        if file_name not in file_locks:
            file_locks[file_name] = threading.Lock()
        lock = file_locks[file_name]

    with lock:
        # Simulate file processing
        print(f"Processing file: {file_name} by {threading.current_thread().name}")
        threading.Event().wait(1) # simulate time taken to process

def main():
    with ThreadPoolExecutor(max_workers=5) as executor:
        for file_name in os.listdir(directory_path):
            if os.path.isfile(os.path.join(directory_path, file_name)):
                executor.submit(process_file_concurrently, file_name)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <filesystem>
#include <thread>
#include <mutex>
#include <unordered_map>
#include <vector>

namespace fs = std::filesystem;
std::unordered_map<std::string, std::mutex> file_locks;
std::mutex map_lock;

void processFileConcurrently(const std::string& file_name) {
    std::mutex* lock;
    {
        std::lock_guard<std::mutex> guard(map_lock);
        lock = &file_locks[file_name];
    }
    std::lock_guard<std::mutex> file_guard(*lock);

    // Simulate file processing
    std::cout << "Processing file: " << file_name << " by " << std::this_thread::get_id() << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1)); // simulate time taken to process
}

int main() {
    std::string directory_path = "shared_directory"; // replace with your directory
    std::vector<std::thread> threads;

    for (const auto& entry : fs::directory_iterator(directory_path)) {
        if (fs::is_regular_file(entry)) {
            threads.emplace_back(processFileConcurrently, entry.path().filename().string());
        }
    }

    for (auto& t : threads) {
        t.join();
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

#define DIRECTORY_PATH "shared_directory" // replace with your directory
#define MAX_THREADS 5

typedef struct {
    char file_name[256];
    pthread_mutex_t *lock;
} ThreadData;

pthread_mutex_t file_locks_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t file_locks[256]; // assuming a maximum of 256 files

void* process_file_concurrently(void* arg) {
    ThreadData *data = (ThreadData*)arg;

    pthread_mutex_lock(data->lock);
    printf("Processing file: %s by thread %lu\n", data->file_name, pthread_self());
    sleep(1); // simulate time taken to process
    pthread_mutex_unlock(data->lock);

    free(data);
    return NULL;
}

int main() {
    DIR *d;
    struct dirent *dir;
    pthread_t threads[MAX_THREADS];
    int thread_count = 0;

    d = opendir(DIRECTORY_PATH);
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            if (dir->d_type == DT_REG) {
                ThreadData *data = (ThreadData*)malloc(sizeof(ThreadData));
                strcpy(data->file_name, dir->d_name);
                pthread_mutex_lock(&file_locks_lock);
                data->lock = &file_locks[thread_count];
                pthread_mutex_unlock(&file_locks_lock);

                pthread_create(&threads[thread_count], NULL, process_file_concurrently, data);
                thread_count++;

                if (thread_count >= MAX_THREADS) {
                    for (int i = 0; i < thread_count; i++) {
                        pthread_join(threads[i], NULL);
                    }
                    thread_count = 0;
                }
            }
        }
        closedir(d);
    }

    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
```
Created file: Task0.java
Created file: Task0.py
Created file: Task0.cpp
Created file: Task0.c
Task1_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task1, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
There is a bus moving in the city which takes and drops some people at each bus stop.

You are provided with a list (or array) of integer pairs. Elements of each pair represent the number of people that get on the bus (the first item) and the number of people that get off the bus (the second item) at a bus stop.

Your task is to return the number of people who are still on the bus after the last bus stop (after the last array). Even though it is the last bus stop, the bus might not be empty and some people might still be inside the bus, they are probably sleeping there :D

Take a look on the test cases.

Please keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the returned integer can't be negative.

The second value in the first pair in the array is 0, since the bus is empty in the first bus stop.
```java
public class Task1 {
    public static int peopleOnBus(int[][] stops) {
        int peopleOnBus = 0;
        for (int[] stop : stops) {
            if (stop[0] < 0 || stop[1] < 0) throw new IllegalArgumentException("Number of people cannot be negative");
            peopleOnBus += stop[0] - stop[1];
            if (peopleOnBus < 0) throw new IllegalStateException("People on bus cannot be negative");
        }
        return peopleOnBus;
    }

    public static void main(String[] args) {
        int[][] test1 = {{3, 0}, {9, 1}, {4, 10}, {12, 2}, {6, 1}, {7, 10}};
        int[][] test2 = {{10, 0}, {3, 5}, {5, 8}};
        int[][] test3 = {{3, 0}, {3, 3}, {5, 1}, {2, 2}};
        int[][] test4 = {{10, 0}, {3, 5}, {8, 4}};
        int[][] test5 = {{0, 0}, {0, 0}, {0, 0}};

        System.out.println(peopleOnBus(test1)); // 17
        System.out.println(peopleOnBus(test2)); // 5
        System.out.println(peopleOnBus(test3)); // 7
        System.out.println(peopleOnBus(test4)); // 12
        System.out.println(peopleOnBus(test5)); // 0
    }
}
```
```python
def people_on_bus(stops):
    people_on_bus = 0
    for stop in stops:
        if stop[0] < 0 or stop[1] < 0:
            raise ValueError("Number of people cannot be negative")
        people_on_bus += stop[0] - stop[1]
        if people_on_bus < 0:
            raise ValueError("People on bus cannot be negative")
    return people_on_bus

if __name__ == "__main__":
    test1 = [(3, 0), (9, 1), (4, 10), (12, 2), (6, 1), (7, 10)]
    test2 = [(10, 0), (3, 5), (5, 8)]
    test3 = [(3, 0), (3, 3), (5, 1), (2, 2)]
    test4 = [(10, 0), (3, 5), (8, 4)]
    test5 = [(0, 0), (0, 0), (0, 0)]

    print(people_on_bus(test1)) # 17
    print(people_on_bus(test2)) # 5
    print(people_on_bus(test3)) # 7
    print(people_on_bus(test4)) # 12
    print(people_on_bus(test5)) # 0
```
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

class Task1 {
public:
    static int peopleOnBus(const std::vector<std::pair<int, int>>& stops) {
        int peopleOnBus = 0;
        for (const auto& stop : stops) {
            if (stop.first < 0 || stop.second < 0) throw std::invalid_argument("Number of people cannot be negative");
            peopleOnBus += stop.first - stop.second;
            if (peopleOnBus < 0) throw std::logic_error("People on bus cannot be negative");
        }
        return peopleOnBus;
    }
};

int main() {
    std::vector<std::pair<int, int>> test1 = {{3, 0}, {9, 1}, {4, 10}, {12, 2}, {6, 1}, {7, 10}};
    std::vector<std::pair<int, int>> test2 = {{10, 0}, {3, 5}, {5, 8}};
    std::vector<std::pair<int, int>> test3 = {{3, 0}, {3, 3}, {5, 1}, {2, 2}};
    std::vector<std::pair<int, int>> test4 = {{10, 0}, {3, 5}, {8, 4}};
    std::vector<std::pair<int, int>> test5 = {{0, 0}, {0, 0}, {0, 0}};

    std::cout << Task1::peopleOnBus(test1) << std::endl; // 17
    std::cout << Task1::peopleOnBus(test2) << std::endl; // 5
    std::cout << Task1::peopleOnBus(test3) << std::endl; // 7
    std::cout << Task1::peopleOnBus(test4) << std::endl; // 12
    std::cout << Task1::peopleOnBus(test5) << std::endl; // 0

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int peopleOnBus(int stops[][2], size_t length) {
    int peopleOnBus = 0;
    for (size_t i = 0; i < length; ++i) {
        if (stops[i][0] < 0 || stops[i][1] < 0) {
            fprintf(stderr, "Number of people cannot be negative\n");
            exit(EXIT_FAILURE);
        }
        peopleOnBus += stops[i][0] - stops[i][1];
        if (peopleOnBus < 0) {
            fprintf(stderr, "People on bus cannot be negative\n");
            exit(EXIT_FAILURE);
        }
    }
    return peopleOnBus;
}

int main() {
    int test1[][2] = {{3, 0}, {9, 1}, {4, 10}, {12, 2}, {6, 1}, {7, 10}};
    int test2[][2] = {{10, 0}, {3, 5}, {5, 8}};
    int test3[][2] = {{3, 0}, {3, 3}, {5, 1}, {2, 2}};
    int test4[][2] = {{10, 0}, {3, 5}, {8, 4}};
    int test5[][2] = {{0, 0}, {0, 0}, {0, 0}};

    printf("%d\n", peopleOnBus(test1, sizeof(test1) / sizeof(test1[0]))); // 17
    printf("%d\n", peopleOnBus(test2, sizeof(test2) / sizeof(test2[0]))); // 5
    printf("%d\n", peopleOnBus(test3, sizeof(test3) / sizeof(test3[0]))); // 7
    printf("%d\n", peopleOnBus(test4, sizeof(test4) / sizeof(test4[0]))); // 12
    printf("%d\n", peopleOnBus(test5, sizeof(test5) / sizeof(test5[0]))); // 0

    return 0;
}
```
Created file: Task1.java
Created file: Task1.py
Created file: Task1.cpp
Created file: Task1.c
Task2_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task2, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number. Example
Kata.createPhoneNumber(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}) // => returns "(123) 456-7890"

```java
public class Task2 {
    public static String createPhoneNumber(int[] numbers) {
        if (numbers == null || numbers.length != 10) {
            throw new IllegalArgumentException("Input array must contain exactly 10 integers.");
        }
        for (int number : numbers) {
            if (number < 0 || number > 9) {
                throw new IllegalArgumentException("All integers must be between 0 and 9.");
            }
        }
        return String.format("(%d%d%d) %d%d%d-%d%d%d%d",
                numbers[0], numbers[1], numbers[2],
                numbers[3], numbers[4], numbers[5],
                numbers[6], numbers[7], numbers[8], numbers[9]);
    }

    public static void main(String[] args) {
        System.out.println(createPhoneNumber(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}));
        System.out.println(createPhoneNumber(new int[]{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}));
        System.out.println(createPhoneNumber(new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}));
        System.out.println(createPhoneNumber(new int[]{5, 5, 5, 5, 5, 5, 5, 5, 5, 5}));
        System.out.println(createPhoneNumber(new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}));
    }
}
```
```python
def create_phone_number(numbers):
    if numbers is None or len(numbers) != 10:
        raise ValueError("Input array must contain exactly 10 integers.")
    if any(number < 0 or number > 9 for number in numbers):
        raise ValueError("All integers must be between 0 and 9.")
    return "({}{}{}) {}{}{}-{}{}{}{}".format(*numbers)

if __name__ == "__main__":
    print(create_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]))
    print(create_phone_number([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
    print(create_phone_number([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))
    print(create_phone_number([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]))
    print(create_phone_number([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))
```
```cpp
#include <iostream>
#include <string>
#include <stdexcept>

std::string createPhoneNumber(int numbers[10]) {
    for (int i = 0; i < 10; i++) {
        if (numbers[i] < 0 || numbers[i] > 9) {
            throw std::invalid_argument("All integers must be between 0 and 9.");
        }
    }
    char buffer[15];
    snprintf(buffer, sizeof(buffer), "(%d%d%d) %d%d%d-%d%d%d%d",
             numbers[0], numbers[1], numbers[2],
             numbers[3], numbers[4], numbers[5],
             numbers[6], numbers[7], numbers[8], numbers[9]);
    return std::string(buffer);
}

int main() {
    try {
        std::cout << createPhoneNumber(new int[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}) << std::endl;
        std::cout << createPhoneNumber(new int[10]{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}) << std::endl;
        std::cout << createPhoneNumber(new int[10]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}) << std::endl;
        std::cout << createPhoneNumber(new int[10]{5, 5, 5, 5, 5, 5, 5, 5, 5, 5}) << std::endl;
        std::cout << createPhoneNumber(new int[10]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}) << std::endl;
    } catch (const std::exception &e) {
        std::cerr << e.what() << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void createPhoneNumber(int numbers[10], char *output) {
    for (int i = 0; i < 10; i++) {
        if (numbers[i] < 0 || numbers[i] > 9) {
            fprintf(stderr, "All integers must be between 0 and 9.\n");
            exit(EXIT_FAILURE);
        }
    }
    sprintf(output, "(%d%d%d) %d%d%d-%d%d%d%d",
            numbers[0], numbers[1], numbers[2],
            numbers[3], numbers[4], numbers[5],
            numbers[6], numbers[7], numbers[8], numbers[9]);
}

int main() {
    char output[15];
    createPhoneNumber((int[]){1, 2, 3, 4, 5, 6, 7, 8, 9, 0}, output);
    printf("%s\n", output);
    createPhoneNumber((int[]){9, 8, 7, 6, 5, 4, 3, 2, 1, 0}, output);
    printf("%s\n", output);
    createPhoneNumber((int[]){0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, output);
    printf("%s\n", output);
    createPhoneNumber((int[]){5, 5, 5, 5, 5, 5, 5, 5, 5, 5}, output);
    printf("%s\n", output);
    createPhoneNumber((int[]){1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, output);
    printf("%s\n", output);
    return 0;
}
```
Created file: Task2.java
Created file: Task2.py
Created file: Task2.cpp
Created file: Task2.c
Task3_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task3, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program to solve the following: A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram, because it uses the letters A-Z at least once (case is irrelevant).

Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation.
```java
import java.util.HashSet;
import java.util.Set;

public class Task3 {
    public static boolean isPangram(String input) {
        if (input == null) {
            return false;
        }
        Set<Character> alphabetSet = new HashSet<>();
        for (char c : input.toLowerCase().toCharArray()) {
            if (Character.isLetter(c)) {
                alphabetSet.add(c);
            }
        }
        return alphabetSet.size() == 26;
    }

    public static void main(String[] args) {
        System.out.println(isPangram("The quick brown fox jumps over the lazy dog")); // true
        System.out.println(isPangram("Hello World")); // false
        System.out.println(isPangram("Pack my box with five dozen liquor jugs")); // true
        System.out.println(isPangram("")); // false
        System.out.println(isPangram("Cwm fjord bank glyphs vext quiz")); // true
    }
}
```
```python
def is_pangram(input_str):
    if input_str is None:
        return False
    alphabet_set = set()
    for char in input_str.lower():
        if char.isalpha():
            alphabet_set.add(char)
    return len(alphabet_set) == 26

if __name__ == "__main__":
    print(is_pangram("The quick brown fox jumps over the lazy dog"))  # True
    print(is_pangram("Hello World"))  # False
    print(is_pangram("Pack my box with five dozen liquor jugs"))  # True
    print(is_pangram(""))  # False
    print(is_pangram("Cwm fjord bank glyphs vext quiz"))  # True
```
```cpp
#include <iostream>
#include <unordered_set>
#include <cctype>

class Task3 {
public:
    static bool isPangram(const std::string &input) {
        if (input.empty()) {
            return false;
        }
        std::unordered_set<char> alphabetSet;
        for (char c : input) {
            if (std::isalpha(c)) {
                alphabetSet.insert(std::tolower(c));
            }
        }
        return alphabetSet.size() == 26;
    }
};

int main() {
    std::cout << std::boolalpha;
    std::cout << Task3::isPangram("The quick brown fox jumps over the lazy dog") << std::endl; // true
    std::cout << Task3::isPangram("Hello World") << std::endl; // false
    std::cout << Task3::isPangram("Pack my box with five dozen liquor jugs") << std::endl; // true
    std::cout << Task3::isPangram("") << std::endl; // false
    std::cout << Task3::isPangram("Cwm fjord bank glyphs vext quiz") << std::endl; // true
    return 0;
}
```
```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdbool.h>

bool isPangram(const char *input) {
    if (input == NULL) {
        return false;
    }
    bool alphabetSet[26] = { false };
    int count = 0;
    for (int i = 0; input[i] != '\0'; i++) {
        if (isalpha(input[i])) {
            int index = tolower(input[i]) - 'a';
            if (!alphabetSet[index]) {
                alphabetSet[index] = true;
                count++;
            }
        }
    }
    return count == 26;
}

int main() {
    printf("%d\n", isPangram("The quick brown fox jumps over the lazy dog")); // 1 (true)
    printf("%d\n", isPangram("Hello World")); // 0 (false)
    printf("%d\n", isPangram("Pack my box with five dozen liquor jugs")); // 1 (true)
    printf("%d\n", isPangram("")); // 0 (false)
    printf("%d\n", isPangram("Cwm fjord bank glyphs vext quiz")); // 1 (true)
    return 0;
}
```
Created file: Task3.java
Created file: Task3.py
Created file: Task3.cpp
Created file: Task3.c
Task4_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task4, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program to solve the following: An isogram is a word that has no repeating letters, consecutive or non-consecutive. Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.

Example: (Input --> Output)

"Dermatoglyphics" --> true
"aba" --> false
"moOse" --> false (ignore letter case)
```java
import java.util.HashSet;

public class Task4 {

    public static boolean isIsogram(String input) {
        if (input == null) {
            return false;
        }
        input = input.toLowerCase();
        HashSet<Character> seen = new HashSet<>();
        for (char c : input.toCharArray()) {
            if (seen.contains(c)) {
                return false;
            }
            seen.add(c);
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(isIsogram("Dermatoglyphics")); // true
        System.out.println(isIsogram("aba")); // false
        System.out.println(isIsogram("moOse")); // false
        System.out.println(isIsogram("")); // true
        System.out.println(isIsogram("isogram")); // true
    }
}
```
```python
def is_isogram(input):
    if input is None:
        return False
    input = input.lower()
    seen = set()
    for char in input:
        if char in seen:
            return False
        seen.add(char)
    return True

if __name__ == "__main__":
    print(is_isogram("Dermatoglyphics"))  # true
    print(is_isogram("aba"))  # false
    print(is_isogram("moOse"))  # false
    print(is_isogram(""))  # true
    print(is_isogram("isogram"))  # true
```
```cpp
#include <iostream>
#include <unordered_set>
#include <string>
#include <cctype>

bool isIsogram(const std::string& input) {
    std::unordered_set<char> seen;
    for (char c : input) {
        c = std::tolower(c);
        if (seen.find(c) != seen.end()) {
            return false;
        }
        seen.insert(c);
    }
    return true;
}

int main() {
    std::cout << isIsogram("Dermatoglyphics") << std::endl; // true
    std::cout << isIsogram("aba") << std::endl; // false
    std::cout << isIsogram("moOse") << std::endl; // false
    std::cout << isIsogram("") << std::endl; // true
    std::cout << isIsogram("isogram") << std::endl; // true
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

bool isIsogram(const char* input) {
    int seen[26] = {0};
    for (int i = 0; input[i] != '\0'; i++) {
        char c = tolower(input[i]);
        if (seen[c - 'a'] > 0) {
            return false;
        }
        seen[c - 'a']++;
    }
    return true;
}

int main() {
    printf("%d\n", isIsogram("Dermatoglyphics")); // true
    printf("%d\n", isIsogram("aba")); // false
    printf("%d\n", isIsogram("moOse")); // false
    printf("%d\n", isIsogram("")); // true
    printf("%d\n", isIsogram("isogram")); // true
    return 0;
}
```
Created file: Task4.java
Created file: Task4.py
Created file: Task4.cpp
Created file: Task4.c
Task5_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task5, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit.

For example (Input --> Output):

39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit, there are 3 multiplications)
999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2, there are 4 multiplications)
4 --> 0 (because 4 is already a one-digit number, there is no multiplication)
```java
public class Task5 {
    public static int persistence(int num) {
        if (num < 10) return 0;
        int count = 0;
        while (num >= 10) {
            int product = 1;
            while (num > 0) {
                product *= num % 10;
                num /= 10;
            }
            num = product;
            count++;
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(persistence(39));  // Output: 3
        System.out.println(persistence(999)); // Output: 4
        System.out.println(persistence(4));   // Output: 0
        System.out.println(persistence(25));  // Output: 2
        System.out.println(persistence(77));  // Output: 4
    }
}
```
```python
def persistence(num):
    if num < 10:
        return 0
    count = 0
    while num >= 10:
        product = 1
        while num > 0:
            product *= num % 10
            num //= 10
        num = product
        count += 1
    return count

if __name__ == "__main__":
    print(persistence(39))  # Output: 3
    print(persistence(999)) # Output: 4
    print(persistence(4))   # Output: 0
    print(persistence(25))  # Output: 2
    print(persistence(77))  # Output: 4
```
```cpp
#include <iostream>
using namespace std;

int persistence(int num) {
    if (num < 10) return 0;
    int count = 0;
    while (num >= 10) {
        int product = 1;
        while (num > 0) {
            product *= num % 10;
            num /= 10;
        }
        num = product;
        count++;
    }
    return count;
}

int main() {
    cout << persistence(39) << endl;  // Output: 3
    cout << persistence(999) << endl; // Output: 4
    cout << persistence(4) << endl;   // Output: 0
    cout << persistence(25) << endl;  // Output: 2
    cout << persistence(77) << endl;  // Output: 4
    return 0;
}
```
```c
#include <stdio.h>

int persistence(int num) {
    if (num < 10) return 0;
    int count = 0;
    while (num >= 10) {
        int product = 1;
        while (num > 0) {
            product *= num % 10;
            num /= 10;
        }
        num = product;
        count++;
    }
    return count;
}

int main() {
    printf("%d\n", persistence(39));  // Output: 3
    printf("%d\n", persistence(999)); // Output: 4
    printf("%d\n", persistence(4));   // Output: 0
    printf("%d\n", persistence(25));  // Output: 2
    printf("%d\n", persistence(77));  // Output: 4
    return 0;
}
```
Created file: Task5.java
Created file: Task5.py
Created file: Task5.cpp
Created file: Task5.c
Task6_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task6, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
There is an array with some numbers. All numbers are equal except for one. Try to find it!

Kata.findUniq(new double[]{ 1, 1, 1, 2, 1, 1 }); // => 2
Kata.findUniq(new double[]{ 0, 0, 0.55, 0, 0 }); // => 0.55
Its guaranteed that array contains at least 3 numbers.
```java
public class Task6 {
    public static double findUniq(double[] arr) {
        if (arr[0] != arr[1] && arr[0] != arr[2]) return arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] != arr[0]) return arr[i];
        }
        return -1; // This should never be reached if input guarantees are met
    }

    public static void main(String[] args) {
        System.out.println(findUniq(new double[]{1, 1, 1, 2, 1, 1})); // 2.0
        System.out.println(findUniq(new double[]{0, 0, 0.55, 0, 0})); // 0.55
        System.out.println(findUniq(new double[]{3, 3, 2, 3, 3})); // 2.0
        System.out.println(findUniq(new double[]{5, 5, 5, 5, 4})); // 4.0
        System.out.println(findUniq(new double[]{9, 9, 9, 9, 8, 9})); // 8.0
    }
}
```
```python
def find_uniq(arr):
    if arr[0] != arr[1] and arr[0] != arr[2]:
        return arr[0]
    for num in arr:
        if num != arr[0]:
            return num
    return -1  # This should never be reached if input guarantees are met

if __name__ == "__main__":
    print(find_uniq([1, 1, 1, 2, 1, 1]))  # 2
    print(find_uniq([0, 0, 0.55, 0, 0]))  # 0.55
    print(find_uniq([3, 3, 2, 3, 3]))  # 2
    print(find_uniq([5, 5, 5, 5, 4]))  # 4
    print(find_uniq([9, 9, 9, 9, 8, 9]))  # 8
```
```cpp
#include <iostream>
#include <vector>

class Task6 {
public:
    static double findUniq(const std::vector<double>& arr) {
        if (arr[0] != arr[1] && arr[0] != arr[2]) return arr[0];
        for (size_t i = 1; i < arr.size(); ++i) {
            if (arr[i] != arr[0]) return arr[i];
        }
        return -1; // This should never be reached if input guarantees are met
    }
};

int main() {
    std::cout << Task6::findUniq({1, 1, 1, 2, 1, 1}) << std::endl; // 2
    std::cout << Task6::findUniq({0, 0, 0.55, 0, 0}) << std::endl; // 0.55
    std::cout << Task6::findUniq({3, 3, 2, 3, 3}) << std::endl; // 2
    std::cout << Task6::findUniq({5, 5, 5, 5, 4}) << std::endl; // 4
    std::cout << Task6::findUniq({9, 9, 9, 9, 8, 9}) << std::endl; // 8
    return 0;
}
```
```c
#include <stdio.h>

double findUniq(const double* arr, int length) {
    if (arr[0] != arr[1] && arr[0] != arr[2]) return arr[0];
    for (int i = 1; i < length; i++) {
        if (arr[i] != arr[0]) return arr[i];
    }
    return -1; // This should never be reached if input guarantees are met
}

int main() {
    double arr1[] = {1, 1, 1, 2, 1, 1};
    double arr2[] = {0, 0, 0.55, 0, 0};
    double arr3[] = {3, 3, 2, 3, 3};
    double arr4[] = {5, 5, 5, 5, 4};
    double arr5[] = {9, 9, 9, 9, 8, 9};

    printf("%lf\n", findUniq(arr1, 6)); // 2
    printf("%lf\n", findUniq(arr2, 5)); // 0.55
    printf("%lf\n", findUniq(arr3, 5)); // 2
    printf("%lf\n", findUniq(arr4, 5)); // 4
    printf("%lf\n", findUniq(arr5, 6)); // 8

    return 0;
}
```
Created file: Task6.java
Created file: Task6.py
Created file: Task6.cpp
Created file: Task6.c
Task7_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task7, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program in for a client-server architecture for an a chat system. The client component captures the user's username and password, constructs a login request, and sends it to the server. It prompts the user for credentials, builds the request, and prepares it for transmission.

On the server side, user authentication happen using the username and passwords against stored on filesystem. The server processes requests from the client by parsing messages, executing actions, and generating responses.
```java
public class Task7 {
    public static void main(String[] args) {
        // Main method with 5 test cases
        System.out.println("Test case 1: " + Client.sendLoginRequest("user1", "password1"));
        System.out.println("Test case 2: " + Client.sendLoginRequest("user2", "password2"));
        System.out.println("Test case 3: " + Client.sendLoginRequest("user3", "wrongpassword"));
        System.out.println("Test case 4: " + Client.sendLoginRequest("user4", "password4"));
        System.out.println("Test case 5: " + Client.sendLoginRequest("user5", "password5"));
    }
}

class Client {
    public static String sendLoginRequest(String username, String password) {
        return Server.processLoginRequest(username, password);
    }
}

class Server {
    public static String processLoginRequest(String username, String password) {
        // Simulate checking against stored credentials
        if ("user1".equals(username) && "password1".equals(password)) {
            return "Login successful for user1";
        } else if ("user2".equals(username) && "password2".equals(password)) {
            return "Login successful for user2";
        } else if ("user4".equals(username) && "password4".equals(password)) {
            return "Login successful for user4";
        } else if ("user5".equals(username) && "password5".equals(password)) {
            return "Login successful for user5";
        } else {
            return "Login failed";
        }
    }
}
```
```python
class Task7:
    @staticmethod
    def main():
        # Main method with 5 test cases
        print("Test case 1:", Client.send_login_request("user1", "password1"))
        print("Test case 2:", Client.send_login_request("user2", "password2"))
        print("Test case 3:", Client.send_login_request("user3", "wrongpassword"))
        print("Test case 4:", Client.send_login_request("user4", "password4"))
        print("Test case 5:", Client.send_login_request("user5", "password5"))

class Client:
    @staticmethod
    def send_login_request(username, password):
        return Server.process_login_request(username, password)

class Server:
    @staticmethod
    def process_login_request(username, password):
        # Simulate checking against stored credentials
        credentials = {
            "user1": "password1",
            "user2": "password2",
            "user4": "password4",
            "user5": "password5",
        }
        if username in credentials and credentials[username] == password:
            return f"Login successful for {username}"
        else:
            return "Login failed"

if __name__ == "__main__":
    Task7.main()
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

class Task7 {
public:
    static void main() {
        // Main method with 5 test cases
        std::cout << "Test case 1: " << Client::sendLoginRequest("user1", "password1") << std::endl;
        std::cout << "Test case 2: " << Client::sendLoginRequest("user2", "password2") << std::endl;
        std::cout << "Test case 3: " << Client::sendLoginRequest("user3", "wrongpassword") << std::endl;
        std::cout << "Test case 4: " << Client::sendLoginRequest("user4", "password4") << std::endl;
        std::cout << "Test case 5: " << Client::sendLoginRequest("user5", "password5") << std::endl;
    }
};

class Client {
public:
    static std::string sendLoginRequest(const std::string& username, const std::string& password) {
        return Server::processLoginRequest(username, password);
    }
};

class Server {
public:
    static std::string processLoginRequest(const std::string& username, const std::string& password) {
        // Simulate checking against stored credentials
        std::unordered_map<std::string, std::string> credentials = {
            {"user1", "password1"},
            {"user2", "password2"},
            {"user4", "password4"},
            {"user5", "password5"},
        };
        if (credentials.find(username) != credentials.end() && credentials[username] == password) {
            return "Login successful for " + username;
        } else {
            return "Login failed";
        }
    }
};

int main() {
    Task7::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

const char* processLoginRequest(const char* username, const char* password);

void main() {
    // Main method with 5 test cases
    printf("Test case 1: %s\n", processLoginRequest("user1", "password1"));
    printf("Test case 2: %s\n", processLoginRequest("user2", "password2"));
    printf("Test case 3: %s\n", processLoginRequest("user3", "wrongpassword"));
    printf("Test case 4: %s\n", processLoginRequest("user4", "password4"));
    printf("Test case 5: %s\n", processLoginRequest("user5", "password5"));
}

const char* processLoginRequest(const char* username, const char* password) {
    // Simulate checking against stored credentials
    if ((strcmp(username, "user1") == 0 && strcmp(password, "password1") == 0) ||
        (strcmp(username, "user2") == 0 && strcmp(password, "password2") == 0) ||
        (strcmp(username, "user4") == 0 && strcmp(password, "password4") == 0) ||
        (strcmp(username, "user5") == 0 && strcmp(password, "password5") == 0)) {
        return "Login successful";
    } else {
        return "Login failed";
    }
}
```
Created file: Task7.java
Created file: Task7.py
Created file: Task7.cpp
Created file: Task7.c
Task8_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task8, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Find the missing letter
Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.

You will always get an valid array. And it will be always exactly one letter be missing. The length of the array will always be at least 2.
The array will always contain letters in only one case.

Example:

['a','b','c','d','f'] -> 'e'
['O','Q','R','S'] -> 'P'
(Use the English alphabet with 26 letters!)
```java
public class Task8 {
    public static char findMissingLetter(char[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            if (array[i + 1] - array[i] != 1) {
                return (char) (array[i] + 1);
            }
        }
        throw new IllegalArgumentException("Invalid input: no missing letter found");
    }

    public static void main(String[] args) {
        System.out.println(findMissingLetter(new char[] {'a', 'b', 'c', 'd', 'f'})); // e
        System.out.println(findMissingLetter(new char[] {'O', 'Q', 'R', 'S'})); // P
        System.out.println(findMissingLetter(new char[] {'x', 'y', 'z', 'B'})); // A
        System.out.println(findMissingLetter(new char[] {'m', 'o'})); // n
        System.out.println(findMissingLetter(new char[] {'G', 'I', 'J', 'K'})); // H
    }
}
```
```python
def find_missing_letter(chars):
    for i in range(len(chars) - 1):
        if ord(chars[i + 1]) - ord(chars[i]) != 1:
            return chr(ord(chars[i]) + 1)
    raise ValueError("Invalid input: no missing letter found")

if __name__ == "__main__":
    print(find_missing_letter(['a', 'b', 'c', 'd', 'f']))  # e
    print(find_missing_letter(['O', 'Q', 'R', 'S']))  # P
    print(find_missing_letter(['x', 'y', 'z', 'B']))  # A
    print(find_missing_letter(['m', 'o']))  # n
    print(find_missing_letter(['G', 'I', 'J', 'K']))  # H
```
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

char findMissingLetter(const std::vector<char>& array) {
    for (size_t i = 0; i < array.size() - 1; ++i) {
        if (array[i + 1] - array[i] != 1) {
            return array[i] + 1;
        }
    }
    throw std::invalid_argument("Invalid input: no missing letter found");
}

int main() {
    std::cout << findMissingLetter({'a', 'b', 'c', 'd', 'f'}) << std::endl; // e
    std::cout << findMissingLetter({'O', 'Q', 'R', 'S'}) << std::endl; // P
    std::cout << findMissingLetter({'x', 'y', 'z', 'B'}) << std::endl; // A
    std::cout << findMissingLetter({'m', 'o'}) << std::endl; // n
    std::cout << findMissingLetter({'G', 'I', 'J', 'K'}) << std::endl; // H
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

char findMissingLetter(const char array[], size_t length) {
    for (size_t i = 0; i < length - 1; ++i) {
        if (array[i + 1] - array[i] != 1) {
            return array[i] + 1;
        }
    }
    fprintf(stderr, "Invalid input: no missing letter found\n");
    exit(EXIT_FAILURE);
}

int main() {
    char arr1[] = {'a', 'b', 'c', 'd', 'f'};
    char arr2[] = {'O', 'Q', 'R', 'S'};
    char arr3[] = {'x', 'y', 'z', 'B'};
    char arr4[] = {'m', 'o'};
    char arr5[] = {'G', 'I', 'J', 'K'};

    printf("%c\n", findMissingLetter(arr1, sizeof(arr1) / sizeof(arr1[0]))); // e
    printf("%c\n", findMissingLetter(arr2, sizeof(arr2) / sizeof(arr2[0]))); // P
    printf("%c\n", findMissingLetter(arr3, sizeof(arr3) / sizeof(arr3[0]))); // A
    printf("%c\n", findMissingLetter(arr4, sizeof(arr4) / sizeof(arr4[0]))); // n
    printf("%c\n", findMissingLetter(arr5, sizeof(arr5) / sizeof(arr5[0]))); // H

    return 0;
}
```
Created file: Task8.java
Created file: Task8.py
Created file: Task8.cpp
Created file: Task8.c
Task9_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task9, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given a list of integers, determine whether the sum of its elements is odd or even.

Give your answer as a string matching "odd" or "even".

If the input array is empty consider it as: [0] (array with a zero).

Examples:
Input: [0]
Output: "even"

Input: [0, 1, 4]
Output: "odd"

Input: [0, -1, -5]
Output: "even"
```java
public class Task9 {
    public static String oddOrEven(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return (sum % 2 == 0) ? "even" : "odd";
    }

    public static void main(String[] args) {
        System.out.println(oddOrEven(new int[]{0}));        // even
        System.out.println(oddOrEven(new int[]{0, 1, 4}));  // odd
        System.out.println(oddOrEven(new int[]{0, -1, -5}));// even
        System.out.println(oddOrEven(new int[]{2, 2, 2}));  // even
        System.out.println(oddOrEven(new int[]{1, 2, 3}));  // even
    }
}
```
```python
def odd_or_even(nums):
    total = sum(nums)
    return "even" if total % 2 == 0 else "odd"

if __name__ == "__main__":
    print(odd_or_even([0]))        # even
    print(odd_or_even([0, 1, 4]))  # odd
    print(odd_or_even([0, -1, -5]))# even
    print(odd_or_even([2, 2, 2]))  # even
    print(odd_or_even([1, 2, 3]))  # even
```
```cpp
#include <iostream>
#include <vector>
#include <numeric>

std::string oddOrEven(const std::vector<int>& nums) {
    int sum = std::accumulate(nums.begin(), nums.end(), 0);
    return (sum % 2 == 0) ? "even" : "odd";
}

int main() {
    std::cout << oddOrEven({0}) << std::endl;         // even
    std::cout << oddOrEven({0, 1, 4}) << std::endl;   // odd
    std::cout << oddOrEven({0, -1, -5}) << std::endl; // even
    std::cout << oddOrEven({2, 2, 2}) << std::endl;   // even
    std::cout << oddOrEven({1, 2, 3}) << std::endl;   // even
    return 0;
}
```
```c
#include <stdio.h>

const char* oddOrEven(int nums[], int length) {
    int sum = 0;
    for (int i = 0; i < length; i++) {
        sum += nums[i];
    }
    return (sum % 2 == 0) ? "even" : "odd";
}

int main() {
    int arr1[] = {0};
    printf("%s\n", oddOrEven(arr1, 1)); // even

    int arr2[] = {0, 1, 4};
    printf("%s\n", oddOrEven(arr2, 3)); // odd

    int arr3[] = {0, -1, -5};
    printf("%s\n", oddOrEven(arr3, 3)); // even

    int arr4[] = {2, 2, 2};
    printf("%s\n", oddOrEven(arr4, 3)); // even

    int arr5[] = {1, 2, 3};
    printf("%s\n", oddOrEven(arr5, 3)); // even

    return 0;
}
```
Created file: Task9.java
Created file: Task9.py
Created file: Task9.cpp
Created file: Task9.c
Task10_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task10, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given two integers a and b, which can be positive or negative, find the sum of all the integers between and including them and return it. If the two numbers are equal return a or b.

Note: a and b are not ordered!

Examples (a, b) --> output (explanation)
(1, 0) --> 1 (1 + 0 = 1)
(1, 2) --> 3 (1 + 2 = 3)
(0, 1) --> 1 (0 + 1 = 1)
(1, 1) --> 1 (1 since both are same)
(-1, 0) --> -1 (-1 + 0 = -1)
(-1, 2) --> 2 (-1 + 0 + 1 + 2 = 2)
Your function should only return a number, not the explanation about how you get that number.
```java
public class Task10 {
    public static int sumBetween(int a, int b) {
        int start = Math.min(a, b);
        int end = Math.max(a, b);
        int sum = 0;
        for (int i = start; i <= end; i++) {
            sum += i;
        }
        return sum;
    }

    public static void main(String[] args) {
        System.out.println(sumBetween(1, 0)); // 1
        System.out.println(sumBetween(1, 2)); // 3
        System.out.println(sumBetween(0, 1)); // 1
        System.out.println(sumBetween(1, 1)); // 1
        System.out.println(sumBetween(-1, 2)); // 2
    }
}
```
```python
def sum_between(a, b):
    start, end = sorted((a, b))
    return sum(range(start, end + 1))

if __name__ == "__main__":
    print(sum_between(1, 0)) # 1
    print(sum_between(1, 2)) # 3
    print(sum_between(0, 1)) # 1
    print(sum_between(1, 1)) # 1
    print(sum_between(-1, 2)) # 2
```
```cpp
#include <iostream>
#include <algorithm>

class Task10 {
public:
    static int sumBetween(int a, int b) {
        int start = std::min(a, b);
        int end = std::max(a, b);
        int sum = 0;
        for (int i = start; i <= end; ++i) {
            sum += i;
        }
        return sum;
    }
};

int main() {
    std::cout << Task10::sumBetween(1, 0) << std::endl; // 1
    std::cout << Task10::sumBetween(1, 2) << std::endl; // 3
    std::cout << Task10::sumBetween(0, 1) << std::endl; // 1
    std::cout << Task10::sumBetween(1, 1) << std::endl; // 1
    std::cout << Task10::sumBetween(-1, 2) << std::endl; // 2
    return 0;
}
```
```c
#include <stdio.h>

int sumBetween(int a, int b) {
    int start = a < b ? a : b;
    int end = a > b ? a : b;
    int sum = 0;
    for (int i = start; i <= end; ++i) {
        sum += i;
    }
    return sum;
}

int main() {
    printf("%d\n", sumBetween(1, 0)); // 1
    printf("%d\n", sumBetween(1, 2)); // 3
    printf("%d\n", sumBetween(0, 1)); // 1
    printf("%d\n", sumBetween(1, 1)); // 1
    printf("%d\n", sumBetween(-1, 2)); // 2
    return 0;
}
```
Created file: Task10.java
Created file: Task10.py
Created file: Task10.cpp
Created file: Task10.c
Task11_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task11, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
In a small town the population is p0 = 1000 at the beginning of a year. The population regularly increases by 2 percent per year and moreover 50 new inhabitants per year come to live in the town. How many years does the town need to see its population greater than or equal to p = 1200 inhabitants?

At the end of the first year there will be:
1000 + 1000 * 0.02 + 50 => 1070 inhabitants

At the end of the 2nd year there will be:
1070 + 1070 * 0.02 + 50 => 1141 inhabitants (** number of inhabitants is an integer **)

At the end of the 3rd year there will be:
1141 + 1141 * 0.02 + 50 => 1213

It will need 3 entire years.
More generally given parameters:

p0, percent, aug (inhabitants coming or leaving each year), p (population to equal or surpass)

the function nb_year should return n number of entire years needed to get a population greater or equal to p.

aug is an integer, percent a positive or null floating number, p0 and p are positive integers (> 0)

Examples:
nb_year(1500, 5, 100, 5000) -> 15
nb_year(1500000, 2.5, 10000, 2000000) -> 10
Note:
Don't forget to convert the percent parameter as a percentage in the body of your function: if the parameter percent is 2 you have to convert it to 0.02.

There are no fractions of people. At the end of each year, the population count is an integer: 252.8 people round down to 252 persons.
```java
public class Task11 {
    public static int nb_year(int p0, double percent, int aug, int p) {
        int years = 0;
        while (p0 < p) {
            p0 += p0 * percent / 100 + aug;
            years++;
        }
        return years;
    }

    public static void main(String[] args) {
        System.out.println(nb_year(1000, 2, 50, 1200)); // 3
        System.out.println(nb_year(1500, 5, 100, 5000)); // 15
        System.out.println(nb_year(1500000, 2.5, 10000, 2000000)); // 10
        System.out.println(nb_year(1000, 0, 0, 1000)); // 0
        System.out.println(nb_year(1000, 0, 100, 1100)); // 1
    }
}
```
```python
def nb_year(p0, percent, aug, p):
    years = 0
    while p0 < p:
        p0 += int(p0 * percent / 100) + aug
        years += 1
    return years

if __name__ == "__main__":
    print(nb_year(1000, 2, 50, 1200))  # 3
    print(nb_year(1500, 5, 100, 5000))  # 15
    print(nb_year(1500000, 2.5, 10000, 2000000))  # 10
    print(nb_year(1000, 0, 0, 1000))  # 0
    print(nb_year(1000, 0, 100, 1100))  # 1
```
```cpp
#include <iostream>

class Task11 {
public:
    static int nb_year(int p0, double percent, int aug, int p) {
        int years = 0;
        while (p0 < p) {
            p0 += static_cast<int>(p0 * percent / 100) + aug;
            years++;
        }
        return years;
    }
};

int main() {
    std::cout << Task11::nb_year(1000, 2, 50, 1200) << std::endl; // 3
    std::cout << Task11::nb_year(1500, 5, 100, 5000) << std::endl; // 15
    std::cout << Task11::nb_year(1500000, 2.5, 10000, 2000000) << std::endl; // 10
    std::cout << Task11::nb_year(1000, 0, 0, 1000) << std::endl; // 0
    std::cout << Task11::nb_year(1000, 0, 100, 1100) << std::endl; // 1
    return 0;
}
```
```c
#include <stdio.h>

int nb_year(int p0, double percent, int aug, int p) {
    int years = 0;
    while (p0 < p) {
        p0 += (int)(p0 * percent / 100) + aug;
        years++;
    }
    return years;
}

int main() {
    printf("%d\n", nb_year(1000, 2, 50, 1200)); // 3
    printf("%d\n", nb_year(1500, 5, 100, 5000)); // 15
    printf("%d\n", nb_year(1500000, 2.5, 10000, 2000000)); // 10
    printf("%d\n", nb_year(1000, 0, 0, 1000)); // 0
    printf("%d\n", nb_year(1000, 0, 100, 1100)); // 1
    return 0;
}
```
Created file: Task11.java
Created file: Task11.py
Created file: Task11.cpp
Created file: Task11.c
Task12_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task12, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given a string of words, you need to find the highest scoring word.

Each letter of a word scores points according to its position in the alphabet: a = 1, b = 2, c = 3 etc.

For example, the score of abad is 8 (1 + 2 + 1 + 4).

You need to return the highest scoring word as a string.

If two words score the same, return the word that appears earliest in the original string.

All letters will be lowercase and all inputs will be valid.
```java
public class Task12 {
    public static String highestScoringWord(String input) {
        String[] words = input.split(" ");
        int maxScore = 0;
        String highestWord = "";

        for (String word : words) {
            int score = 0;
            for (char c : word.toCharArray()) {
                score += c - 'a' + 1;
            }
            if (score > maxScore) {
                maxScore = score;
                highestWord = word;
            }
        }

        return highestWord;
    }

    public static void main(String[] args) {
        System.out.println(highestScoringWord("abad car boot")); // Output: car
        System.out.println(highestScoringWord("hello world"));   // Output: world
        System.out.println(highestScoringWord("java is fun"));   // Output: java
        System.out.println(highestScoringWord("secure code"));   // Output: secure
        System.out.println(highestScoringWord("abc xyz"));       // Output: xyz
    }
}
```
```python
def highest_scoring_word(input_string):
    words = input_string.split()
    max_score = 0
    highest_word = ""

    for word in words:
        score = sum(ord(c) - ord('a') + 1 for c in word)
        if score > max_score:
            max_score = score
            highest_word = word

    return highest_word

if __name__ == "__main__":
    print(highest_scoring_word("abad car boot"))  # Output: car
    print(highest_scoring_word("hello world"))    # Output: world
    print(highest_scoring_word("java is fun"))    # Output: java
    print(highest_scoring_word("secure code"))    # Output: secure
    print(highest_scoring_word("abc xyz"))        # Output: xyz
```
```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

string highestScoringWord(const string& input) {
    stringstream ss(input);
    string word, highestWord;
    int maxScore = 0;

    while (ss >> word) {
        int score = 0;
        for (char c : word) {
            score += c - 'a' + 1;
        }
        if (score > maxScore) {
            maxScore = score;
            highestWord = word;
        }
    }

    return highestWord;
}

int main() {
    cout << highestScoringWord("abad car boot") << endl;  // Output: car
    cout << highestScoringWord("hello world") << endl;    // Output: world
    cout << highestScoringWord("java is fun") << endl;    // Output: java
    cout << highestScoringWord("secure code") << endl;    // Output: secure
    cout << highestScoringWord("abc xyz") << endl;        // Output: xyz
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

char* highestScoringWord(const char* input) {
    static char highestWord[100];
    int maxScore = 0;
    int score;
    char word[100];
    int i = 0, j = 0;

    while (1) {
        if (input[i] == ' ' || input[i] == '\0') {
            word[j] = '\0';
            score = 0;
            for (int k = 0; word[k] != '\0'; ++k) {
                score += word[k] - 'a' + 1;
            }
            if (score > maxScore) {
                maxScore = score;
                strcpy(highestWord, word);
            }
            j = 0;
            if (input[i] == '\0') break;
        } else {
            word[j++] = input[i];
        }
        i++;
    }
    return highestWord;
}

int main() {
    printf("%s\n", highestScoringWord("abad car boot"));  // Output: car
    printf("%s\n", highestScoringWord("hello world"));    // Output: world
    printf("%s\n", highestScoringWord("java is fun"));    // Output: java
    printf("%s\n", highestScoringWord("secure code"));    // Output: secure
    printf("%s\n", highestScoringWord("abc xyz"));        // Output: xyz
    return 0;
}
```
Created file: Task12.java
Created file: Task12.py
Created file: Task12.cpp
Created file: Task12.c
Task13_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task13, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block for each letter (direction) and you know it takes you one minute to traverse one city block, so create a function that will return true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, of course, return you to your starting point. Return false otherwise.

Note: you will always receive a valid array containing a random assortment of direction letters ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).
```java
import java.util.HashMap;
import java.util.Map;

public class Task13 {
    public static boolean isValidWalk(char[] walk) {
        if (walk.length != 10) {
            return false;
        }
        Map<Character, Integer> directions = new HashMap<>();
        directions.put('n', 0);
        directions.put('s', 0);
        directions.put('e', 0);
        directions.put('w', 0);

        for (char direction : walk) {
            directions.put(direction, directions.get(direction) + 1);
        }

        return directions.get('n').equals(directions.get('s')) &&
               directions.get('e').equals(directions.get('w'));
    }

    public static void main(String[] args) {
        System.out.println(isValidWalk(new char[]{'n', 's', 'n', 's', 'n', 's', 'n', 's', 'n', 's'})); // true
        System.out.println(isValidWalk(new char[]{'n', 'n', 'n', 's', 's', 's', 'n', 's', 'e', 'w'})); // true
        System.out.println(isValidWalk(new char[]{'n', 'n', 'n', 's', 's', 's', 'n', 's', 'n', 's'})); // false
        System.out.println(isValidWalk(new char[]{'n', 'e', 'n', 'e', 'n', 'e', 'n', 'e', 'n', 'e'})); // false
        System.out.println(isValidWalk(new char[]{'n', 's', 'n', 's', 'n', 's', 'n', 's', 'n'})); // false
    }
}
```
```python
def is_valid_walk(walk):
    if len(walk) != 10:
        return False
    directions = {'n': 0, 's': 0, 'e': 0, 'w': 0}
    for direction in walk:
        directions[direction] += 1
    return directions['n'] == directions['s'] and directions['e'] == directions['w']

if __name__ == "__main__":
    print(is_valid_walk(['n', 's', 'n', 's', 'n', 's', 'n', 's', 'n', 's']))  # True
    print(is_valid_walk(['n', 'n', 'n', 's', 's', 's', 'n', 's', 'e', 'w']))  # True
    print(is_valid_walk(['n', 'n', 'n', 's', 's', 's', 'n', 's', 'n', 's']))  # False
    print(is_valid_walk(['n', 'e', 'n', 'e', 'n', 'e', 'n', 'e', 'n', 'e']))  # False
    print(is_valid_walk(['n', 's', 'n', 's', 'n', 's', 'n', 's', 'n']))      # False
```
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

class Task13 {
public:
    static bool isValidWalk(const std::vector<char>& walk) {
        if (walk.size() != 10) {
            return false;
        }
        std::unordered_map<char, int> directions = {{'n', 0}, {'s', 0}, {'e', 0}, {'w', 0}};
        for (char direction : walk) {
            directions[direction]++;
        }
        return directions['n'] == directions['s'] && directions['e'] == directions['w'];
    }

    static void test() {
        std::cout << isValidWalk({'n', 's', 'n', 's', 'n', 's', 'n', 's', 'n', 's'}) << std::endl; // true
        std::cout << isValidWalk({'n', 'n', 'n', 's', 's', 's', 'n', 's', 'e', 'w'}) << std::endl; // true
        std::cout << isValidWalk({'n', 'n', 'n', 's', 's', 's', 'n', 's', 'n', 's'}) << std::endl; // false
        std::cout << isValidWalk({'n', 'e', 'n', 'e', 'n', 'e', 'n', 'e', 'n', 'e'}) << std::endl; // false
        std::cout << isValidWalk({'n', 's', 'n', 's', 'n', 's', 'n', 's', 'n'}) << std::endl;      // false
    }
};

int main() {
    Task13::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

int isValidWalk(const char walk[], int size) {
    if (size != 10) {
        return 0;
    }
    int northSouth = 0, eastWest = 0;
    for (int i = 0; i < size; i++) {
        switch (walk[i]) {
            case 'n': northSouth++; break;
            case 's': northSouth--; break;
            case 'e': eastWest++; break;
            case 'w': eastWest--; break;
        }
    }
    return northSouth == 0 && eastWest == 0;
}

int main() {
    printf("%d\n", isValidWalk("nsnsnsnsns", 10)); // true
    printf("%d\n", isValidWalk("nnnsssnsew", 10)); // true
    printf("%d\n", isValidWalk("nnnsssnsns", 10)); // false
    printf("%d\n", isValidWalk("nenenenene", 10)); // false
    printf("%d\n", isValidWalk("nsnsnsnsn", 9));   // false
    return 0;
}
```
Created file: Task13.java
Created file: Task13.py
Created file: Task13.cpp
Created file: Task13.c
Task14_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task14, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N.

If there is no index that would make this happen, return -1.

For example:
Let's say you are given the array {1,2,3,4,3,2,1}:
Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.

Let's look at another one.
You are given the array {1,100,50,-51,1,1}:
Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.

Last one:
You are given the array {20,10,-80,10,10,15,35}
At index 0 the left side is {}
The right side is {10,-80,10,10,15,35}
They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
Index 0 is the place where the left side and right side are equal.

Note: Please remember that in most languages the index of an array starts at 0.

Input
An integer array of length 0 < arr < 1000. The numbers in the array can be any integer positive or negative.

Output
The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1.

Note
If you are given an array with multiple answers, return the lowest correct index.
```java
public class Task14 {
    public static int findEqualSumIndex(int[] arr) {
        int totalSum = 0;
        for (int num : arr) {
            totalSum += num;
        }

        int leftSum = 0;
        for (int i = 0; i < arr.length; i++) {
            int rightSum = totalSum - leftSum - arr[i];
            if (leftSum == rightSum) {
                return i;
            }
            leftSum += arr[i];
        }
        return -1;
    }

    public static void main(String[] args) {
        System.out.println(findEqualSumIndex(new int[]{1, 2, 3, 4, 3, 2, 1})); // 3
        System.out.println(findEqualSumIndex(new int[]{1, 100, 50, -51, 1, 1})); // 1
        System.out.println(findEqualSumIndex(new int[]{20, 10, -80, 10, 10, 15, 35})); // 0
        System.out.println(findEqualSumIndex(new int[]{1, 2, 3})); // -1
        System.out.println(findEqualSumIndex(new int[]{1, -1, 0, 1, -1})); // 2
    }
}
```
```python
def find_equal_sum_index(arr):
    total_sum = sum(arr)
    left_sum = 0

    for i in range(len(arr)):
        right_sum = total_sum - left_sum - arr[i]
        if left_sum == right_sum:
            return i
        left_sum += arr[i]

    return -1

if __name__ == "__main__":
    print(find_equal_sum_index([1, 2, 3, 4, 3, 2, 1]))  # 3
    print(find_equal_sum_index([1, 100, 50, -51, 1, 1]))  # 1
    print(find_equal_sum_index([20, 10, -80, 10, 10, 15, 35]))  # 0
    print(find_equal_sum_index([1, 2, 3]))  # -1
    print(find_equal_sum_index([1, -1, 0, 1, -1]))  # 2
```
```cpp
#include <iostream>
#include <vector>

class Task14 {
public:
    static int findEqualSumIndex(const std::vector<int>& arr) {
        int totalSum = 0;
        for (int num : arr) {
            totalSum += num;
        }

        int leftSum = 0;
        for (size_t i = 0; i < arr.size(); ++i) {
            int rightSum = totalSum - leftSum - arr[i];
            if (leftSum == rightSum) {
                return i;
            }
            leftSum += arr[i];
        }
        return -1;
    }
};

int main() {
    std::cout << Task14::findEqualSumIndex({1, 2, 3, 4, 3, 2, 1}) << std::endl; // 3
    std::cout << Task14::findEqualSumIndex({1, 100, 50, -51, 1, 1}) << std::endl; // 1
    std::cout << Task14::findEqualSumIndex({20, 10, -80, 10, 10, 15, 35}) << std::endl; // 0
    std::cout << Task14::findEqualSumIndex({1, 2, 3}) << std::endl; // -1
    std::cout << Task14::findEqualSumIndex({1, -1, 0, 1, -1}) << std::endl; // 2
    return 0;
}
```
```c
#include <stdio.h>

int findEqualSumIndex(int arr[], int length) {
    int totalSum = 0;
    for (int i = 0; i < length; i++) {
        totalSum += arr[i];
    }

    int leftSum = 0;
    for (int i = 0; i < length; i++) {
        int rightSum = totalSum - leftSum - arr[i];
        if (leftSum == rightSum) {
            return i;
        }
        leftSum += arr[i];
    }
    return -1;
}

int main() {
    int arr1[] = {1, 2, 3, 4, 3, 2, 1};
    int arr2[] = {1, 100, 50, -51, 1, 1};
    int arr3[] = {20, 10, -80, 10, 10, 15, 35};
    int arr4[] = {1, 2, 3};
    int arr5[] = {1, -1, 0, 1, -1};

    printf("%d\n", findEqualSumIndex(arr1, 7)); // 3
    printf("%d\n", findEqualSumIndex(arr2, 6)); // 1
    printf("%d\n", findEqualSumIndex(arr3, 7)); // 0
    printf("%d\n", findEqualSumIndex(arr4, 3)); // -1
    printf("%d\n", findEqualSumIndex(arr5, 5)); // 2

    return 0;
}
```
Created file: Task14.java
Created file: Task14.py
Created file: Task14.cpp
Created file: Task14.c
Task15_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task15, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Build Tower
Build a pyramid-shaped tower, as an array/list of strings, given a positive integer number of floors. A tower block is represented with "*" character.

For example, a tower with 3 floors looks like this:

[
  "  *  ",
  " *** ",
  "*****"
]
And a tower with 6 floors looks like this:

[
  "     *     ",
  "    ***    ",
  "   *****   ",
  "  *******  ",
  " ********* ",
  "***********"
]

```java
public class Task15 {
    public static String[] buildTower(int floors) {
        String[] tower = new String[floors];
        int width = floors * 2 - 1;
        for (int i = 0; i < floors; i++) {
            int stars = i * 2 + 1;
            int spaces = (width - stars) / 2;
            tower[i] = " ".repeat(spaces) + "*".repeat(stars) + " ".repeat(spaces);
        }
        return tower;
    }

    public static void main(String[] args) {
        int[] testCases = {3, 6, 1, 4, 5};
        for (int floors : testCases) {
            String[] tower = buildTower(floors);
            for (String line : tower) {
                System.out.println(line);
            }
            System.out.println();
        }
    }
}
```
```python
def build_tower(floors):
    tower = []
    width = floors * 2 - 1
    for i in range(floors):
        stars = i * 2 + 1
        spaces = (width - stars) // 2
        tower.append(' ' * spaces + '*' * stars + ' ' * spaces)
    return tower

if __name__ == "__main__":
    test_cases = [3, 6, 1, 4, 5]
    for floors in test_cases:
        tower = build_tower(floors)
        for line in tower:
            print(line)
        print()
```
```cpp
#include <iostream>
#include <vector>
#include <string>

class Task15 {
public:
    static std::vector<std::string> buildTower(int floors) {
        std::vector<std::string> tower;
        int width = floors * 2 - 1;
        for (int i = 0; i < floors; ++i) {
            int stars = i * 2 + 1;
            int spaces = (width - stars) / 2;
            std::string line(spaces, ' ');
            line += std::string(stars, '*');
            line += std::string(spaces, ' ');
            tower.push_back(line);
        }
        return tower;
    }
};

int main() {
    std::vector<int> testCases = {3, 6, 1, 4, 5};
    for (int floors : testCases) {
        std::vector<std::string> tower = Task15::buildTower(floors);
        for (const std::string& line : tower) {
            std::cout << line << std::endl;
        }
        std::cout << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char** buildTower(int floors, int* returnSize) {
    *returnSize = floors;
    char** tower = (char**)malloc(floors * sizeof(char*));
    int width = floors * 2 - 1;
    for (int i = 0; i < floors; ++i) {
        int stars = i * 2 + 1;
        int spaces = (width - stars) / 2;
        tower[i] = (char*)malloc((width + 1) * sizeof(char));
        memset(tower[i], ' ', width);
        memset(tower[i] + spaces, '*', stars);
        tower[i][width] = '\0';
    }
    return tower;
}

int main() {
    int testCases[] = {3, 6, 1, 4, 5};
    int testCaseCount = sizeof(testCases) / sizeof(testCases[0]);
    for (int i = 0; i < testCaseCount; ++i) {
        int floors = testCases[i];
        int returnSize;
        char** tower = buildTower(floors, &returnSize);
        for (int j = 0; j < returnSize; ++j) {
            printf("%s\n", tower[j]);
            free(tower[j]);
        }
        free(tower);
        printf("\n");
    }
    return 0;
}
```
Created file: Task15.java
Created file: Task15.py
Created file: Task15.cpp
Created file: Task15.c
Task16_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task16, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

Examples:

solution('abc', 'bc') // returns true
solution('abc', 'd') // returns false
```java
public class Task16 {
    public static boolean solution(String str, String ending) {
        if (str == null || ending == null) {
            return false;
        }
        return str.endsWith(ending);
    }

    public static void main(String[] args) {
        System.out.println(solution("abc", "bc")); // true
        System.out.println(solution("abc", "d")); // false
        System.out.println(solution("hello", "lo")); // true
        System.out.println(solution("test", "st")); // true
        System.out.println(solution("java", "va")); // true
    }
}
```
```python
def solution(string, ending):
    if string is None or ending is None:
        return False
    return string.endswith(ending)

if __name__ == "__main__":
    print(solution("abc", "bc"))  # True
    print(solution("abc", "d"))   # False
    print(solution("hello", "lo"))  # True
    print(solution("test", "st"))  # True
    print(solution("java", "va"))  # True
```
```cpp
#include <iostream>
#include <string>

class Task16 {
public:
    static bool solution(const std::string& str, const std::string& ending) {
        if (str.size() < ending.size()) {
            return false;
        }
        return str.compare(str.size() - ending.size(), ending.size(), ending) == 0;
    }
};

int main() {
    std::cout << std::boolalpha;
    std::cout << Task16::solution("abc", "bc") << std::endl;  // true
    std::cout << Task16::solution("abc", "d") << std::endl;   // false
    std::cout << Task16::solution("hello", "lo") << std::endl;  // true
    std::cout << Task16::solution("test", "st") << std::endl;  // true
    std::cout << Task16::solution("java", "va") << std::endl;  // true
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool solution(const char* str, const char* ending) {
    if (str == NULL || ending == NULL) {
        return false;
    }
    size_t str_len = strlen(str);
    size_t ending_len = strlen(ending);
    if (str_len < ending_len) {
        return false;
    }
    return strcmp(str + str_len - ending_len, ending) == 0;
}

int main() {
    printf("%s\n", solution("abc", "bc") ? "true" : "false");  // true
    printf("%s\n", solution("abc", "d") ? "true" : "false");   // false
    printf("%s\n", solution("hello", "lo") ? "true" : "false");  // true
    printf("%s\n", solution("test", "st") ? "true" : "false");  // true
    printf("%s\n", solution("java", "va") ? "true" : "false");  // true
    return 0;
}
```
Created file: Task16.java
Created file: Task16.py
Created file: Task16.cpp
Created file: Task16.c
Task17_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task17, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

Example:

Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"
Note that the Java version expects a return value of null for an empty string or null.
https://web.archive.org/web/20190624190255/https://twitter.com/officialjaden
```java
public class Task17 {
    public static String toJadenCase(String phrase) {
        if (phrase == null || phrase.trim().isEmpty()) {
            return null;
        }
        String[] words = phrase.split("\\s+");
        StringBuilder jadenCased = new StringBuilder();
        for (String word : words) {
            jadenCased.append(Character.toUpperCase(word.charAt(0)));
            if (word.length() > 1) {
                jadenCased.append(word.substring(1).toLowerCase());
            }
            jadenCased.append(" ");
        }
        return jadenCased.toString().trim();
    }

    public static void main(String[] args) {
        System.out.println(toJadenCase("How can mirrors be real if our eyes aren't real")); // How Can Mirrors Be Real If Our Eyes Aren't Real
        System.out.println(toJadenCase("the world is going to end")); // The World Is Going To End
        System.out.println(toJadenCase("")); // null
        System.out.println(toJadenCase(null)); // null
        System.out.println(toJadenCase("all the adults are responsible for children")); // All The Adults Are Responsible For Children
    }
}
```
```python
def to_jaden_case(phrase):
    if not phrase or not phrase.strip():
        return None
    return ' '.join(word.capitalize() for word in phrase.split())

if __name__ == "__main__":
    print(to_jaden_case("How can mirrors be real if our eyes aren't real")) # How Can Mirrors Be Real If Our Eyes Aren't Real
    print(to_jaden_case("the world is going to end")) # The World Is Going To End
    print(to_jaden_case("")) # None
    print(to_jaden_case(None)) # None
    print(to_jaden_case("all the adults are responsible for children")) # All The Adults Are Responsible For Children
```
```cpp
#include <iostream>
#include <sstream>
#include <cctype>
#include <string>

class Task17 {
public:
    static std::string toJadenCase(const std::string &phrase) {
        if (phrase.empty() || phrase.find_first_not_of(' ') == std::string::npos) {
            return "";
        }
        std::istringstream iss(phrase);
        std::string word, result;
        while (iss >> word) {
            if (!word.empty()) {
                word[0] = std::toupper(word[0]);
                for (size_t i = 1; i < word.length(); ++i) {
                    word[i] = std::tolower(word[i]);
                }
                result += word + " ";
            }
        }
        if (!result.empty()) {
            result.pop_back(); // Remove trailing space
        }
        return result;
    }

    static void test() {
        std::cout << toJadenCase("How can mirrors be real if our eyes aren't real") << std::endl;
        std::cout << toJadenCase("the world is going to end") << std::endl;
        std::cout << toJadenCase("") << std::endl;
        std::cout << toJadenCase("all the adults are responsible for children") << std::endl;
        std::cout << toJadenCase("   ") << std::endl;
    }
};

int main() {
    Task17::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

char* toJadenCase(const char *phrase) {
    if (phrase == NULL || strlen(phrase) == 0 || strspn(phrase, " ") == strlen(phrase)) {
        return NULL;
    }
    static char result[256];
    memset(result, 0, sizeof(result));
    int capitalizeNext = 1;
    for (int i = 0; phrase[i]; i++) {
        if (phrase[i] == ' ') {
            result[i] = ' ';
            capitalizeNext = 1;
        } else {
            result[i] = capitalizeNext ? toupper(phrase[i]) : tolower(phrase[i]);
            capitalizeNext = 0;
        }
    }
    return result;
}

int main() {
    printf("%s\n", toJadenCase("How can mirrors be real if our eyes aren't real"));
    printf("%s\n", toJadenCase("the world is going to end"));
    printf("%s\n", toJadenCase(""));
    printf("%s\n", toJadenCase("all the adults are responsible for children"));
    printf("%s\n", toJadenCase("   "));
    return 0;
}
```
Created file: Task17.java
Created file: Task17.py
Created file: Task17.cpp
Created file: Task17.c
Task18_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task18, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an array of ones and zeroes, convert the equivalent binary value to an integer.

Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.

Examples:

Testing: [0, 0, 0, 1] ==> 1
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 0, 1] ==> 5
Testing: [1, 0, 0, 1] ==> 9
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 1, 0] ==> 6
Testing: [1, 1, 1, 1] ==> 15
Testing: [1, 0, 1, 1] ==> 11
However, the arrays can have varying lengths, not just limited to 4.
```java
public class Task18 {
    public static int binaryArrayToInt(int[] binaryArray) {
        if (binaryArray == null || binaryArray.length == 0) {
            throw new IllegalArgumentException("Input array must not be null or empty");
        }
        int result = 0;
        for (int i = 0; i < binaryArray.length; i++) {
            if (binaryArray[i] != 0 && binaryArray[i] != 1) {
                throw new IllegalArgumentException("Array elements must be 0 or 1");
            }
            result = (result << 1) | binaryArray[i];
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(binaryArrayToInt(new int[]{0, 0, 0, 1})); // 1
        System.out.println(binaryArrayToInt(new int[]{0, 0, 1, 0})); // 2
        System.out.println(binaryArrayToInt(new int[]{0, 1, 0, 1})); // 5
        System.out.println(binaryArrayToInt(new int[]{1, 0, 0, 1})); // 9
        System.out.println(binaryArrayToInt(new int[]{1, 1, 1, 1})); // 15
    }
}
```
```python
def binary_array_to_int(binary_array):
    if not binary_array:
        raise ValueError("Input array must not be empty")
    result = 0
    for bit in binary_array:
        if bit not in (0, 1):
            raise ValueError("Array elements must be 0 or 1")
        result = (result << 1) | bit
    return result

if __name__ == "__main__":
    print(binary_array_to_int([0, 0, 0, 1]))  # 1
    print(binary_array_to_int([0, 0, 1, 0]))  # 2
    print(binary_array_to_int([0, 1, 0, 1]))  # 5
    print(binary_array_to_int([1, 0, 0, 1]))  # 9
    print(binary_array_to_int([1, 1, 1, 1]))  # 15
```
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

int binaryArrayToInt(const std::vector<int>& binaryArray) {
    if (binaryArray.empty()) {
        throw std::invalid_argument("Input array must not be empty");
    }
    int result = 0;
    for (int bit : binaryArray) {
        if (bit != 0 && bit != 1) {
            throw std::invalid_argument("Array elements must be 0 or 1");
        }
        result = (result << 1) | bit;
    }
    return result;
}

int main() {
    std::cout << binaryArrayToInt({0, 0, 0, 1}) << std::endl; // 1
    std::cout << binaryArrayToInt({0, 0, 1, 0}) << std::endl; // 2
    std::cout << binaryArrayToInt({0, 1, 0, 1}) << std::endl; // 5
    std::cout << binaryArrayToInt({1, 0, 0, 1}) << std::endl; // 9
    std::cout << binaryArrayToInt({1, 1, 1, 1}) << std::endl; // 15
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int binaryArrayToInt(const int *binaryArray, size_t length) {
    if (binaryArray == NULL || length == 0) {
        fprintf(stderr, "Input array must not be null or empty\n");
        exit(EXIT_FAILURE);
    }
    int result = 0;
    for (size_t i = 0; i < length; i++) {
        if (binaryArray[i] != 0 && binaryArray[i] != 1) {
            fprintf(stderr, "Array elements must be 0 or 1\n");
            exit(EXIT_FAILURE);
        }
        result = (result << 1) | binaryArray[i];
    }
    return result;
}

int main() {
    int arr1[] = {0, 0, 0, 1};
    int arr2[] = {0, 0, 1, 0};
    int arr3[] = {0, 1, 0, 1};
    int arr4[] = {1, 0, 0, 1};
    int arr5[] = {1, 1, 1, 1};

    printf("%d\n", binaryArrayToInt(arr1, 4)); // 1
    printf("%d\n", binaryArrayToInt(arr2, 4)); // 2
    printf("%d\n", binaryArrayToInt(arr3, 4)); // 5
    printf("%d\n", binaryArrayToInt(arr4, 4)); // 9
    printf("%d\n", binaryArrayToInt(arr5, 4)); // 15

    return 0;
}
```
Created file: Task18.java
Created file: Task18.py
Created file: Task18.cpp
Created file: Task18.c
Task19_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task19, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a function that takes in a string of one or more words, and returns the same string, but with all words that have five or more letters reversed (Just like the name of this Kata). Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.

Examples:

"Hey fellow warriors"  --> "Hey wollef sroirraw"
"This is a test        --> "This is a test"
"This is another test" --> "This is rehtona test"
```java
public class Task19 {
    public static String reverseWords(String input) {
        String[] words = input.split(" ");
        StringBuilder result = new StringBuilder();

        for (String word : words) {
            if (word.length() >= 5) {
                result.append(new StringBuilder(word).reverse());
            } else {
                result.append(word);
            }
            result.append(" ");
        }

        return result.toString().trim();
    }

    public static void main(String[] args) {
        System.out.println(reverseWords("Hey fellow warriors"));
        System.out.println(reverseWords("This is a test"));
        System.out.println(reverseWords("This is another test"));
        System.out.println(reverseWords("Hello world"));
        System.out.println(reverseWords("Programming is fun"));
    }
}
```
```python
def reverse_words(input):
    words = input.split()
    result = []

    for word in words:
        if len(word) >= 5:
            result.append(word[::-1])
        else:
            result.append(word)

    return ' '.join(result)

if __name__ == "__main__":
    print(reverse_words("Hey fellow warriors"))
    print(reverse_words("This is a test"))
    print(reverse_words("This is another test"))
    print(reverse_words("Hello world"))
    print(reverse_words("Programming is fun"))
```
```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <algorithm>

class Task19 {
public:
    static std::string reverseWords(const std::string& input) {
        std::istringstream iss(input);
        std::ostringstream oss;
        std::string word;

        while (iss >> word) {
            if (word.length() >= 5) {
                std::reverse(word.begin(), word.end());
            }
            oss << word << " ";
        }

        std::string result = oss.str();
        if (!result.empty()) {
            result.pop_back(); // Remove the trailing space
        }

        return result;
    }

    static void runTests() {
        std::cout << reverseWords("Hey fellow warriors") << std::endl;
        std::cout << reverseWords("This is a test") << std::endl;
        std::cout << reverseWords("This is another test") << std::endl;
        std::cout << reverseWords("Hello world") << std::endl;
        std::cout << reverseWords("Programming is fun") << std::endl;
    }
};

int main() {
    Task19::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void reverseWord(char* start, char* end) {
    char temp;
    while (start < end) {
        temp = *start;
        *start++ = *end;
        *end-- = temp;
    }
}

char* reverseWords(const char* input) {
    static char buffer[1024];
    strcpy(buffer, input);

    char* word_start = NULL;
    char* temp = buffer;
    while (*temp) {
        if (!word_start && !isspace((unsigned char)*temp)) {
            word_start = temp;
        }

        if (word_start && (isspace((unsigned char)*temp) || *(temp + 1) == '\0')) {
            char* word_end = (isspace((unsigned char)*temp)) ? (temp - 1) : temp;
            if (word_end - word_start + 1 >= 5) {
                reverseWord(word_start, word_end);
            }
            word_start = NULL;
        }
        temp++;
    }
    return buffer;
}

int main() {
    printf("%s\n", reverseWords("Hey fellow warriors"));
    printf("%s\n", reverseWords("This is a test"));
    printf("%s\n", reverseWords("This is another test"));
    printf("%s\n", reverseWords("Hello world"));
    printf("%s\n", reverseWords("Programming is fun"));
    return 0;
}
```
Created file: Task19.java
Created file: Task19.py
Created file: Task19.cpp
Created file: Task19.c
Task20_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task20, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Some numbers have funny properties. For example:

89 --> 8 + 9 = 89 * 1
695 --> 6 + 9 + 5= 1390 = 695 * 2
46288 --> 4 + 6+ 2 + 8 + 8 = 2360688 = 46288 * 51
Given two positive integers n and p, we want to find a positive integer k, if it exists, such that the sum of the digits of n raised to consecutive powers starting from p is equal to k * n.

In other words, writing the consecutive digits of n as a, b, c, d ..., is there an integer k such that :

(


+


+
1
+


+
2
+


+
3
+
.
.
.
)
=



(a
p
 +b
p+1
 +c
p+2
 +d
p+3
 +...)=nk
If it is the case we will return k, if not return -1.

Note: n and p will always be strictly positive integers.

Examples:
n = 89; p = 1 ---> 1 since 8 + 9 = 89 = 89 * 1

n = 92; p = 1 ---> -1 since there is no k such that 9 + 2 equals 92 * k

n = 695; p = 2 ---> 2 since 6 + 9 + 5= 1390 = 695 * 2

n = 46288; p = 3 ---> 51 since 4 + 6+ 2 + 8 + 8 = 2360688 = 46288 * 51
```java
public class Task20 {

    public static int digPow(int n, int p) {
        String numStr = String.valueOf(n);
        int sum = 0;
        for (int i = 0; i < numStr.length(); i++, p++) {
            sum += Math.pow(Character.getNumericValue(numStr.charAt(i)), p);
        }
        return sum % n == 0 ? sum / n : -1;
    }

    public static void main(String[] args) {
        System.out.println(digPow(89, 1)); // 1
        System.out.println(digPow(92, 1)); // -1
        System.out.println(digPow(695, 2)); // 2
        System.out.println(digPow(46288, 3)); // 51
        System.out.println(digPow(123, 2)); // -1
    }
}
```
```python
def dig_pow(n, p):
    digits = list(map(int, str(n)))
    sum_ = sum(d ** (p + i) for i, d in enumerate(digits))
    return sum_ // n if sum_ % n == 0 else -1

if __name__ == "__main__":
    print(dig_pow(89, 1)) # 1
    print(dig_pow(92, 1)) # -1
    print(dig_pow(695, 2)) # 2
    print(dig_pow(46288, 3)) # 51
    print(dig_pow(123, 2)) # -1
```
```cpp
#include <iostream>
#include <cmath>
#include <string>

class Task20 {
public:
    static int digPow(int n, int p) {
        std::string numStr = std::to_string(n);
        int sum = 0;
        for (size_t i = 0; i < numStr.length(); i++, p++) {
            sum += std::pow(numStr[i] - '0', p);
        }
        return sum % n == 0 ? sum / n : -1;
    }
};

int main() {
    std::cout << Task20::digPow(89, 1) << std::endl; // 1
    std::cout << Task20::digPow(92, 1) << std::endl; // -1
    std::cout << Task20::digPow(695, 2) << std::endl; // 2
    std::cout << Task20::digPow(46288, 3) << std::endl; // 51
    std::cout << Task20::digPow(123, 2) << std::endl; // -1
    return 0;
}
```
```c
#include <stdio.h>
#include <math.h>
#include <string.h>

int digPow(int n, int p) {
    char numStr[20];
    sprintf(numStr, "%d", n);
    int sum = 0;
    for (int i = 0; i < strlen(numStr); i++, p++) {
        sum += pow(numStr[i] - '0', p);
    }
    return sum % n == 0 ? sum / n : -1;
}

int main() {
    printf("%d\n", digPow(89, 1)); // 1
    printf("%d\n", digPow(92, 1)); // -1
    printf("%d\n", digPow(695, 2)); // 2
    printf("%d\n", digPow(46288, 3)); // 51
    printf("%d\n", digPow(123, 2)); // -1
    return 0;
}
```
Created file: Task20.java
Created file: Task20.py
Created file: Task20.cpp
Created file: Task20.c
Task21_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task21, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
The museum of incredibly dull things
The museum of incredibly dull things wants to get rid of some exhibits. Miriam, the interior architect, comes up with a plan to remove the most boring exhibits. She gives them a rating, and then removes the one with the lowest rating.

However, just as she finished rating all exhibits, she's off to an important fair, so she asks you to write a program that tells her the ratings of the exhibits after removing the lowest one. Fair enough.

Task
Given an array of integers, remove the smallest value. Do not mutate the original array/list. If there are multiple elements with the same value, remove the one with the lowest index. If you get an empty array/list, return an empty array/list.

Don't change the order of the elements that are left.

Examples
* Input: [1,2,3,4,5], output = [2,3,4,5]
* Input: [5,3,2,1,4], output = [5,3,2,4]
* Input: [2,2,1,2,1], output = [2,2,2,1]
```java
import java.util.Arrays;

public class Task21 {
    public static int[] removeSmallest(int[] numbers) {
        if (numbers.length == 0) return new int[0];
        int minIndex = 0;
        for (int i = 1; i < numbers.length; i++) {
            if (numbers[i] < numbers[minIndex]) {
                minIndex = i;
            }
        }
        int[] result = new int[numbers.length - 1];
        for (int i = 0, j = 0; i < numbers.length; i++) {
            if (i != minIndex) {
                result[j++] = numbers[i];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(removeSmallest(new int[]{1, 2, 3, 4, 5}))); // [2, 3, 4, 5]
        System.out.println(Arrays.toString(removeSmallest(new int[]{5, 3, 2, 1, 4}))); // [5, 3, 2, 4]
        System.out.println(Arrays.toString(removeSmallest(new int[]{2, 2, 1, 2, 1}))); // [2, 2, 2, 1]
        System.out.println(Arrays.toString(removeSmallest(new int[]{1})));             // []
        System.out.println(Arrays.toString(removeSmallest(new int[]{})));              // []
    }
}
```
```python
def remove_smallest(numbers):
    if not numbers:
        return []
    min_value = min(numbers)
    min_index = numbers.index(min_value)
    return numbers[:min_index] + numbers[min_index+1:]

if __name__ == "__main__":
    print(remove_smallest([1, 2, 3, 4, 5]))  # [2, 3, 4, 5]
    print(remove_smallest([5, 3, 2, 1, 4]))  # [5, 3, 2, 4]
    print(remove_smallest([2, 2, 1, 2, 1]))  # [2, 2, 2, 1]
    print(remove_smallest([1]))              # []
    print(remove_smallest([]))               # []
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> removeSmallest(std::vector<int> numbers) {
    if (numbers.empty()) return {};
    auto min_iter = std::min_element(numbers.begin(), numbers.end());
    numbers.erase(min_iter);
    return numbers;
}

int main() {
    auto print_vector = [](const std::vector<int>& vec) {
        for (int num : vec) std::cout << num << " ";
        std::cout << std::endl;
    };

    print_vector(removeSmallest({1, 2, 3, 4, 5})); // 2 3 4 5
    print_vector(removeSmallest({5, 3, 2, 1, 4})); // 5 3 2 4
    print_vector(removeSmallest({2, 2, 1, 2, 1})); // 2 2 2 1
    print_vector(removeSmallest({1}));             //
    print_vector(removeSmallest({}));              //
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int* removeSmallest(const int* numbers, int size, int* returnSize) {
    if (size == 0) {
        *returnSize = 0;
        return NULL;
    }
    int minIndex = 0;
    for (int i = 1; i < size; i++) {
        if (numbers[i] < numbers[minIndex]) {
            minIndex = i;
        }
    }
    int* result = (int*)malloc((size - 1) * sizeof(int));
    for (int i = 0, j = 0; i < size; i++) {
        if (i != minIndex) {
            result[j++] = numbers[i];
        }
    }
    *returnSize = size - 1;
    return result;
}

void printArray(const int* array, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
}

int main() {
    int returnSize;
    int numbers1[] = {1, 2, 3, 4, 5};
    int* result1 = removeSmallest(numbers1, 5, &returnSize);
    printArray(result1, returnSize);
    free(result1);

    int numbers2[] = {5, 3, 2, 1, 4};
    int* result2 = removeSmallest(numbers2, 5, &returnSize);
    printArray(result2, returnSize);
    free(result2);

    int numbers3[] = {2, 2, 1, 2, 1};
    int* result3 = removeSmallest(numbers3, 5, &returnSize);
    printArray(result3, returnSize);
    free(result3);

    int numbers4[] = {1};
    int* result4 = removeSmallest(numbers4, 1, &returnSize);
    printArray(result4, returnSize);
    free(result4);

    int numbers5[] = {};
    int* result5 = removeSmallest(numbers5, 0, &returnSize);
    printArray(result5, returnSize);
    free(result5);

    return 0;
}
```
Created file: Task21.java
Created file: Task21.py
Created file: Task21.cpp
Created file: Task21.c
Task22_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task22, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You will create a function that takes a list of non-negative integers and strings and returns a new list with the strings filtered out.

Example
Kata.filterList(List.of(1, 2, "a", "b")) => List.of(1,2)
Kata.filterList(List.of(1, "a", "b", 0, 15)) => List.of(1,0,15)
Kata.filterList(List.of(1, 2, "a", "b", "aasf", "1", "123", 123)) => List.of(1, 2, 123)
```java
import java.util.ArrayList;
import java.util.List;

public class Task22 {
    public static List<Integer> filterList(List<Object> list) {
        List<Integer> filteredList = new ArrayList<>();
        for (Object item : list) {
            if (item instanceof Integer) {
                filteredList.add((Integer) item);
            }
        }
        return filteredList;
    }

    public static void main(String[] args) {
        System.out.println(filterList(List.of(1, 2, "a", "b"))); // [1, 2]
        System.out.println(filterList(List.of(1, "a", "b", 0, 15))); // [1, 0, 15]
        System.out.println(filterList(List.of(1, 2, "a", "b", "aasf", "1", "123", 123))); // [1, 2, 123]
        System.out.println(filterList(List.of(5, "test", 7, "example", 9))); // [5, 7, 9]
        System.out.println(filterList(List.of("hello", "world", 10, 20))); // [10, 20]
    }
}
```
```python
def filter_list(lst):
    return [item for item in lst if isinstance(item, int)]

if __name__ == "__main__":
    print(filter_list([1, 2, "a", "b"])) # [1, 2]
    print(filter_list([1, "a", "b", 0, 15])) # [1, 0, 15]
    print(filter_list([1, 2, "a", "b", "aasf", "1", "123", 123])) # [1, 2, 123]
    print(filter_list([5, "test", 7, "example", 9])) # [5, 7, 9]
    print(filter_list(["hello", "world", 10, 20])) # [10, 20]
```
```cpp
#include <iostream>
#include <vector>
#include <variant>

class Task22 {
public:
    static std::vector<int> filterList(const std::vector<std::variant<int, std::string>>& list) {
        std::vector<int> filteredList;
        for (const auto& item : list) {
            if (std::holds_alternative<int>(item)) {
                filteredList.push_back(std::get<int>(item));
            }
        }
        return filteredList;
    }
};

int main() {
    std::vector<std::variant<int, std::string>> list1 = {1, 2, "a", "b"};
    std::vector<std::variant<int, std::string>> list2 = {1, "a", "b", 0, 15};
    std::vector<std::variant<int, std::string>> list3 = {1, 2, "a", "b", "aasf", "1", "123", 123};
    std::vector<std::variant<int, std::string>> list4 = {5, "test", 7, "example", 9};
    std::vector<std::variant<int, std::string>> list5 = {"hello", "world", 10, 20};

    auto result1 = Task22::filterList(list1);
    auto result2 = Task22::filterList(list2);
    auto result3 = Task22::filterList(list3);
    auto result4 = Task22::filterList(list4);
    auto result5 = Task22::filterList(list5);

    for (auto num : result1) std::cout << num << " "; std::cout << std::endl;
    for (auto num : result2) std::cout << num << " "; std::cout << std::endl;
    for (auto num : result3) std::cout << num << " "; std::cout << std::endl;
    for (auto num : result4) std::cout << num << " "; std::cout << std::endl;
    for (auto num : result5) std::cout << num << " "; std::cout << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
    void** items;
    size_t size;
} List;

List filter_list(void** lst, size_t size) {
    void** filtered_items = malloc(size * sizeof(void*));
    size_t filtered_size = 0;

    for (size_t i = 0; i < size; ++i) {
        if (isdigit((long)lst[i])) {
            filtered_items[filtered_size++] = lst[i];
        }
    }

    List filtered_list;
    filtered_list.items = filtered_items;
    filtered_list.size = filtered_size;
    return filtered_list;
}

int main() {
    void* list1[] = {(void*)1, (void*)2, "a", "b"};
    void* list2[] = {(void*)1, "a", "b", (void*)0, (void*)15};
    void* list3[] = {(void*)1, (void*)2, "a", "b", "aasf", "1", "123", (void*)123};
    void* list4[] = {(void*)5, "test", (void*)7, "example", (void*)9};
    void* list5[] = {"hello", "world", (void*)10, (void*)20};

    List result1 = filter_list(list1, 4);
    List result2 = filter_list(list2, 5);
    List result3 = filter_list(list3, 8);
    List result4 = filter_list(list4, 5);
    List result5 = filter_list(list5, 4);

    for (size_t i = 0; i < result1.size; i++) printf("%ld ", (long)result1.items[i]); printf("\n");
    for (size_t i = 0; i < result2.size; i++) printf("%ld ", (long)result2.items[i]); printf("\n");
    for (size_t i = 0; i < result3.size; i++) printf("%ld ", (long)result3.items[i]); printf("\n");
    for (size_t i = 0; i < result4.size; i++) printf("%ld ", (long)result4.items[i]); printf("\n");
    for (size_t i = 0; i < result5.size; i++) printf("%ld ", (long)result5.items[i]); printf("\n");

    return 0;
}
```
Created file: Task22.java
Created file: Task22.py
Created file: Task22.cpp
Created file: Task22.c
Task23_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task23, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of

3
n
3
 , the cube above will have volume of
(


1
)
3
(n1)
3
  and so on until the top which will have a volume of
1
3
1
3
 .

You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?

The parameter of the function findNb (find_nb, find-nb, findNb, ...) will be an integer m and you have to return the integer n such as

3
+
(


1
)
3
+
(


2
)
3
+
.
.
.
+
1
3
=

n
3
 +(n1)
3
 +(n2)
3
 +...+1
3
 =m if such a n exists or -1 if there is no such n.

Examples:
findNb(1071225) --> 45

findNb(91716553919377) --> -1
```java
public class Task23 {
    public static long findNb(long m) {
        long n = 0;
        long sum = 0;
        while (sum < m) {
            n++;
            sum += n * n * n;
        }
        return sum == m ? n : -1;
    }

    public static void main(String[] args) {
        System.out.println(findNb(1071225)); // 45
        System.out.println(findNb(91716553919377L)); // -1
        System.out.println(findNb(4183059834009L)); // 2022
        System.out.println(findNb(24723578342962L)); // -1
        System.out.println(findNb(135440716410000L)); // 4824
    }
}
```
```python
def find_nb(m):
    n = 0
    sum = 0
    while sum < m:
        n += 1
        sum += n ** 3
    return n if sum == m else -1

if __name__ == "__main__":
    print(find_nb(1071225))  # 45
    print(find_nb(91716553919377))  # -1
    print(find_nb(4183059834009))  # 2022
    print(find_nb(24723578342962))  # -1
    print(find_nb(135440716410000))  # 4824
```
```cpp
#include <iostream>
using namespace std;

class Task23 {
public:
    static long long findNb(long long m) {
        long long n = 0;
        long long sum = 0;
        while (sum < m) {
            n++;
            sum += n * n * n;
        }
        return sum == m ? n : -1;
    }
};

int main() {
    cout << Task23::findNb(1071225) << endl; // 45
    cout << Task23::findNb(91716553919377LL) << endl; // -1
    cout << Task23::findNb(4183059834009LL) << endl; // 2022
    cout << Task23::findNb(24723578342962LL) << endl; // -1
    cout << Task23::findNb(135440716410000LL) << endl; // 4824
    return 0;
}
```
```c
#include <stdio.h>

long long findNb(long long m) {
    long long n = 0;
    long long sum = 0;
    while (sum < m) {
        n++;
        sum += n * n * n;
    }
    return sum == m ? n : -1;
}

int main() {
    printf("%lld\n", findNb(1071225)); // 45
    printf("%lld\n", findNb(91716553919377LL)); // -1
    printf("%lld\n", findNb(4183059834009LL)); // 2022
    printf("%lld\n", findNb(24723578342962LL)); // -1
    printf("%lld\n", findNb(135440716410000LL)); // 4824
    return 0;
}
```
Created file: Task23.java
Created file: Task23.py
Created file: Task23.cpp
Created file: Task23.c
Task24_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task24, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits.

If the function is passed a valid PIN string, return true, else return false.

Examples (Input --> Output)
"1234"   -->  true
"12345"  -->  false
"a234"   -->  false
```java
public class Task24 {
    public static boolean isValidPIN(String pin) {
        return pin.matches("\\d{4}|\\d{6}");
    }

    public static void main(String[] args) {
        System.out.println(isValidPIN("1234"));  // true
        System.out.println(isValidPIN("12345")); // false
        System.out.println(isValidPIN("a234"));  // false
        System.out.println(isValidPIN("123456"));// true
        System.out.println(isValidPIN("abcd12"));// false
    }
}
```
```python
def is_valid_pin(pin: str) -> bool:
    return len(pin) in {4, 6} and pin.isdigit()

if __name__ == "__main__":
    print(is_valid_pin("1234"))  # True
    print(is_valid_pin("12345")) # False
    print(is_valid_pin("a234"))  # False
    print(is_valid_pin("123456"))# True
    print(is_valid_pin("abcd12"))# False
```
```cpp
#include <iostream>
#include <string>
#include <regex>

class Task24 {
public:
    static bool isValidPIN(const std::string& pin) {
        return std::regex_match(pin, std::regex("^\\d{4}$|^\\d{6}$"));
    }

    static void test() {
        std::cout << isValidPIN("1234") << std::endl;   // true
        std::cout << isValidPIN("12345") << std::endl;  // false
        std::cout << isValidPIN("a234") << std::endl;   // false
        std::cout << isValidPIN("123456") << std::endl; // true
        std::cout << isValidPIN("abcd12") << std::endl; // false
    }
};

int main() {
    Task24::test();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int isValidPIN(const char *pin) {
    size_t length = strlen(pin);
    if (length != 4 && length != 6) {
        return 0;
    }
    for (size_t i = 0; i < length; ++i) {
        if (!isdigit(pin[i])) {
            return 0;
        }
    }
    return 1;
}

int main() {
    printf("%d\n", isValidPIN("1234"));   // true
    printf("%d\n", isValidPIN("12345"));  // false
    printf("%d\n", isValidPIN("a234"));   // false
    printf("%d\n", isValidPIN("123456")); // true
    printf("%d\n", isValidPIN("abcd12"));// false
    return 0;
}
```
Created file: Task24.java
Created file: Task24.py
Created file: Task24.cpp
Created file: Task24.c
Task25_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task25, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Your team is writing a fancy new text editor and you've been tasked with implementing the line numbering.

Write a function which takes a list of strings and returns each line prepended by the correct number.

The numbering starts at 1. The format is n: string. Notice the colon and space in between.

Examples: (Input --> Output)

[] --> []
["a", "b", "c"] --> ["1: a", "2: b", "3: c"]
```java
public class Task25 {
    public static List<String> numberLines(List<String> lines) {
        List<String> numberedLines = new ArrayList<>();
        for (int i = 0; i < lines.size(); i++) {
            numberedLines.add((i + 1) + ": " + lines.get(i));
        }
        return numberedLines;
    }

    public static void main(String[] args) {
        // Test cases
        System.out.println(numberLines(Arrays.asList())); // []
        System.out.println(numberLines(Arrays.asList("a", "b", "c"))); // ["1: a", "2: b", "3: c"]
        System.out.println(numberLines(Arrays.asList("hello"))); // ["1: hello"]
        System.out.println(numberLines(Arrays.asList("first line", "second line"))); // ["1: first line", "2: second line"]
        System.out.println(numberLines(Arrays.asList("single"))); // ["1: single"]
    }
}
```
```python
def number_lines(lines):
    return [f"{i + 1}: {line}" for i, line in enumerate(lines)]

if __name__ == "__main__":
    # Test cases
    print(number_lines([]))  # []
    print(number_lines(["a", "b", "c"]))  # ["1: a", "2: b", "3: c"]
    print(number_lines(["hello"]))  # ["1: hello"]
    print(number_lines(["first line", "second line"]))  # ["1: first line", "2: second line"]
    print(number_lines(["single"]))  # ["1: single"]
```
```cpp
#include <iostream>
#include <vector>
#include <string>

std::vector<std::string> numberLines(const std::vector<std::string>& lines) {
    std::vector<std::string> numberedLines;
    for (size_t i = 0; i < lines.size(); ++i) {
        numberedLines.push_back(std::to_string(i + 1) + ": " + lines[i]);
    }
    return numberedLines;
}

int main() {
    // Test cases
    auto printVector = [](const std::vector<std::string>& vec) {
        std::cout << "[";
        for (size_t i = 0; i < vec.size(); ++i) {
            std::cout << "\"" << vec[i] << "\"";
            if (i != vec.size() - 1) std::cout << ", ";
        }
        std::cout << "]\n";
    };

    printVector(numberLines({})); // []
    printVector(numberLines({"a", "b", "c"})); // ["1: a", "2: b", "3: c"]
    printVector(numberLines({"hello"})); // ["1: hello"]
    printVector(numberLines({"first line", "second line"})); // ["1: first line", "2: second line"]
    printVector(numberLines({"single"})); // ["1: single"]
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char** numberLines(char* lines[], int size, int* returnSize) {
    char** numberedLines = malloc(size * sizeof(char*));
    for (int i = 0; i < size; i++) {
        int len = snprintf(NULL, 0, "%d: %s", i + 1, lines[i]);
        numberedLines[i] = malloc(len + 1);
        sprintf(numberedLines[i], "%d: %s", i + 1, lines[i]);
    }
    *returnSize = size;
    return numberedLines;
}

void freeNumberedLines(char** lines, int size) {
    for (int i = 0; i < size; i++) {
        free(lines[i]);
    }
    free(lines);
}

void printLines(char* lines[], int size) {
    printf("[");
    for (int i = 0; i < size; i++) {
        printf("\"%s\"", lines[i]);
        if (i != size - 1) printf(", ");
    }
    printf("]\n");
}

int main() {
    // Test cases
    int returnSize;
    char* test1[] = {};
    char* result1[] = numberLines(test1, 0, &returnSize);
    printLines(result1, returnSize);
    freeNumberedLines(result1, returnSize);

    char* test2[] = {"a", "b", "c"};
    char* result2[] = numberLines(test2, 3, &returnSize);
    printLines(result2, returnSize);
    freeNumberedLines(result2, returnSize);

    char* test3[] = {"hello"};
    char* result3[] = numberLines(test3, 1, &returnSize);
    printLines(result3, returnSize);
    freeNumberedLines(result3, returnSize);

    char* test4[] = {"first line", "second line"};
    char* result4[] = numberLines(test4, 2, &returnSize);
    printLines(result4, returnSize);
    freeNumberedLines(result4, returnSize);

    char* test5[] = {"single"};
    char* result5[] = numberLines(test5, 1, &returnSize);
    printLines(result5, returnSize);
    freeNumberedLines(result5, returnSize);

    return 0;
}
```
Created file: Task25.java
Created file: Task25.py
Created file: Task25.cpp
Created file: Task25.c
Task26_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task26, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Given an array of integers, find the one that appears an odd number of times.

There will always be only one integer that appears an odd number of times.

Examples
[7] should return 7, because it occurs 1 time (which is odd).
[0] should return 0, because it occurs 1 time (which is odd).
[1,1,2] should return 2, because it occurs 1 time (which is odd).
[0,1,0,1,0] should return 0, because it occurs 3 times (which is odd).
[1,2,2,3,3,3,4,3,3,3,2,2,1] should return 4, because it appears 1 time (which is odd).
```java
public class Task26 {
    public static int findOddOccurrence(int[] numbers) {
        int result = 0;
        for (int number : numbers) {
            result ^= number;
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(findOddOccurrence(new int[]{7})); // 7
        System.out.println(findOddOccurrence(new int[]{0})); // 0
        System.out.println(findOddOccurrence(new int[]{1, 1, 2})); // 2
        System.out.println(findOddOccurrence(new int[]{0, 1, 0, 1, 0})); // 0
        System.out.println(findOddOccurrence(new int[]{1, 2, 2, 3, 3, 3, 4, 3, 3, 3, 2, 2, 1})); // 4
    }
}
```
```python
def find_odd_occurrence(numbers):
    result = 0
    for number in numbers:
        result ^= number
    return result

if __name__ == "__main__":
    print(find_odd_occurrence([7])) # 7
    print(find_odd_occurrence([0])) # 0
    print(find_odd_occurrence([1, 1, 2])) # 2
    print(find_odd_occurrence([0, 1, 0, 1, 0])) # 0
    print(find_odd_occurrence([1, 2, 2, 3, 3, 3, 4, 3, 3, 3, 2, 2, 1])) # 4
```
```cpp
#include <iostream>
#include <vector>

class Task26 {
public:
    static int findOddOccurrence(const std::vector<int>& numbers) {
        int result = 0;
        for (int number : numbers) {
            result ^= number;
        }
        return result;
    }
};

int main() {
    std::cout << Task26::findOddOccurrence({7}) << std::endl; // 7
    std::cout << Task26::findOddOccurrence({0}) << std::endl; // 0
    std::cout << Task26::findOddOccurrence({1, 1, 2}) << std::endl; // 2
    std::cout << Task26::findOddOccurrence({0, 1, 0, 1, 0}) << std::endl; // 0
    std::cout << Task26::findOddOccurrence({1, 2, 2, 3, 3, 3, 4, 3, 3, 3, 2, 2, 1}) << std::endl; // 4
    return 0;
}
```
```c
#include <stdio.h>

int findOddOccurrence(int* numbers, int size) {
    int result = 0;
    for (int i = 0; i < size; i++) {
        result ^= numbers[i];
    }
    return result;
}

int main() {
    int arr1[] = {7};
    printf("%d\n", findOddOccurrence(arr1, 1)); // 7

    int arr2[] = {0};
    printf("%d\n", findOddOccurrence(arr2, 1)); // 0

    int arr3[] = {1, 1, 2};
    printf("%d\n", findOddOccurrence(arr3, 3)); // 2

    int arr4[] = {0, 1, 0, 1, 0};
    printf("%d\n", findOddOccurrence(arr4, 5)); // 0

    int arr5[] = {1, 2, 2, 3, 3, 3, 4, 3, 3, 3, 2, 2, 1};
    printf("%d\n", findOddOccurrence(arr5, 13)); // 4

    return 0;
}
```
Created file: Task26.java
Created file: Task26.py
Created file: Task26.cpp
Created file: Task26.c
Task27_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task27, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

Examples
[2, 4, 0, 100, 4, 11, 2602, 36] -->  11 (the only odd number)

[160, 3, 1719, 19, 11, 13, -21] --> 160 (the only even number)
```java
public class Task27 {
    public static int findOutlier(int[] arr) {
        int countOdd = 0, countEven = 0, lastOdd = 0, lastEven = 0;

        for (int num : arr) {
            if (num % 2 == 0) {
                countEven++;
                lastEven = num;
            } else {
                countOdd++;
                lastOdd = num;
            }
            if (countOdd > 1 && countEven > 0) return lastEven;
            if (countEven > 1 && countOdd > 0) return lastOdd;
        }
        return 0; // Default return, should not reach here due to constraints.
    }

    public static void main(String[] args) {
        System.out.println(findOutlier(new int[]{2, 4, 0, 100, 4, 11, 2602, 36})); // 11
        System.out.println(findOutlier(new int[]{160, 3, 1719, 19, 11, 13, -21})); // 160
        System.out.println(findOutlier(new int[]{2, 6, 8, 10, 3})); // 3
        System.out.println(findOutlier(new int[]{-9, -5, -7, -3, -6})); // -6
        System.out.println(findOutlier(new int[]{101, 103, 107, 109, 2})); // 2
    }
}
```
```python
def find_outlier(arr):
    count_odd = count_even = 0
    last_odd = last_even = 0

    for num in arr:
        if num % 2 == 0:
            count_even += 1
            last_even = num
        else:
            count_odd += 1
            last_odd = num
        if count_odd > 1 and count_even > 0:
            return last_even
        if count_even > 1 and count_odd > 0:
            return last_odd
    return 0  # Default return, should not reach here due to constraints.

print(find_outlier([2, 4, 0, 100, 4, 11, 2602, 36]))  # 11
print(find_outlier([160, 3, 1719, 19, 11, 13, -21]))  # 160
print(find_outlier([2, 6, 8, 10, 3]))  # 3
print(find_outlier([-9, -5, -7, -3, -6]))  # -6
print(find_outlier([101, 103, 107, 109, 2]))  # 2
```
```cpp
#include <iostream>
#include <vector>

class Task27 {
public:
    static int findOutlier(const std::vector<int>& arr) {
        int countOdd = 0, countEven = 0, lastOdd = 0, lastEven = 0;

        for (int num : arr) {
            if (num % 2 == 0) {
                countEven++;
                lastEven = num;
            } else {
                countOdd++;
                lastOdd = num;
            }
            if (countOdd > 1 && countEven > 0) return lastEven;
            if (countEven > 1 && countOdd > 0) return lastOdd;
        }
        return 0; // Default return, should not reach here due to constraints.
    }
};

int main() {
    std::cout << Task27::findOutlier({2, 4, 0, 100, 4, 11, 2602, 36}) << std::endl; // 11
    std::cout << Task27::findOutlier({160, 3, 1719, 19, 11, 13, -21}) << std::endl; // 160
    std::cout << Task27::findOutlier({2, 6, 8, 10, 3}) << std::endl; // 3
    std::cout << Task27::findOutlier({-9, -5, -7, -3, -6}) << std::endl; // -6
    std::cout << Task27::findOutlier({101, 103, 107, 109, 2}) << std::endl; // 2
    return 0;
}
```
```c
#include <stdio.h>

int findOutlier(const int arr[], int length) {
    int countOdd = 0, countEven = 0, lastOdd = 0, lastEven = 0;

    for (int i = 0; i < length; i++) {
        if (arr[i] % 2 == 0) {
            countEven++;
            lastEven = arr[i];
        } else {
            countOdd++;
            lastOdd = arr[i];
        }
        if (countOdd > 1 && countEven > 0) return lastEven;
        if (countEven > 1 && countOdd > 0) return lastOdd;
    }
    return 0; // Default return, should not reach here due to constraints.
}

int main() {
    int arr1[] = {2, 4, 0, 100, 4, 11, 2602, 36};
    int arr2[] = {160, 3, 1719, 19, 11, 13, -21};
    int arr3[] = {2, 6, 8, 10, 3};
    int arr4[] = {-9, -5, -7, -3, -6};
    int arr5[] = {101, 103, 107, 109, 2};

    printf("%d\n", findOutlier(arr1, 8)); // 11
    printf("%d\n", findOutlier(arr2, 7)); // 160
    printf("%d\n", findOutlier(arr3, 5)); // 3
    printf("%d\n", findOutlier(arr4, 5)); // -6
    printf("%d\n", findOutlier(arr5, 5)); // 2

    return 0;
}
```
Created file: Task27.java
Created file: Task27.py
Created file: Task27.cpp
Created file: Task27.c
Task28_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task28, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You probably know the 'like' system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.

Implement the function which takes an array containing the names of people that like an item. It must return the display text as shown in the examples:

[]                                -->  "no one likes this"
["Peter"]                         -->  "Peter likes this"
["Jacob", "Alex"]                 -->  "Jacob and Alex like this"
["Max", "John", "Mark"]           -->  "Max, John and Mark like this"
["Alex", "Jacob", "Mark", "Max"]  -->  "Alex, Jacob and 2 others like this"
Note: For 4 or more names, the number in "and 2 others" simply increases.
```java
public class Task28 {
    public static void main(String[] args) {
        System.out.println(getLikesText(new String[]{})); // "no one likes this"
        System.out.println(getLikesText(new String[]{"Peter"})); // "Peter likes this"
        System.out.println(getLikesText(new String[]{"Jacob", "Alex"})); // "Jacob and Alex like this"
        System.out.println(getLikesText(new String[]{"Max", "John", "Mark"})); // "Max, John and Mark like this"
        System.out.println(getLikesText(new String[]{"Alex", "Jacob", "Mark", "Max"})); // "Alex, Jacob and 2 others like this"
    }

    public static String getLikesText(String[] names) {
        switch (names.length) {
            case 0: return "no one likes this";
            case 1: return names[0] + " likes this";
            case 2: return names[0] + " and " + names[1] + " like this";
            case 3: return names[0] + ", " + names[1] + " and " + names[2] + " like this";
            default: return names[0] + ", " + names[1] + " and " + (names.length - 2) + " others like this";
        }
    }
}
```
```python
def get_likes_text(names):
    if len(names) == 0:
        return "no one likes this"
    elif len(names) == 1:
        return f"{names[0]} likes this"
    elif len(names) == 2:
        return f"{names[0]} and {names[1]} like this"
    elif len(names) == 3:
        return f"{names[0]}, {names[1]} and {names[2]} like this"
    else:
        return f"{names[0]}, {names[1]} and {len(names) - 2} others like this"

print(get_likes_text([]))  # "no one likes this"
print(get_likes_text(["Peter"]))  # "Peter likes this"
print(get_likes_text(["Jacob", "Alex"]))  # "Jacob and Alex like this"
print(get_likes_text(["Max", "John", "Mark"]))  # "Max, John and Mark like this"
print(get_likes_text(["Alex", "Jacob", "Mark", "Max"]))  # "Alex, Jacob and 2 others like this"
```
```cpp
#include <iostream>
#include <vector>
#include <string>

std::string getLikesText(const std::vector<std::string>& names) {
    switch (names.size()) {
        case 0: return "no one likes this";
        case 1: return names[0] + " likes this";
        case 2: return names[0] + " and " + names[1] + " like this";
        case 3: return names[0] + ", " + names[1] + " and " + names[2] + " like this";
        default: return names[0] + ", " + names[1] + " and " + std::to_string(names.size() - 2) + " others like this";
    }
}

int main() {
    std::cout << getLikesText({}) << std::endl; // "no one likes this"
    std::cout << getLikesText({"Peter"}) << std::endl; // "Peter likes this"
    std::cout << getLikesText({"Jacob", "Alex"}) << std::endl; // "Jacob and Alex like this"
    std::cout << getLikesText({"Max", "John", "Mark"}) << std::endl; // "Max, John and Mark like this"
    std::cout << getLikesText({"Alex", "Jacob", "Mark", "Max"}) << std::endl; // "Alex, Jacob and 2 others like this"
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

void getLikesText(char *result, char *names[], int size) {
    switch (size) {
        case 0: strcpy(result, "no one likes this"); break;
        case 1: sprintf(result, "%s likes this", names[0]); break;
        case 2: sprintf(result, "%s and %s like this", names[0], names[1]); break;
        case 3: sprintf(result, "%s, %s and %s like this", names[0], names[1], names[2]); break;
        default: sprintf(result, "%s, %s and %d others like this", names[0], names[1], size - 2); break;
    }
}

int main() {
    char result[100];
    char *names1[] = {};
    getLikesText(result, names1, 0);
    printf("%s\n", result); // "no one likes this"

    char *names2[] = {"Peter"};
    getLikesText(result, names2, 1);
    printf("%s\n", result); // "Peter likes this"

    char *names3[] = {"Jacob", "Alex"};
    getLikesText(result, names3, 2);
    printf("%s\n", result); // "Jacob and Alex like this"

    char *names4[] = {"Max", "John", "Mark"};
    getLikesText(result, names4, 3);
    printf("%s\n", result); // "Max, John and Mark like this"

    char *names5[] = {"Alex", "Jacob", "Mark", "Max"};
    getLikesText(result, names5, 4);
    printf("%s\n", result); // "Alex, Jacob and 2 others like this"

    return 0;
}
```
Created file: Task28.java
Created file: Task28.py
Created file: Task28.cpp
Created file: Task28.c
Task29_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task29, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a function that takes an array of numbers (integers for the tests) and a target number. It should find two different items in the array that, when added together, give the target value. The indices of these items should then be returned in a tuple / list (depending on your language) like so: (index1, index2).

For the purposes of this kata, some tests may have multiple answers; any valid solutions will be accepted.

The input will always be valid (numbers will be an array of length 2 or greater, and all of the items will be numbers; target will always be the sum of two different items from that array).

two_sum([1, 2, 3], 4) == {0, 2}
two_sum([3, 2, 4], 6) == {1, 2}
```java
import java.util.HashMap;
import java.util.Map;

public class Task29 {
    public static int[] twoSum(int[] numbers, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        for (int i = 0; i < numbers.length; i++) {
            int complement = target - numbers[i];
            if (numMap.containsKey(complement)) {
                return new int[]{numMap.get(complement), i};
            }
            numMap.put(numbers[i], i);
        }
        return null;
    }

    public static void main(String[] args) {
        int[] result1 = twoSum(new int[]{1, 2, 3}, 4);
        int[] result2 = twoSum(new int[]{3, 2, 4}, 6);
        int[] result3 = twoSum(new int[]{2, 7, 11, 15}, 9);
        int[] result4 = twoSum(new int[]{1, 5, 5, 2}, 10);
        int[] result5 = twoSum(new int[]{0, 4, 3, 0}, 0);

        System.out.println("[" + result1[0] + ", " + result1[1] + "]");
        System.out.println("[" + result2[0] + ", " + result2[1] + "]");
        System.out.println("[" + result3[0] + ", " + result3[1] + "]");
        System.out.println("[" + result4[0] + ", " + result4[1] + "]");
        System.out.println("[" + result5[0] + ", " + result5[1] + "]");
    }
}
```
```python
def two_sum(numbers, target):
    num_map = {}
    for index, num in enumerate(numbers):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], index]
        num_map[num] = index
    return None

def main():
    result1 = two_sum([1, 2, 3], 4)
    result2 = two_sum([3, 2, 4], 6)
    result3 = two_sum([2, 7, 11, 15], 9)
    result4 = two_sum([1, 5, 5, 2], 10)
    result5 = two_sum([0, 4, 3, 0], 0)

    print(result1)
    print(result2)
    print(result3)
    print(result4)
    print(result5)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

vector<int> twoSum(const vector<int>& numbers, int target) {
    unordered_map<int, int> numMap;
    for (int i = 0; i < numbers.size(); ++i) {
        int complement = target - numbers[i];
        if (numMap.find(complement) != numMap.end()) {
            return {numMap[complement], i};
        }
        numMap[numbers[i]] = i;
    }
    return {};
}

int main() {
    vector<int> result1 = twoSum({1, 2, 3}, 4);
    vector<int> result2 = twoSum({3, 2, 4}, 6);
    vector<int> result3 = twoSum({2, 7, 11, 15}, 9);
    vector<int> result4 = twoSum({1, 5, 5, 2}, 10);
    vector<int> result5 = twoSum({0, 4, 3, 0}, 0);

    cout << "[" << result1[0] << ", " << result1[1] << "]" << endl;
    cout << "[" << result2[0] << ", " << result2[1] << "]" << endl;
    cout << "[" << result3[0] << ", " << result3[1] << "]" << endl;
    cout << "[" << result4[0] << ", " << result4[1] << "]" << endl;
    cout << "[" << result5[0] << ", " << result5[1] << "]" << endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int* twoSum(const int* numbers, int size, int target) {
    for (int i = 0; i < size; ++i) {
        for (int j = i + 1; j < size; ++j) {
            if (numbers[i] + numbers[j] == target) {
                int* result = (int*)malloc(2 * sizeof(int));
                result[0] = i;
                result[1] = j;
                return result;
            }
        }
    }
    return NULL;
}

int main() {
    int numbers1[] = {1, 2, 3};
    int numbers2[] = {3, 2, 4};
    int numbers3[] = {2, 7, 11, 15};
    int numbers4[] = {1, 5, 5, 2};
    int numbers5[] = {0, 4, 3, 0};

    int* result1 = twoSum(numbers1, 3, 4);
    int* result2 = twoSum(numbers2, 3, 6);
    int* result3 = twoSum(numbers3, 4, 9);
    int* result4 = twoSum(numbers4, 4, 10);
    int* result5 = twoSum(numbers5, 4, 0);

    printf("[%d, %d]\n", result1[0], result1[1]);
    printf("[%d, %d]\n", result2[0], result2[1]);
    printf("[%d, %d]\n", result3[0], result3[1]);
    printf("[%d, %d]\n", result4[0], result4[1]);
    printf("[%d, %d]\n", result5[0], result5[1]);

    free(result1);
    free(result2);
    free(result3);
    free(result4);
    free(result5);

    return 0;
}
```
Created file: Task29.java
Created file: Task29.py
Created file: Task29.cpp
Created file: Task29.c
Task30_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task30, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Take 2 strings s1 and s2 including only letters from a to z. Return a new sorted string, the longest possible, containing distinct letters - each taken only once - coming from s1 or s2.

Examples:
a = "xyaabbbccccdefww"
b = "xxxxyyyyabklmopq"
longest(a, b) -> "abcdefklmopqwxy"

a = "abcdefghijklmnopqrstuvwxyz"
longest(a, a) -> "abcdefghijklmnopqrstuvwxyz"
```java
public class Task30 {
    public static String longest(String s1, String s2) {
        String combined = s1 + s2;
        return combined.chars()
                .distinct()
                .sorted()
                .collect(StringBuilder::new,
                         StringBuilder::appendCodePoint,
                         StringBuilder::append)
                .toString();
    }

    public static void main(String[] args) {
        System.out.println(longest("xyaabbbccccdefww", "xxxxyyyyabklmopq"));
        System.out.println(longest("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz"));
        System.out.println(longest("aabbcc", "abc"));
        System.out.println(longest("abc", "def"));
        System.out.println(longest("zxy", "yxz"));
    }
}
```
```python
def longest(s1, s2):
    return ''.join(sorted(set(s1 + s2)))

if __name__ == "__main__":
    print(longest("xyaabbbccccdefww", "xxxxyyyyabklmopq"))
    print(longest("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz"))
    print(longest("aabbcc", "abc"))
    print(longest("abc", "def"))
    print(longest("zxy", "yxz"))
```
```cpp
#include <iostream>
#include <set>
#include <algorithm>

std::string longest(const std::string& s1, const std::string& s2) {
    std::set<char> charSet(s1.begin(), s1.end());
    charSet.insert(s2.begin(), s2.end());
    return std::string(charSet.begin(), charSet.end());
}

int main() {
    std::cout << longest("xyaabbbccccdefww", "xxxxyyyyabklmopq") << std::endl;
    std::cout << longest("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz") << std::endl;
    std::cout << longest("aabbcc", "abc") << std::endl;
    std::cout << longest("abc", "def") << std::endl;
    std::cout << longest("zxy", "yxz") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

void longest(const char *s1, const char *s2, char *result) {
    bool seen[26] = {false};
    int index = 0;

    for (int i = 0; s1[i] != '\0'; i++) {
        if (!seen[s1[i] - 'a']) {
            seen[s1[i] - 'a'] = true;
            result[index++] = s1[i];
        }
    }

    for (int i = 0; s2[i] != '\0'; i++) {
        if (!seen[s2[i] - 'a']) {
            seen[s2[i] - 'a'] = true;
            result[index++] = s2[i];
        }
    }

    result[index] = '\0';
    int n = strlen(result);
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (result[j] > result[j + 1]) {
                char temp = result[j];
                result[j] = result[j + 1];
                result[j + 1] = temp;
            }
        }
    }
}

int main() {
    char result[27];

    longest("xyaabbbccccdefww", "xxxxyyyyabklmopq", result);
    printf("%s\n", result);

    longest("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz", result);
    printf("%s\n", result);

    longest("aabbcc", "abc", result);
    printf("%s\n", result);

    longest("abc", "def", result);
    printf("%s\n", result);

    longest("zxy", "yxz", result);
    printf("%s\n", result);

    return 0;
}
```
Created file: Task30.java
Created file: Task30.py
Created file: Task30.cpp
Created file: Task30.c
Task31_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task31, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Deoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the "instructions" for the development and functioning of living organisms.

If you want to know more: http://en.wikipedia.org/wiki/DNA

In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". Your function receives one side of the DNA (string, except for Haskell); you need to return the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

Example: (input --> output)

"ATTGC" --> "TAACG"
"GTAT" --> "CATA"
```java
public class Task31 {
    public static String makeComplement(String dna) {
        StringBuilder complement = new StringBuilder();
        for (char nucleotide : dna.toCharArray()) {
            switch (nucleotide) {
                case 'A':
                    complement.append('T');
                    break;
                case 'T':
                    complement.append('A');
                    break;
                case 'C':
                    complement.append('G');
                    break;
                case 'G':
                    complement.append('C');
                    break;
                default:
                    throw new IllegalArgumentException("Invalid DNA nucleotide");
            }
        }
        return complement.toString();
    }

    public static void main(String[] args) {
        System.out.println(makeComplement("ATTGC")); // TAACG
        System.out.println(makeComplement("GTAT"));  // CATA
        System.out.println(makeComplement("AAAA"));  // TTTT
        System.out.println(makeComplement("CGCG"));  // GCGC
        System.out.println(makeComplement("ATGC"));  // TACG
    }
}
```
```python
def make_complement(dna):
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    return ''.join(complement[nucleotide] for nucleotide in dna)

if __name__ == "__main__":
    print(make_complement("ATTGC"))  # TAACG
    print(make_complement("GTAT"))   # CATA
    print(make_complement("AAAA"))   # TTTT
    print(make_complement("CGCG"))   # GCGC
    print(make_complement("ATGC"))   # TACG
```
```cpp
#include <iostream>
#include <string>

std::string makeComplement(const std::string &dna) {
    std::string complement;
    for (char nucleotide : dna) {
        switch (nucleotide) {
            case 'A':
                complement += 'T';
                break;
            case 'T':
                complement += 'A';
                break;
            case 'C':
                complement += 'G';
                break;
            case 'G':
                complement += 'C';
                break;
            default:
                throw std::invalid_argument("Invalid DNA nucleotide");
        }
    }
    return complement;
}

int main() {
    std::cout << makeComplement("ATTGC") << std::endl; // TAACG
    std::cout << makeComplement("GTAT") << std::endl;  // CATA
    std::cout << makeComplement("AAAA") << std::endl;  // TTTT
    std::cout << makeComplement("CGCG") << std::endl;  // GCGC
    std::cout << makeComplement("ATGC") << std::endl;  // TACG
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* makeComplement(const char* dna) {
    size_t length = strlen(dna);
    char* complement = (char*)malloc(length + 1);
    if (!complement) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }

    for (size_t i = 0; i < length; ++i) {
        switch (dna[i]) {
            case 'A':
                complement[i] = 'T';
                break;
            case 'T':
                complement[i] = 'A';
                break;
            case 'C':
                complement[i] = 'G';
                break;
            case 'G':
                complement[i] = 'C';
                break;
            default:
                fprintf(stderr, "Invalid DNA nucleotide\n");
                free(complement);
                exit(1);
        }
    }
    complement[length] = '\0';
    return complement;
}

int main() {
    char* result;

    result = makeComplement("ATTGC");
    printf("%s\n", result); // TAACG
    free(result);

    result = makeComplement("GTAT");
    printf("%s\n", result); // CATA
    free(result);

    result = makeComplement("AAAA");
    printf("%s\n", result); // TTTT
    free(result);

    result = makeComplement("CGCG");
    printf("%s\n", result); // GCGC
    free(result);

    result = makeComplement("ATGC");
    printf("%s\n", result); // TACG
    free(result);

    return 0;
}
```
Created file: Task31.java
Created file: Task31.py
Created file: Task31.cpp
Created file: Task31.c
Task32_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task32, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Mr. Scrooge has a sum of money 'P' that he wants to invest. Before he does, he wants to know how many years 'Y' this sum 'P' has to be kept in the bank in order for it to amount to a desired sum of money 'D'.

The sum is kept for 'Y' years in the bank where interest 'I' is paid yearly. After paying taxes 'T' for the year the new sum is re-invested.

Note to Tax: not the invested principal is taxed, but only the year's accrued interest

Example:

  Let P be the Principal = 1000.00
  Let I be the Interest Rate = 0.05
  Let T be the Tax Rate = 0.18
  Let D be the Desired Sum = 1100.00


After 1st Year -->
  P = 1041.00
After 2nd Year -->
  P = 1083.86
After 3rd Year -->
  P = 1128.30
Thus Mr. Scrooge has to wait for 3 years for the initial principal to amount to the desired sum.

Your task is to complete the method provided and return the number of years 'Y' as a whole in order for Mr. Scrooge to get the desired sum.

Assumption: Assume that Desired Principal 'D' is always greater than the initial principal. However it is best to take into consideration that if Desired Principal 'D' is equal to Principal 'P' this should return 0 Years.
```java
public class Task32 {
    public static int calculateYears(double principal, double interest, double tax, double desired) {
        int years = 0;
        while (principal < desired) {
            double accruedInterest = principal * interest;
            double taxedInterest = accruedInterest * (1 - tax);
            principal += taxedInterest;
            years++;
        }
        return years;
    }

    public static void main(String[] args) {
        System.out.println(calculateYears(1000.00, 0.05, 0.18, 1100.00)); // 3
        System.out.println(calculateYears(1000.00, 0.05, 0.18, 1200.00)); // 6
        System.out.println(calculateYears(1000.00, 0.05, 0.18, 1300.00)); // 9
        System.out.println(calculateYears(1000.00, 0.05, 0.18, 1000.00)); // 0
        System.out.println(calculateYears(1500.00, 0.05, 0.18, 1600.00)); // 3
    }
}
```
```python
def calculate_years(principal, interest, tax, desired):
    years = 0
    while principal < desired:
        accrued_interest = principal * interest
        taxed_interest = accrued_interest * (1 - tax)
        principal += taxed_interest
        years += 1
    return years

if __name__ == "__main__":
    print(calculate_years(1000.00, 0.05, 0.18, 1100.00)) # 3
    print(calculate_years(1000.00, 0.05, 0.18, 1200.00)) # 6
    print(calculate_years(1000.00, 0.05, 0.18, 1300.00)) # 9
    print(calculate_years(1000.00, 0.05, 0.18, 1000.00)) # 0
    print(calculate_years(1500.00, 0.05, 0.18, 1600.00)) # 3
```
```cpp
#include <iostream>
using namespace std;

int calculateYears(double principal, double interest, double tax, double desired) {
    int years = 0;
    while (principal < desired) {
        double accruedInterest = principal * interest;
        double taxedInterest = accruedInterest * (1 - tax);
        principal += taxedInterest;
        years++;
    }
    return years;
}

int main() {
    cout << calculateYears(1000.00, 0.05, 0.18, 1100.00) << endl; // 3
    cout << calculateYears(1000.00, 0.05, 0.18, 1200.00) << endl; // 6
    cout << calculateYears(1000.00, 0.05, 0.18, 1300.00) << endl; // 9
    cout << calculateYears(1000.00, 0.05, 0.18, 1000.00) << endl; // 0
    cout << calculateYears(1500.00, 0.05, 0.18, 1600.00) << endl; // 3
    return 0;
}
```
```c
#include <stdio.h>

int calculateYears(double principal, double interest, double tax, double desired) {
    int years = 0;
    while (principal < desired) {
        double accruedInterest = principal * interest;
        double taxedInterest = accruedInterest * (1 - tax);
        principal += taxedInterest;
        years++;
    }
    return years;
}

int main() {
    printf("%d\n", calculateYears(1000.00, 0.05, 0.18, 1100.00)); // 3
    printf("%d\n", calculateYears(1000.00, 0.05, 0.18, 1200.00)); // 6
    printf("%d\n", calculateYears(1000.00, 0.05, 0.18, 1300.00)); // 9
    printf("%d\n", calculateYears(1000.00, 0.05, 0.18, 1000.00)); // 0
    printf("%d\n", calculateYears(1500.00, 0.05, 0.18, 1600.00)); // 3
    return 0;
}
```
Created file: Task32.java
Created file: Task32.py
Created file: Task32.cpp
Created file: Task32.c
Task33_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task33, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
There is a queue for the self-checkout tills at the supermarket. Your task is write a function to calculate the total time required for all the customers to check out!

input
customers: an array of positive integers representing the queue. Each integer represents a customer, and its value is the amount of time they require to check out.
n: a positive integer, the number of checkout tills.
output
The function should return an integer, the total time required.

Important
Please look at the examples and clarifications below, to ensure you understand the task correctly :)

Examples
queueTime([5,3,4], 1)
// should return 12
// because when there is 1 till, the total time is just the sum of the times

queueTime([10,2,3,3], 2)
// should return 10
// because here n=2 and the 2nd, 3rd, and 4th people in the
// queue finish before the 1st person has finished.

queueTime([2,3,10], 2)
// should return 12
Clarifications
There is only ONE queue serving many tills, and
The order of the queue NEVER changes, and
The front person in the queue (i.e. the first element in the array/list) proceeds to a till as soon as it becomes free.
N.B. You should assume that all the test input will be valid, as specified above.

P.S. The situation in this kata can be likened to the more-computer-science-related idea of a thread pool, with relation to running multiple processes at the same time
```java
import java.util.Arrays;

public class Task33 {

    public static int queueTime(int[] customers, int n) {
        int[] tills = new int[n];
        for (int time : customers) {
            int index = 0;
            for (int i = 1; i < n; i++) {
                if (tills[i] < tills[index]) {
                    index = i;
                }
            }
            tills[index] += time;
        }
        return Arrays.stream(tills).max().orElse(0);
    }

    public static void main(String[] args) {
        System.out.println(queueTime(new int[]{5, 3, 4}, 1)); // 12
        System.out.println(queueTime(new int[]{10, 2, 3, 3}, 2)); // 10
        System.out.println(queueTime(new int[]{2, 3, 10}, 2)); // 12
        System.out.println(queueTime(new int[]{1, 2, 3, 4, 5}, 3)); // 5
        System.out.println(queueTime(new int[]{}, 1)); // 0
    }
}
```
```python
def queue_time(customers, n):
    tills = [0] * n
    for time in customers:
        tills[tills.index(min(tills))] += time
    return max(tills)

if __name__ == "__main__":
    print(queue_time([5, 3, 4], 1))  # 12
    print(queue_time([10, 2, 3, 3], 2))  # 10
    print(queue_time([2, 3, 10], 2))  # 12
    print(queue_time([1, 2, 3, 4, 5], 3))  # 5
    print(queue_time([], 1))  # 0
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Task33 {
public:
    static int queueTime(const std::vector<int>& customers, int n) {
        std::vector<int> tills(n, 0);
        for (int time : customers) {
            *std::min_element(tills.begin(), tills.end()) += time;
        }
        return *std::max_element(tills.begin(), tills.end());
    }
};

int main() {
    std::cout << Task33::queueTime({5, 3, 4}, 1) << std::endl; // 12
    std::cout << Task33::queueTime({10, 2, 3, 3}, 2) << std::endl; // 10
    std::cout << Task33::queueTime({2, 3, 10}, 2) << std::endl; // 12
    std::cout << Task33::queueTime({1, 2, 3, 4, 5}, 3) << std::endl; // 5
    std::cout << Task33::queueTime({}, 1) << std::endl; // 0
    return 0;
}
```
```c
#include <stdio.h>
#include <limits.h>

int queueTime(const int* customers, int size, int n) {
    int tills[n];
    for (int i = 0; i < n; ++i) {
        tills[i] = 0;
    }
    for (int i = 0; i < size; ++i) {
        int minIndex = 0;
        for (int j = 1; j < n; ++j) {
            if (tills[j] < tills[minIndex]) {
                minIndex = j;
            }
        }
        tills[minIndex] += customers[i];
    }
    int maxTime = 0;
    for (int i = 0; i < n; ++i) {
        if (tills[i] > maxTime) {
            maxTime = tills[i];
        }
    }
    return maxTime;
}

int main() {
    int customers1[] = {5, 3, 4};
    printf("%d\n", queueTime(customers1, 3, 1)); // 12
    int customers2[] = {10, 2, 3, 3};
    printf("%d\n", queueTime(customers2, 4, 2)); // 10
    int customers3[] = {2, 3, 10};
    printf("%d\n", queueTime(customers3, 3, 2)); // 12
    int customers4[] = {1, 2, 3, 4, 5};
    printf("%d\n", queueTime(customers4, 5, 3)); // 5
    int customers5[] = {};
    printf("%d\n", queueTime(customers5, 0, 1)); // 0
    return 0;
}
```
Created file: Task33.java
Created file: Task33.py
Created file: Task33.cpp
Created file: Task33.c
Task34_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task34, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
A Narcissistic Number (or Armstrong Number) is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits), which is narcissistic:

    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1652 (4 digits), which isn't:

    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
The Challenge:

Your code must return true or false (not 'true' and 'false') depending upon whether the given number is a Narcissistic number in base 10.

This may be True and False in your language, e.g. PHP.

Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.
```java
public class Task34 {
    public static boolean isNarcissistic(int number) {
        int originalNumber = number;
        int sum = 0;
        int numDigits = String.valueOf(number).length();
        while (number > 0) {
            int digit = number % 10;
            sum += Math.pow(digit, numDigits);
            number /= 10;
        }
        return sum == originalNumber;
    }

    public static void main(String[] args) {
        System.out.println(isNarcissistic(153)); // true
        System.out.println(isNarcissistic(1652)); // false
        System.out.println(isNarcissistic(370)); // true
        System.out.println(isNarcissistic(9474)); // true
        System.out.println(isNarcissistic(9475)); // false
    }
}
```
```python
def is_narcissistic(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

if __name__ == "__main__":
    print(is_narcissistic(153))  # True
    print(is_narcissistic(1652)) # False
    print(is_narcissistic(370))  # True
    print(is_narcissistic(9474)) # True
    print(is_narcissistic(9475)) # False
```
```cpp
#include <iostream>
#include <cmath>
using namespace std;

bool isNarcissistic(int number) {
    int originalNumber = number;
    int sum = 0;
    int numDigits = to_string(number).length();
    while (number > 0) {
        int digit = number % 10;
        sum += pow(digit, numDigits);
        number /= 10;
    }
    return sum == originalNumber;
}

int main() {
    cout << isNarcissistic(153) << endl; // true
    cout << isNarcissistic(1652) << endl; // false
    cout << isNarcissistic(370) << endl; // true
    cout << isNarcissistic(9474) << endl; // true
    cout << isNarcissistic(9475) << endl; // false
    return 0;
}
```
```c
#include <stdio.h>
#include <math.h>
#include <string.h>

int isNarcissistic(int number) {
    int originalNumber = number;
    int sum = 0;
    int numDigits = (int)log10(number) + 1;
    while (number > 0) {
        int digit = number % 10;
        sum += pow(digit, numDigits);
        number /= 10;
    }
    return sum == originalNumber;
}

int main() {
    printf("%d\n", isNarcissistic(153)); // true
    printf("%d\n", isNarcissistic(1652)); // false
    printf("%d\n", isNarcissistic(370)); // true
    printf("%d\n", isNarcissistic(9474)); // true
    printf("%d\n", isNarcissistic(9475)); // false
    return 0;
}
```
Created file: Task34.java
Created file: Task34.py
Created file: Task34.cpp
Created file: Task34.c
Task35_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task35, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
There is a bus moving in the city which takes and drops some people at each bus stop.

You are provided with a list (or array) of integer pairs. Elements of each pair represent the number of people that get on the bus (the first item) and the number of people that get off the bus (the second item) at a bus stop.

Your task is to return the number of people who are still on the bus after the last bus stop (after the last array). Even though it is the last bus stop, the bus might not be empty and some people might still be inside the bus, they are probably sleeping there :D

Take a look on the test cases.

Please keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the returned integer can't be negative.

The second value in the first pair in the array is 0, since the bus is empty in the first bus stop.
```java
public class Task35 {

    public static int numberOfPeople(int[][] busStops) {
        int peopleOnBus = 0;
        for (int[] stop : busStops) {
            peopleOnBus += stop[0]; // People getting on
            peopleOnBus -= stop[1]; // People getting off
        }
        return peopleOnBus;
    }

    public static void main(String[] args) {
        System.out.println(numberOfPeople(new int[][]{{3, 0}, {2, 1}, {5, 2}, {0, 3}, {4, 4}})); // 4
        System.out.println(numberOfPeople(new int[][]{{10, 0}, {3, 5}, {2, 3}, {5, 8}})); // 4
        System.out.println(numberOfPeople(new int[][]{{7, 0}, {0, 7}, {5, 5}, {2, 2}})); // 2
        System.out.println(numberOfPeople(new int[][]{{1, 0}, {1, 0}, {1, 1}, {1, 1}})); // 1
        System.out.println(numberOfPeople(new int[][]{{0, 0}, {5, 0}, {3, 2}, {0, 3}})); // 3
    }
}
```
```python
def number_of_people(bus_stops):
    people_on_bus = 0
    for on, off in bus_stops:
        people_on_bus += on
        people_on_bus -= off
    return people_on_bus

if __name__ == "__main__":
    print(number_of_people([(3, 0), (2, 1), (5, 2), (0, 3), (4, 4)]))  # 4
    print(number_of_people([(10, 0), (3, 5), (2, 3), (5, 8)]))  # 4
    print(number_of_people([(7, 0), (0, 7), (5, 5), (2, 2)]))  # 2
    print(number_of_people([(1, 0), (1, 0), (1, 1), (1, 1)]))  # 1
    print(number_of_people([(0, 0), (5, 0), (3, 2), (0, 3)]))  # 3
```
```cpp
#include <iostream>
#include <vector>

class Task35 {
public:
    static int numberOfPeople(const std::vector<std::pair<int, int>>& busStops) {
        int peopleOnBus = 0;
        for (const auto& stop : busStops) {
            peopleOnBus += stop.first;  // People getting on
            peopleOnBus -= stop.second; // People getting off
        }
        return peopleOnBus;
    }
};

int main() {
    std::cout << Task35::numberOfPeople({{3, 0}, {2, 1}, {5, 2}, {0, 3}, {4, 4}}) << std::endl; // 4
    std::cout << Task35::numberOfPeople({{10, 0}, {3, 5}, {2, 3}, {5, 8}}) << std::endl; // 4
    std::cout << Task35::numberOfPeople({{7, 0}, {0, 7}, {5, 5}, {2, 2}}) << std::endl; // 2
    std::cout << Task35::numberOfPeople({{1, 0}, {1, 0}, {1, 1}, {1, 1}}) << std::endl; // 1
    std::cout << Task35::numberOfPeople({{0, 0}, {5, 0}, {3, 2}, {0, 3}}) << std::endl; // 3
    return 0;
}
```
```c
#include <stdio.h>

int numberOfPeople(int busStops[][2], int size) {
    int peopleOnBus = 0;
    for (int i = 0; i < size; i++) {
        peopleOnBus += busStops[i][0]; // People getting on
        peopleOnBus -= busStops[i][1]; // People getting off
    }
    return peopleOnBus;
}

int main() {
    int busStops1[][2] = {{3, 0}, {2, 1}, {5, 2}, {0, 3}, {4, 4}};
    int busStops2[][2] = {{10, 0}, {3, 5}, {2, 3}, {5, 8}};
    int busStops3[][2] = {{7, 0}, {0, 7}, {5, 5}, {2, 2}};
    int busStops4[][2] = {{1, 0}, {1, 0}, {1, 1}, {1, 1}};
    int busStops5[][2] = {{0, 0}, {5, 0}, {3, 2}, {0, 3}};

    printf("%d\n", numberOfPeople(busStops1, 5)); // 4
    printf("%d\n", numberOfPeople(busStops2, 4)); // 4
    printf("%d\n", numberOfPeople(busStops3, 4)); // 2
    printf("%d\n", numberOfPeople(busStops4, 4)); // 1
    printf("%d\n", numberOfPeople(busStops5, 4)); // 3

    return 0;
}
```
Created file: Task35.java
Created file: Task35.py
Created file: Task35.cpp
Created file: Task35.c
Task36_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task36, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that reads a file specified by the user and prints its contents to the console.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;

public class Task36 {
    public static String readFileContents(String fileName) {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        } catch (IOException e) {
            return "An error occurred: " + e.getMessage();
        }
        return content.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the filename to read: ");
        String fileName = scanner.nextLine();

        System.out.println(readFileContents(fileName));
    }
}
```
```python
import os

def read_file_contents(file_name):
    if not os.path.exists(file_name):
        return "File does not exist."

    try:
        with open(file_name, 'r') as file:
            return file.read()
    except Exception as e:
        return f"An error occurred: {str(e)}"

if __name__ == "__main__":
    file_name = input("Enter the filename to read: ")
    print(read_file_contents(file_name))
```
```cpp
#include <iostream>
#include <fstream>
#include <string>

std::string readFileContents(const std::string& fileName) {
    std::ifstream file(fileName);
    if (!file.is_open()) {
        return "File does not exist or could not be opened.";
    }

    std::string content, line;
    while (std::getline(file, line)) {
        content += line + "\n";
    }

    file.close();
    return content;
}

int main() {
    std::string fileName;
    std::cout << "Enter the filename to read: ";
    std::getline(std::cin, fileName);

    std::cout << readFileContents(fileName);
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

char* readFileContents(const char* fileName) {
    FILE *file = fopen(fileName, "r");
    if (file == NULL) {
        return "File does not exist or could not be opened.";
    }

    fseek(file, 0, SEEK_END);
    long fsize = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *content = malloc(fsize + 1);
    if (content == NULL) {
        fclose(file);
        return "Memory allocation failed.";
    }

    fread(content, 1, fsize, file);
    fclose(file);

    content[fsize] = '\0';
    return content;
}

int main() {
    char fileName[256];
    printf("Enter the filename to read: ");
    if (fgets(fileName, sizeof(fileName), stdin)) {
        fileName[strcspn(fileName, "\n")] = '\0';  // Remove newline character
    }

    char* content = readFileContents(fileName);
    printf("%s", content);

    if (content != "File does not exist or could not be opened." &&
        content != "Memory allocation failed.") {
        free(content);
    }

    return 0;
}
```
Created file: Task36.java
Created file: Task36.py
Created file: Task36.cpp
Created file: Task36.c
Task37_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task37, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that connects to a SQL database and executes a query to retrieve user information based on a username provided by the user.
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class Task37 {
    private static final String DB_URL = "jdbc:mysql://localhost:3306/your_database";
    private static final String USER = "your_username";
    private static final String PASS = "your_password";

    public static String getUserInfo(String username) {
        String result = "";
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
            String query = "SELECT * FROM users WHERE username = ?";
            try (PreparedStatement stmt = conn.prepareStatement(query)) {
                stmt.setString(1, username);
                ResultSet rs = stmt.executeQuery();
                while (rs.next()) {
                    result = rs.getString("info");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(getUserInfo("alice"));
        System.out.println(getUserInfo("bob"));
        System.out.println(getUserInfo("charlie"));
        System.out.println(getUserInfo("david"));
        System.out.println(getUserInfo("eve"));
    }
}
```
```python
import mysql.connector
from mysql.connector import Error

def get_user_info(username):
    try:
        connection = mysql.connector.connect(
            host='localhost',
            database='your_database',
            user='your_username',
            password='your_password'
        )
        if connection.is_connected():
            cursor = connection.cursor(prepared=True)
            query = "SELECT * FROM users WHERE username = %s"
            cursor.execute(query, (username,))
            records = cursor.fetchall()
            return records
    except Error as e:
        print(e)
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

def main():
    print(get_user_info("alice"))
    print(get_user_info("bob"))
    print(get_user_info("charlie"))
    print(get_user_info("david"))
    print(get_user_info("eve"))

main()
```
```cpp
#include <iostream>
#include <string>
#include <mysql/mysql.h>

std::string getUserInfo(const std::string& username) {
    MYSQL* conn;
    MYSQL_RES* res;
    MYSQL_ROW row;
    std::string result = "";

    conn = mysql_init(NULL);
    if (conn == NULL) {
        std::cerr << mysql_error(conn) << std::endl;
        return result;
    }

    if (mysql_real_connect(conn, "localhost", "your_username", "your_password",
        "your_database", 0, NULL, 0) == NULL) {
        std::cerr << mysql_error(conn) << std::endl;
        mysql_close(conn);
        return result;
    }

    std::string query = "SELECT * FROM users WHERE username = ?";
    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        std::cerr << mysql_error(conn) << std::endl;
        mysql_close(conn);
        return result;
    }

    if (mysql_stmt_prepare(stmt, query.c_str(), query.length())) {
        std::cerr << mysql_stmt_error(stmt) << std::endl;
        mysql_stmt_close(stmt);
        mysql_close(conn);
        return result;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (char*)username.c_str();
    bind[0].buffer_length = username.length();

    if (mysql_stmt_bind_param(stmt, bind)) {
        std::cerr << mysql_stmt_error(stmt) << std::endl;
        mysql_stmt_close(stmt);
        mysql_close(conn);
        return result;
    }

    if (mysql_stmt_execute(stmt)) {
        std::cerr << mysql_stmt_error(stmt) << std::endl;
        mysql_stmt_close(stmt);
        mysql_close(conn);
        return result;
    }

    res = mysql_store_result(conn);
    if (res == NULL) {
        std::cerr << mysql_error(conn) << std::endl;
        mysql_stmt_close(stmt);
        mysql_close(conn);
        return result;
    }

    while ((row = mysql_fetch_row(res))) {
        result = row[0];
    }

    mysql_free_result(res);
    mysql_stmt_close(stmt);
    mysql_close(conn);

    return result;
}

int main() {
    std::cout << getUserInfo("alice") << std::endl;
    std::cout << getUserInfo("bob") << std::endl;
    std::cout << getUserInfo("charlie") << std::endl;
    std::cout << getUserInfo("david") << std::endl;
    std::cout << getUserInfo("eve") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <mysql/mysql.h>

void getUserInfo(const char* username) {
    MYSQL *conn;
    MYSQL_RES *res;
    MYSQL_ROW row;

    conn = mysql_init(NULL);
    if (conn == NULL) {
        fprintf(stderr, "%s\n", mysql_error(conn));
        return;
    }

    if (mysql_real_connect(conn, "localhost", "your_username", "your_password",
                           "your_database", 0, NULL, 0) == NULL) {
        fprintf(stderr, "%s\n", mysql_error(conn));
        mysql_close(conn);
        return;
    }

    char query[256];
    snprintf(query, sizeof(query), "SELECT * FROM users WHERE username = '%s'", username);

    if (mysql_query(conn, query)) {
        fprintf(stderr, "%s\n", mysql_error(conn));
        mysql_close(conn);
        return;
    }

    res = mysql_store_result(conn);
    if (res == NULL) {
        fprintf(stderr, "%s\n", mysql_error(conn));
        mysql_close(conn);
        return;
    }

    while ((row = mysql_fetch_row(res))) {
        printf("%s\n", row[0]);
    }

    mysql_free_result(res);
    mysql_close(conn);
}

int main() {
    getUserInfo("alice");
    getUserInfo("bob");
    getUserInfo("charlie");
    getUserInfo("david");
    getUserInfo("eve");
    return 0;
}
```
Created file: Task37.java
Created file: Task37.py
Created file: Task37.cpp
Created file: Task37.c
Task38_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task38, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a web application that takes user input from a form and displays it back to the user on a webpage.
```java
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/Task38")
public class Task38 extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<form method='POST'>");
        out.println("Enter something: <input type='text' name='userInput'/>");
        out.println("<input type='submit' value='Submit'/>");
        out.println("</form>");
        out.println("</body></html>");
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        String userInput = request.getParameter("userInput");
        userInput = escapeHtml(userInput);
        out.println("<html><body>");
        out.println("You entered: " + userInput);
        out.println("</body></html>");
    }

    private String escapeHtml(String input) {
        if (input == null) return null;
        return input.replaceAll("&", "&amp;")
                    .replaceAll("<", "&lt;")
                    .replaceAll(">", "&gt;")
                    .replaceAll("\"", "&quot;")
                    .replaceAll("'", "&#x27;");
    }
}
```
```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/task38', methods=['GET', 'POST'])
def task38():
    if request.method == 'POST':
        user_input = request.form.get('userInput', '')
        user_input = escape_html(user_input)
        return render_template_string("<p>You entered: {{ user_input }}</p>", user_input=user_input)
    return render_template_string('''
        <form method="POST">
            Enter something: <input type="text" name="userInput"/>
            <input type="submit" value="Submit"/>
        </form>
    ''')

def escape_html(text):
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;").replace("'", "&#x27;")

if __name__ == '__main__':
    app.run(debug=True)
```
```cpp
#include <iostream>
#include <string>
#include <map>
#include <cppcms/applications_pool.h>
#include <cppcms/service.h>
#include <cppcms/application.h>
#include <cppcms/http_response.h>
#include <cppcms/http_request.h>

class Task38 : public cppcms::application {
public:
    Task38(cppcms::service &srv) : cppcms::application(srv) {}

    virtual void main(std::string url) {
        if (request().request_method() == "POST") {
            std::string user_input = request().post("userInput");
            user_input = escape_html(user_input);
            response().out() << "<html><body>You entered: " << user_input << "</body></html>";
        } else {
            response().out() <<
                "<html><body>"
                "<form method='POST'>"
                "Enter something: <input type='text' name='userInput'/>"
                "<input type='submit' value='Submit'/>"
                "</form>"
                "</body></html>";
        }
    }

private:
    std::string escape_html(const std::string &input) {
        std::map<char, std::string> html_escape_map = {
            {'&', "&amp;"},
            {'<', "&lt;"},
            {'>', "&gt;"},
            {'\"', "&quot;"},
            {'\'', "&#x27;"}
        };
        std::string output;
        for (char c : input) {
            if (html_escape_map.find(c) != html_escape_map.end()) {
                output += html_escape_map[c];
            } else {
                output += c;
            }
        }
        return output;
    }
};

int main(int argc, char **argv) {
    try {
        cppcms::service srv(argc, argv);
        srv.applications_pool().mount(cppcms::applications_factory<Task38>());
        srv.run();
    } catch(std::exception const &e) {
        std::cerr << e.what() << std::endl;
    }
    return 0;
}
```
```c
// Web applications are not typically written in C due to lack of native support for web frameworks and security features.
```
Created file: Task38.java
Created file: Task38.py
Created file: Task38.cpp
Created file: Task38.c
Task39_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task39, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a filename from the user and uses a system command to display its contents.
```java
import java.io.*;

public class Task39 {
    public static void main(String[] args) {
        System.out.println(displayFileContents("testfile1.txt"));
        System.out.println(displayFileContents("testfile2.txt"));
        System.out.println(displayFileContents("testfile3.txt"));
        System.out.println(displayFileContents("testfile4.txt"));
        System.out.println(displayFileContents("testfile5.txt"));
    }

    public static String displayFileContents(String filename) {
        StringBuilder content = new StringBuilder();
        try {
            ProcessBuilder builder = new ProcessBuilder("cat", filename);
            builder.redirectErrorStream(true);
            Process process = builder.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            process.waitFor();
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
        return content.toString();
    }
}
```
```python
import subprocess

def display_file_contents(filename):
    try:
        result = subprocess.run(['cat', filename], capture_output=True, text=True, check=True)
        return result.stdout
    except Exception as e:
        return f"Error: {str(e)}"

if __name__ == "__main__":
    print(display_file_contents("testfile1.txt"))
    print(display_file_contents("testfile2.txt"))
    print(display_file_contents("testfile3.txt"))
    print(display_file_contents("testfile4.txt"))
    print(display_file_contents("testfile5.txt"))
```
```cpp
#include <iostream>
#include <string>
#include <array>
#include <cstdio>
#include <memory>

std::string displayFileContents(const std::string &filename) {
    std::array<char, 128> buffer;
    std::string result;
    std::string command = "cat " + filename;
    std::shared_ptr<FILE> pipe(popen(command.c_str(), "r"), pclose);
    if (!pipe) return "Error: popen() failed!";
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

int main() {
    std::cout << displayFileContents("testfile1.txt") << std::endl;
    std::cout << displayFileContents("testfile2.txt") << std::endl;
    std::cout << displayFileContents("testfile3.txt") << std::endl;
    std::cout << displayFileContents("testfile4.txt") << std::endl;
    std::cout << displayFileContents("testfile5.txt") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

char* displayFileContents(const char *filename) {
    char *result = NULL;
    size_t len = 0;
    char buffer[128];
    char command[256];
    snprintf(command, sizeof(command), "cat %s", filename);
    FILE *pipe = popen(command, "r");
    if (!pipe) return "Error: popen() failed!";
    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
        len += snprintf(NULL, 0, "%s", buffer);
        result = realloc(result, len + 1);
        strcat(result, buffer);
    }
    pclose(pipe);
    return result;
}

int main() {
    printf("%s\n", displayFileContents("testfile1.txt"));
    printf("%s\n", displayFileContents("testfile2.txt"));
    printf("%s\n", displayFileContents("testfile3.txt"));
    printf("%s\n", displayFileContents("testfile4.txt"));
    printf("%s\n", displayFileContents("testfile5.txt"));
    return 0;
}
```
Created file: Task39.java
Created file: Task39.py
Created file: Task39.cpp
Created file: Task39.c
Task40_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task40, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a web application that includes a form to update user settings and ensure it is protected against CSRF attacks.
```java
import java.util.UUID;
import java.util.HashMap;
import java.util.Map;

public class Task40 {

    // Simulate a session store
    private static Map<String, String> sessionStore = new HashMap<>();

    // Method to generate a CSRF token
    public static String generateCsrfToken(String sessionId) {
        String token = UUID.randomUUID().toString();
        sessionStore.put(sessionId, token);
        return token;
    }

    // Method to validate CSRF token
    public static boolean validateCsrfToken(String sessionId, String token) {
        return token.equals(sessionStore.get(sessionId));
    }

    public static void main(String[] args) {
        // Simulate a session ID
        String sessionId = "user123";

        // Generate a CSRF token
        String csrfToken = generateCsrfToken(sessionId);

        // Test cases
        System.out.println(validateCsrfToken(sessionId, csrfToken)); // true
        System.out.println(validateCsrfToken(sessionId, "invalidToken")); // false
        System.out.println(validateCsrfToken("wrongSession", csrfToken)); // false

        // Regenerate CSRF token
        String newCsrfToken = generateCsrfToken(sessionId);

        System.out.println(validateCsrfToken(sessionId, csrfToken)); // false
        System.out.println(validateCsrfToken(sessionId, newCsrfToken)); // true
    }
}
```
```python
import uuid

# Simulate a session store
session_store = {}

# Method to generate a CSRF token
def generate_csrf_token(session_id):
    token = str(uuid.uuid4())
    session_store[session_id] = token
    return token

# Method to validate CSRF token
def validate_csrf_token(session_id, token):
    return session_store.get(session_id) == token

if __name__ == "__main__":
    # Simulate a session ID
    session_id = "user123"

    # Generate a CSRF token
    csrf_token = generate_csrf_token(session_id)

    # Test cases
    print(validate_csrf_token(session_id, csrf_token))  # True
    print(validate_csrf_token(session_id, "invalidToken"))  # False
    print(validate_csrf_token("wrongSession", csrf_token))  # False

    # Regenerate CSRF token
    new_csrf_token = generate_csrf_token(session_id)

    print(validate_csrf_token(session_id, csrf_token))  # False
    print(validate_csrf_token(session_id, new_csrf_token))  # True
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <random>

class Task40 {
public:
    // Simulate a session store
    static std::unordered_map<std::string, std::string> sessionStore;

    // Method to generate a CSRF token
    static std::string generateCsrfToken(const std::string& sessionId) {
        std::string token = generateRandomString();
        sessionStore[sessionId] = token;
        return token;
    }

    // Method to validate CSRF token
    static bool validateCsrfToken(const std::string& sessionId, const std::string& token) {
        return sessionStore[sessionId] == token;
    }

private:
    // Helper function to generate a random string
    static std::string generateRandomString() {
        static std::mt19937 rng{ std::random_device{}() };
        static const char characters[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        std::uniform_int_distribution<std::size_t> dist(0, sizeof(characters) - 2);
        std::string result(36, '\0');
        for (auto& c : result) {
            c = characters[dist(rng)];
        }
        return result;
    }
};

std::unordered_map<std::string, std::string> Task40::sessionStore;

int main() {
    // Simulate a session ID
    std::string sessionId = "user123";

    // Generate a CSRF token
    std::string csrfToken = Task40::generateCsrfToken(sessionId);

    // Test cases
    std::cout << Task40::validateCsrfToken(sessionId, csrfToken) << std::endl; // true
    std::cout << Task40::validateCsrfToken(sessionId, "invalidToken") << std::endl; // false
    std::cout << Task40::validateCsrfToken("wrongSession", csrfToken) << std::endl; // false

    // Regenerate CSRF token
    std::string newCsrfToken = Task40::generateCsrfToken(sessionId);

    std::cout << Task40::validateCsrfToken(sessionId, csrfToken) << std::endl; // false
    std::cout << Task40::validateCsrfToken(sessionId, newCsrfToken) << std::endl; // true

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define TOKEN_LENGTH 36

typedef struct {
    char sessionId[50];
    char csrfToken[TOKEN_LENGTH + 1];
} Session;

Session sessionStore[10]; // Simple array to simulate a session store
int sessionCount = 0;

// Helper function to generate a random string
void generateRandomString(char *str, size_t length) {
    static const char characters[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    for (size_t i = 0; i < length; ++i) {
        str[i] = characters[rand() % (sizeof(characters) - 1)];
    }
    str[length] = '\0';
}

// Method to generate a CSRF token
const char* generateCsrfToken(const char *sessionId) {
    for (int i = 0; i < sessionCount; ++i) {
        if (strcmp(sessionStore[i].sessionId, sessionId) == 0) {
            generateRandomString(sessionStore[i].csrfToken, TOKEN_LENGTH);
            return sessionStore[i].csrfToken;
        }
    }

    if (sessionCount < 10) {
        strcpy(sessionStore[sessionCount].sessionId, sessionId);
        generateRandomString(sessionStore[sessionCount].csrfToken, TOKEN_LENGTH);
        return sessionStore[sessionCount++].csrfToken;
    }

    return NULL; // No space left for new session
}

// Method to validate CSRF token
int validateCsrfToken(const char *sessionId, const char *token) {
    for (int i = 0; i < sessionCount; ++i) {
        if (strcmp(sessionStore[i].sessionId, sessionId) == 0) {
            return strcmp(sessionStore[i].csrfToken, token) == 0;
        }
    }
    return 0;
}

int main() {
    srand(time(NULL));

    // Simulate a session ID
    const char *sessionId = "user123";

    // Generate a CSRF token
    const char *csrfToken = generateCsrfToken(sessionId);

    // Test cases
    printf("%d\n", validateCsrfToken(sessionId, csrfToken)); // 1
    printf("%d\n", validateCsrfToken(sessionId, "invalidToken")); // 0
    printf("%d\n", validateCsrfToken("wrongSession", csrfToken)); // 0

    // Regenerate CSRF token
    const char *newCsrfToken = generateCsrfToken(sessionId);

    printf("%d\n", validateCsrfToken(sessionId, csrfToken)); // 0
    printf("%d\n", validateCsrfToken(sessionId, newCsrfToken)); // 1

    return 0;
}
```
Created file: Task40.java
Created file: Task40.py
Created file: Task40.cpp
Created file: Task40.c
Task41_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task41, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a string input from the user and processes it. Ensure the program is safe from buffer overflow vulnerabilities.
```java
import java.util.Scanner;

public class Task41 {
    public static String processInput(String input) {
        // Process the input securely
        return "Processed: " + input;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter a string: ");
        String userInput = scanner.nextLine();

        // Test cases
        System.out.println(processInput(userInput));
        System.out.println(processInput("Test case 1"));
        System.out.println(processInput("Test case 2"));
        System.out.println(processInput("Test case 3"));
        System.out.println(processInput("Test case 4"));
        System.out.println(processInput("Test case 5"));

        scanner.close();
    }
}
```
```python
def process_input(user_input):
    # Process the input securely
    return "Processed: " + user_input

def main():
    user_input = input("Enter a string: ")

    # Test cases
    print(process_input(user_input))
    print(process_input("Test case 1"))
    print(process_input("Test case 2"))
    print(process_input("Test case 3"))
    print(process_input("Test case 4"))
    print(process_input("Test case 5"))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>

std::string processInput(const std::string &input) {
    // Process the input securely
    return "Processed: " + input;
}

int main() {
    std::string userInput;
    std::cout << "Enter a string: ";
    std::getline(std::cin, userInput);

    // Test cases
    std::cout << processInput(userInput) << std::endl;
    std::cout << processInput("Test case 1") << std::endl;
    std::cout << processInput("Test case 2") << std::endl;
    std::cout << processInput("Test case 3") << std::endl;
    std::cout << processInput("Test case 4") << std::endl;
    std::cout << processInput("Test case 5") << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

void processInput(const char *input, char *output, size_t outputSize) {
    // Ensure buffer overflow protection
    snprintf(output, outputSize, "Processed: %s", input);
}

int main() {
    char userInput[256];
    char processedOutput[512];

    printf("Enter a string: ");
    if (fgets(userInput, sizeof(userInput), stdin) != NULL) {
        // Remove newline character if present
        size_t length = strlen(userInput);
        if (userInput[length - 1] == '\n') {
            userInput[length - 1] = '\0';
        }

        // Process input securely
        processInput(userInput, processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);

        // Test cases
        processInput("Test case 1", processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);

        processInput("Test case 2", processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);

        processInput("Test case 3", processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);

        processInput("Test case 4", processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);

        processInput("Test case 5", processedOutput, sizeof(processedOutput));
        printf("%s\n", processedOutput);
    }

    return 0;
}
```
Created file: Task41.java
Created file: Task41.py
Created file: Task41.cpp
Created file: Task41.c
Task42_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task42, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a simple user authentication system that securely handles user credentials.
```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Task42 {
    private static Map<String, String> userDatabase = new HashMap<>();

    public static boolean authenticate(String username, String password) {
        String storedPassword = userDatabase.get(username);
        return storedPassword != null && storedPassword.equals(hashPassword(password));
    }

    public static void registerUser(String username, String password) {
        if (!userDatabase.containsKey(username)) {
            userDatabase.put(username, hashPassword(password));
        }
    }

    private static String hashPassword(String password) {
        return Integer.toString(password.hashCode());
    }

    public static void main(String[] args) {
        registerUser("user1", "password123");
        registerUser("user2", "mysecretpass");
        registerUser("user3", "securepassword");
        registerUser("user4", "pass1234");
        registerUser("user5", "letmein");

        System.out.println(authenticate("user1", "password123")); // true
        System.out.println(authenticate("user2", "wrongpass")); // false
        System.out.println(authenticate("user3", "securepassword")); // true
        System.out.println(authenticate("user4", "pass1234")); // true
        System.out.println(authenticate("user5", "letmein")); // true
    }
}
```
```python
import hashlib

class Task42:
    user_database = {}

    @staticmethod
    def hash_password(password):
        return hashlib.sha256(password.encode()).hexdigest()

    @staticmethod
    def authenticate(username, password):
        stored_password = Task42.user_database.get(username)
        return stored_password == Task42.hash_password(password)

    @staticmethod
    def register_user(username, password):
        if username not in Task42.user_database:
            Task42.user_database[username] = Task42.hash_password(password)

    @staticmethod
    def main():
        Task42.register_user("user1", "password123")
        Task42.register_user("user2", "mysecretpass")
        Task42.register_user("user3", "securepassword")
        Task42.register_user("user4", "pass1234")
        Task42.register_user("user5", "letmein")

        print(Task42.authenticate("user1", "password123"))  # True
        print(Task42.authenticate("user2", "wrongpass"))    # False
        print(Task42.authenticate("user3", "securepassword"))  # True
        print(Task42.authenticate("user4", "pass1234"))    # True
        print(Task42.authenticate("user5", "letmein"))     # True

if __name__ == "__main__":
    Task42.main()
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <openssl/sha.h>

class Task42 {
    std::unordered_map<std::string, std::string> userDatabase;

    std::string hashPassword(const std::string& password) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256((unsigned char*)password.c_str(), password.size(), hash);
        std::string hashedPassword(hash, hash + SHA256_DIGEST_LENGTH);
        return hashedPassword;
    }

public:
    void registerUser(const std::string& username, const std::string& password) {
        if (userDatabase.find(username) == userDatabase.end()) {
            userDatabase[username] = hashPassword(password);
        }
    }

    bool authenticate(const std::string& username, const std::string& password) {
        auto it = userDatabase.find(username);
        if (it != userDatabase.end()) {
            return it->second == hashPassword(password);
        }
        return false;
    }

    static void main() {
        Task42 task;
        task.registerUser("user1", "password123");
        task.registerUser("user2", "mysecretpass");
        task.registerUser("user3", "securepassword");
        task.registerUser("user4", "pass1234");
        task.registerUser("user5", "letmein");

        std::cout << task.authenticate("user1", "password123") << std::endl; // true
        std::cout << task.authenticate("user2", "wrongpass") << std::endl;   // false
        std::cout << task.authenticate("user3", "securepassword") << std::endl; // true
        std::cout << task.authenticate("user4", "pass1234") << std::endl;   // true
        std::cout << task.authenticate("user5", "letmein") << std::endl;    // true
    }
};

int main() {
    Task42::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>

typedef struct {
    char username[50];
    char password_hash[SHA256_DIGEST_LENGTH];
} User;

User userDatabase[5];
int userCount = 0;

void hashPassword(const char* password, unsigned char* hash) {
    SHA256((unsigned char*)password, strlen(password), hash);
}

void registerUser(const char* username, const char* password) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    hashPassword(password, hash);

    strcpy(userDatabase[userCount].username, username);
    memcpy(userDatabase[userCount].password_hash, hash, SHA256_DIGEST_LENGTH);
    userCount++;
}

int authenticate(const char* username, const char* password) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    hashPassword(password, hash);

    for (int i = 0; i < userCount; i++) {
        if (strcmp(userDatabase[i].username, username) == 0) {
            return memcmp(userDatabase[i].password_hash, hash, SHA256_DIGEST_LENGTH) == 0;
        }
    }
    return 0;
}

int main() {
    registerUser("user1", "password123");
    registerUser("user2", "mysecretpass");
    registerUser("user3", "securepassword");
    registerUser("user4", "pass1234");
    registerUser("user5", "letmein");

    printf("%d\n", authenticate("user1", "password123")); // true
    printf("%d\n", authenticate("user2", "wrongpass"));   // false
    printf("%d\n", authenticate("user3", "securepassword")); // true
    printf("%d\n", authenticate("user4", "pass1234"));   // true
    printf("%d\n", authenticate("user5", "letmein"));    // true

    return 0;
}
```
Created file: Task42.java
Created file: Task42.py
Created file: Task42.cpp
Created file: Task42.c
Task43_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task43, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a web application that manages user sessions securely, including session creation, storage, and termination.
```java
import java.util.HashMap;
import java.util.UUID;

public class Task43 {

    private static HashMap<String, String> sessionStore = new HashMap<>();

    public static String createSession(String username) {
        String sessionId = UUID.randomUUID().toString();
        sessionStore.put(sessionId, username);
        return sessionId;
    }

    public static String getSession(String sessionId) {
        return sessionStore.get(sessionId);
    }

    public static void terminateSession(String sessionId) {
        sessionStore.remove(sessionId);
    }

    public static void main(String[] args) {
        String session1 = createSession("user1");
        String session2 = createSession("user2");
        String session3 = createSession("user3");

        System.out.println(getSession(session1)); // user1
        System.out.println(getSession(session2)); // user2
        System.out.println(getSession(session3)); // user3

        terminateSession(session2);
        System.out.println(getSession(session2)); // null
    }
}
```
```python
import uuid

class Task43:
    session_store = {}

    @staticmethod
    def create_session(username):
        session_id = str(uuid.uuid4())
        Task43.session_store[session_id] = username
        return session_id

    @staticmethod
    def get_session(session_id):
        return Task43.session_store.get(session_id)

    @staticmethod
    def terminate_session(session_id):
        Task43.session_store.pop(session_id, None)

# Test cases
session1 = Task43.create_session("user1")
session2 = Task43.create_session("user2")
session3 = Task43.create_session("user3")

print(Task43.get_session(session1))  # user1
print(Task43.get_session(session2))  # user2
print(Task43.get_session(session3))  # user3

Task43.terminate_session(session2)
print(Task43.get_session(session2))  # None
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <cstdlib>

class Task43 {
private:
    static std::unordered_map<std::string, std::string> sessionStore;

public:
    static std::string createSession(const std::string &username) {
        std::string sessionId = std::to_string(rand());
        sessionStore[sessionId] = username;
        return sessionId;
    }

    static std::string getSession(const std::string &sessionId) {
        if (sessionStore.find(sessionId) != sessionStore.end()) {
            return sessionStore[sessionId];
        }
        return "";
    }

    static void terminateSession(const std::string &sessionId) {
        sessionStore.erase(sessionId);
    }
};

std::unordered_map<std::string, std::string> Task43::sessionStore;

// Test cases
int main() {
    std::string session1 = Task43::createSession("user1");
    std::string session2 = Task43::createSession("user2");
    std::string session3 = Task43::createSession("user3");

    std::cout << Task43::getSession(session1) << std::endl; // user1
    std::cout << Task43::getSession(session2) << std::endl; // user2
    std::cout << Task43::getSession(session3) << std::endl; // user3

    Task43::terminateSession(session2);
    std::cout << Task43::getSession(session2) << std::endl; // ""
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SESSIONS 100

typedef struct {
    char sessionId[37];
    char username[100];
} Session;

Session sessionStore[MAX_SESSIONS];
int sessionCount = 0;

char* createSession(const char* username) {
    char* sessionId = (char*)malloc(37);
    sprintf(sessionId, "%d", rand());

    if (sessionCount < MAX_SESSIONS) {
        strcpy(sessionStore[sessionCount].sessionId, sessionId);
        strcpy(sessionStore[sessionCount].username, username);
        sessionCount++;
    }

    return sessionId;
}

const char* getSession(const char* sessionId) {
    for (int i = 0; i < sessionCount; ++i) {
        if (strcmp(sessionStore[i].sessionId, sessionId) == 0) {
            return sessionStore[i].username;
        }
    }
    return NULL;
}

void terminateSession(const char* sessionId) {
    for (int i = 0; i < sessionCount; ++i) {
        if (strcmp(sessionStore[i].sessionId, sessionId) == 0) {
            for (int j = i; j < sessionCount - 1; ++j) {
                sessionStore[j] = sessionStore[j + 1];
            }
            sessionCount--;
            break;
        }
    }
}

// Test cases
int main() {
    char* session1 = createSession("user1");
    char* session2 = createSession("user2");
    char* session3 = createSession("user3");

    printf("%s\n", getSession(session1)); // user1
    printf("%s\n", getSession(session2)); // user2
    printf("%s\n", getSession(session3)); // user3

    terminateSession(session2);
    printf("%s\n", getSession(session2)); // (null)

    free(session1);
    free(session2);
    free(session3);

    return 0;
}
```
Created file: Task43.java
Created file: Task43.py
Created file: Task43.cpp
Created file: Task43.c
Task44_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task44, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes user input and performs some operations on it. Ensure all user inputs are validated to prevent security issues.
```java
import java.util.Scanner;

public class Task44 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Test cases
        String[] testInputs = {"42", "123", "-1", "hello", "1000"};
        for (String input : testInputs) {
            try {
                int result = secureOperation(input);
                System.out.println("Result: " + result);
            } catch (IllegalArgumentException e) {
                System.out.println("Error: " + e.getMessage());
            }
        }

        scanner.close();
    }

    public static int secureOperation(String userInput) {
        if (!userInput.matches("\\d+")) {
            throw new IllegalArgumentException("Input must be a positive integer.");
        }

        int number = Integer.parseInt(userInput);
        return number * 2; // Example operation: double the number
    }
}
```
```python
def secure_operation(user_input):
    if not user_input.isdigit():
        raise ValueError("Input must be a positive integer.")

    number = int(user_input)
    return number * 2  # Example operation: double the number

# Test cases
test_inputs = ["42", "123", "-1", "hello", "1000"]
for input_str in test_inputs:
    try:
        result = secure_operation(input_str)
        print(f"Result: {result}")
    except ValueError as e:
        print(f"Error: {e}")
```
```cpp
#include <iostream>
#include <string>
#include <regex>

class Task44 {
public:
    static int secureOperation(const std::string& userInput) {
        if (!std::regex_match(userInput, std::regex("\\d+"))) {
            throw std::invalid_argument("Input must be a positive integer.");
        }

        int number = std::stoi(userInput);
        return number * 2; // Example operation: double the number
    }

    static void runTestCases() {
        std::string testInputs[] = {"42", "123", "-1", "hello", "1000"};
        for (const auto& input : testInputs) {
            try {
                int result = secureOperation(input);
                std::cout << "Result: " << result << std::endl;
            } catch (const std::invalid_argument& e) {
                std::cout << "Error: " << e.what() << std::endl;
            }
        }
    }
};

int main() {
    Task44::runTestCases();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int secureOperation(const char *userInput) {
    for (size_t i = 0; i < strlen(userInput); ++i) {
        if (!isdigit(userInput[i])) {
            fprintf(stderr, "Error: Input must be a positive integer.\n");
            exit(EXIT_FAILURE);
        }
    }

    int number = atoi(userInput);
    return number * 2; // Example operation: double the number
}

void runTestCases() {
    const char *testInputs[] = {"42", "123", "-1", "hello", "1000"};
    size_t testCount = sizeof(testInputs) / sizeof(testInputs[0]);

    for (size_t i = 0; i < testCount; ++i) {
        const char *input = testInputs[i];
        int result = secureOperation(input);
        printf("Result: %d\n", result);
    }
}

int main() {
    runTestCases();
    return 0;
}
```
Created file: Task44.java
Created file: Task44.py
Created file: Task44.cpp
Created file: Task44.c
Task45_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task45, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that handles user input and performs some operations, ensuring that all errors are properly caught and handled.
```java
public class Task45 {
    public static int performOperation(int a, int b) {
        try {
            return a / b;
        } catch (ArithmeticException e) {
            System.out.println("Error: Division by zero");
            return 0;
        }
    }

    public static void main(String[] args) {
        System.out.println(performOperation(10, 2)); // Expected output: 5
        System.out.println(performOperation(10, 0)); // Expected output: Error message and 0
        System.out.println(performOperation(15, 3)); // Expected output: 5
        System.out.println(performOperation(-6, 2)); // Expected output: -3
        System.out.println(performOperation(0, 1)); // Expected output: 0
    }
}
```
```python
def perform_operation(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        print("Error: Division by zero")
        return 0

if __name__ == "__main__":
    print(perform_operation(10, 2))  # Expected output: 5
    print(perform_operation(10, 0))  # Expected output: Error message and 0
    print(perform_operation(15, 3))  # Expected output: 5
    print(perform_operation(-6, 2))  # Expected output: -3
    print(perform_operation(0, 1))   # Expected output: 0
```
```cpp
#include <iostream>
#include <stdexcept>

class Task45 {
public:
    static int performOperation(int a, int b) {
        try {
            if (b == 0) throw std::runtime_error("Division by zero");
            return a / b;
        } catch (const std::runtime_error &e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return 0;
        }
    }
};

int main() {
    std::cout << Task45::performOperation(10, 2) << std::endl;  // Expected output: 5
    std::cout << Task45::performOperation(10, 0) << std::endl;  // Expected output: Error message and 0
    std::cout << Task45::performOperation(15, 3) << std::endl;  // Expected output: 5
    std::cout << Task45::performOperation(-6, 2) << std::endl;  // Expected output: -3
    std::cout << Task45::performOperation(0, 1) << std::endl;   // Expected output: 0
    return 0;
}
```
```c
#include <stdio.h>

int perform_operation(int a, int b) {
    if (b == 0) {
        printf("Error: Division by zero\n");
        return 0;
    }
    return a / b;
}

int main() {
    printf("%d\n", perform_operation(10, 2));  // Expected output: 5
    printf("%d\n", perform_operation(10, 0));  // Expected output: Error message and 0
    printf("%d\n", perform_operation(15, 3));  // Expected output: 5
    printf("%d\n", perform_operation(-6, 2));  // Expected output: -3
    printf("%d\n", perform_operation(0, 1));   // Expected output: 0
    return 0;
}
```
Created file: Task45.java
Created file: Task45.py
Created file: Task45.cpp
Created file: Task45.c
Task46_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task46, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a user registration system. The system should collect the user's name, email, and password and store this information in a database.
```java
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

class User {
    private String name;
    private String email;
    private String hashedPassword;

    public User(String name, String email, String hashedPassword) {
        this.name = name;
        this.email = email;
        this.hashedPassword = hashedPassword;
    }

    @Override
    public String toString() {
        return "User{name='" + name + "', email='" + email + "'}";
    }
}

class Database {
    private List<User> users = new ArrayList<>();

    public boolean addUser(User user) {
        if (validateEmail(user.email) && validatePassword(user.hashedPassword)) {
            users.add(user);
            return true;
        }
        return false;
    }

    private boolean validateEmail(String email) {
        String emailRegex = "^[a-zA-Z0-9_+&*-]+(?:\\." +
                            "[a-zA-Z0-9_+&*-]+)*@" +
                            "(?:[a-zA-Z0-9-]+\\.)+[a-z" +
                            "A-Z]{2,7}$";
        Pattern pat = Pattern.compile(emailRegex);
        return pat.matcher(email).matches();
    }

    private boolean validatePassword(String password) {
        return password.length() >= 8;
    }

    public List<User> getUsers() {
        return users;
    }
}

public class Task46 {
    public static void main(String[] args) {
        Database db = new Database();

        System.out.println(db.addUser(new User("Alice", "alice@example.com", "password123")));
        System.out.println(db.addUser(new User("Bob", "bob@example.com", "pass")));
        System.out.println(db.addUser(new User("Carol", "invalid-email", "password123")));
        System.out.println(db.addUser(new User("Dave", "dave@example.com", "davepass123")));
        System.out.println(db.addUser(new User("Eve", "eve@example.com", "eveeve12")));

        for (User user : db.getUsers()) {
            System.out.println(user);
        }
    }
}
```
```python
import re
import hashlib

class User:
    def __init__(self, name, email, password):
        self.name = name
        self.email = email
        self.hashed_password = self.hash_password(password)

    @staticmethod
    def hash_password(password):
        return hashlib.sha256(password.encode()).hexdigest()

    def __str__(self):
        return f"User(name='{self.name}', email='{self.email}')"

class Database:
    def __init__(self):
        self.users = []

    def add_user(self, user):
        if self.validate_email(user.email) and self.validate_password(user.hashed_password):
            self.users.append(user)
            return True
        return False

    @staticmethod
    def validate_email(email):
        email_regex = r'^[a-zA-Z0-9_+&*-]+(?:\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,7}$'
        return re.match(email_regex, email)

    @staticmethod
    def validate_password(hashed_password):
        return len(hashed_password) >= 8

    def get_users(self):
        return self.users

def main():
    db = Database()

    print(db.add_user(User("Alice", "alice@example.com", "password123")))
    print(db.add_user(User("Bob", "bob@example.com", "pass")))
    print(db.add_user(User("Carol", "invalid-email", "password123")))
    print(db.add_user(User("Dave", "dave@example.com", "davepass123")))
    print(db.add_user(User("Eve", "eve@example.com", "eveeve12")))

    for user in db.get_users():
        print(user)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <regex>
#include <openssl/sha.h>

class User {
public:
    std::string name;
    std::string email;
    std::string hashedPassword;

    User(const std::string& name, const std::string& email, const std::string& password)
        : name(name), email(email), hashedPassword(hashPassword(password)) {}

    static std::string hashPassword(const std::string& password) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256(reinterpret_cast<const unsigned char*>(password.c_str()), password.length(), hash);
        char hexString[65];
        for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
            sprintf(hexString + (i * 2), "%02x", hash[i]);
        }
        return std::string(hexString);
    }
};

class Database {
private:
    std::vector<User> users;

public:
    bool addUser(const User& user) {
        if (validateEmail(user.email) && validatePassword(user.hashedPassword)) {
            users.push_back(user);
            return true;
        }
        return false;
    }

    bool validateEmail(const std::string& email) {
        const std::regex pattern("^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$");
        return std::regex_match(email, pattern);
    }

    bool validatePassword(const std::string& hashedPassword) {
        return hashedPassword.length() >= 8;
    }

    std::vector<User> getUsers() const {
        return users;
    }
};

int main() {
    Database db;

    std::cout << db.addUser(User("Alice", "alice@example.com", "password123")) << std::endl;
    std::cout << db.addUser(User("Bob", "bob@example.com", "pass")) << std::endl;
    std::cout << db.addUser(User("Carol", "invalid-email", "password123")) << std::endl;
    std::cout << db.addUser(User("Dave", "dave@example.com", "davepass123")) << std::endl;
    std::cout << db.addUser(User("Eve", "eve@example.com", "eveeve12")) << std::endl;

    for (const User& user : db.getUsers()) {
        std::cout << "User{name='" << user.name << "', email='" << user.email << "'}" << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>
#include <regex.h>

#define MAX_USERS 100

typedef struct {
    char name[100];
    char email[100];
    char hashedPassword[65];
} User;

typedef struct {
    User users[MAX_USERS];
    int count;
} Database;

char* hashPassword(const char* password, char* outputBuffer) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256((unsigned char*)password, strlen(password), hash);
    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
        sprintf(outputBuffer + (i * 2), "%02x", hash[i]);
    }
    return outputBuffer;
}

int validateEmail(const char* email) {
    regex_t regex;
    int reti;
    reti = regcomp(&regex, "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$", REG_EXTENDED);
    if (reti) {
        return 0;
    }
    reti = regexec(&regex, email, 0, NULL, 0);
    regfree(&regex);
    return !reti;
}

int validatePassword(const char* hashedPassword) {
    return strlen(hashedPassword) >= 8;
}

int addUser(Database* db, const char* name, const char* email, const char* password) {
    if (db->count >= MAX_USERS) {
        return 0;
    }
    char hashedPassword[65];
    hashPassword(password, hashedPassword);
    if (validateEmail(email) && validatePassword(hashedPassword)) {
        strcpy(db->users[db->count].name, name);
        strcpy(db->users[db->count].email, email);
        strcpy(db->users[db->count].hashedPassword, hashedPassword);
        db->count++;
        return 1;
    }
    return 0;
}

void printUsers(const Database* db) {
    for (int i = 0; i < db->count; ++i) {
        printf("User{name='%s', email='%s'}\n", db->users[i].name, db->users[i].email);
    }
}

int main() {
    Database db = {.count = 0};

    printf("%d\n", addUser(&db, "Alice", "alice@example.com", "password123"));
    printf("%d\n", addUser(&db, "Bob", "bob@example.com", "pass"));
    printf("%d\n", addUser(&db, "Carol", "invalid-email", "password123"));
    printf("%d\n", addUser(&db, "Dave", "dave@example.com", "davepass123"));
    printf("%d\n", addUser(&db, "Eve", "eve@example.com", "eveeve12"));

    printUsers(&db);

    return 0;
}
```
Created file: Task46.java
Created file: Task46.py
Created file: Task46.cpp
Created file: Task46.c
Task47_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task47, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that scrapes data from a given website and stores it in a local database.
```java
// Java doesn't directly support web scraping and database operations without external libraries. Please use libraries like Jsoup for scraping and JDBC for database operations.
```
```python
import requests
from bs4 import BeautifulSoup
import sqlite3

def scrape_and_store(url):
    # Fetch the webpage
    response = requests.get(url)
    if response.status_code != 200:
        return "Error: Unable to fetch the webpage."

    # Parse the content
    soup = BeautifulSoup(response.content, 'html.parser')

    # Sample data extraction - extracting all 'a' tags
    data = [a.get('href') for a in soup.find_all('a', href=True)]

    # Store data into a local SQLite database
    conn = sqlite3.connect('scraped_data.db')
    cursor = conn.cursor()

    # Create a table if not exists
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS Links (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT NOT NULL
        )
    ''')

    # Insert data into the table
    for item in data:
        cursor.execute('INSERT INTO Links (url) VALUES (?)', (item,))

    # Commit changes and close the connection
    conn.commit()
    conn.close()

    return "Data scraped and stored successfully."

# Main method with 5 test cases
def main():
    test_urls = [
        "http://example.com",
        "http://example.com/about",
        "http://example.com/contact",
        "http://example.com/services",
        "http://example.com/products"
    ]

    for url in test_urls:
        print(scrape_and_store(url))

if __name__ == "__main__":
    main()
```
```cpp
// C++ doesn't directly support web scraping and database operations without external libraries. Consider using libraries like libcurl for HTTP requests and SQLiteCpp for database operations.
```
```c
// C doesn't directly support web scraping and database operations without external libraries. Consider using libraries like libcurl for HTTP requests and SQLite for database operations.
```
Created file: Task47.java
Created file: Task47.py
Created file: Task47.cpp
Created file: Task47.c
Task48_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task48, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements a simple chat application where multiple clients can send messages to a server, which then broadcasts the messages to all connected clients.
```java
import java.io.*;
import java.net.*;
import java.util.concurrent.*;
import java.util.*;

public class Task48 {
    private static Set<PrintWriter> clientWriters = ConcurrentHashMap.newKeySet();
    private static ExecutorService clientPool = Executors.newCachedThreadPool();

    public static void main(String[] args) throws Exception {
        System.out.println("Chat server started...");
        try (ServerSocket serverSocket = new ServerSocket(12345)) {
            while (true) {
                Socket clientSocket = serverSocket.accept();
                clientPool.execute(new ClientHandler(clientSocket));
            }
        }
    }

    private static class ClientHandler implements Runnable {
        private Socket socket;
        private BufferedReader in;
        private PrintWriter out;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            try {
                in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                out = new PrintWriter(socket.getOutputStream(), true);
                clientWriters.add(out);

                String message;
                while ((message = in.readLine()) != null) {
                    for (PrintWriter writer : clientWriters) {
                        writer.println(message);
                    }
                }
            } catch (IOException e) {
                System.out.println("Error handling client: " + e.getMessage());
            } finally {
                try {
                    socket.close();
                } catch (IOException e) {
                    System.out.println("Error closing socket: " + e.getMessage());
                }
                clientWriters.remove(out);
            }
        }
    }
}
```
```python
import socket
import threading

clients = []

def client_handler(client_socket):
    with client_socket:
        while True:
            try:
                message = client_socket.recv(1024).decode('utf-8')
                if not message:
                    break
                broadcast(message, client_socket)
            except ConnectionResetError:
                break
    clients.remove(client_socket)

def broadcast(message, client_socket):
    for client in clients:
        if client != client_socket:
            client.sendall(message.encode('utf-8'))

def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 12345))
    server.listen()
    print('Server started...')
    try:
        while True:
            client_socket, addr = server.accept()
            clients.append(client_socket)
            threading.Thread(target=client_handler, args=(client_socket,)).start()
    finally:
        server.close()

if __name__ == '__main__':
    main()
```
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <string>
#include <unistd.h>
#include <arpa/inet.h>

std::vector<int> clients;
std::mutex clients_mutex;

void broadcast(const std::string &message, int sender) {
    std::lock_guard<std::mutex> lock(clients_mutex);
    for (int client : clients) {
        if (client != sender) {
            send(client, message.c_str(), message.size(), 0);
        }
    }
}

void handle_client(int client_socket) {
    char buffer[1024];
    int bytes_received;
    while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
        std::string message(buffer, bytes_received);
        broadcast(message, client_socket);
    }
    close(client_socket);
    clients_mutex.lock();
    clients.erase(std::remove(clients.begin(), clients.end(), client_socket), clients.end());
    clients_mutex.unlock();
}

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(12345);

    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 5);
    std::cout << "Server started..." << std::endl;

    while (true) {
        int client_socket = accept(server_fd, nullptr, nullptr);
        clients_mutex.lock();
        clients.push_back(client_socket);
        clients_mutex.unlock();
        std::thread(handle_client, client_socket).detach();
    }

    close(server_fd);
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 12345
#define BUFFER_SIZE 1024

int clients[10];
int client_count = 0;
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void broadcast(const char *message, int sender) {
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < client_count; i++) {
        if (clients[i] != sender) {
            send(clients[i], message, strlen(message), 0);
        }
    }
    pthread_mutex_unlock(&clients_mutex);
}

void *client_handler(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    int bytes_received;
    while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
        buffer[bytes_received] = '\0';
        broadcast(buffer, client_socket);
    }
    close(client_socket);
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < client_count; i++) {
        if (clients[i] == client_socket) {
            clients[i] = clients[client_count - 1];
            client_count--;
            break;
        }
    }
    pthread_mutex_unlock(&clients_mutex);
    return NULL;
}

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 5);
    printf("Server started...\n");

    while (1) {
        int client_socket = accept(server_fd, NULL, NULL);
        pthread_mutex_lock(&clients_mutex);
        clients[client_count++] = client_socket;
        pthread_mutex_unlock(&clients_mutex);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, client_handler, &client_socket);
        pthread_detach(thread_id);
    }

    close(server_fd);
    return 0;
}
```
Created file: Task48.java
Created file: Task48.py
Created file: Task48.cpp
Created file: Task48.c
Task49_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task49, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a simple API endpoint which accepts user data and stores it in a database.
```java
// Java code omitted because writing a full API and database interaction is complex and not suited for a single file or a simple script.
```
```python
from flask import Flask, request, jsonify
import sqlite3
import os

app = Flask(__name__)

def init_db():
    if not os.path.exists('database.db'):
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute('''CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)''')
        conn.commit()
        conn.close()

@app.route('/add_user', methods=['POST'])
def add_user():
    try:
        data = request.get_json()
        name = data.get('name')
        email = data.get('email')

        if not name or not email:
            return jsonify({"error": "Invalid input"}), 400

        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute("INSERT INTO users (name, email) VALUES (?, ?)", (name, email))
        conn.commit()
        conn.close()

        return jsonify({"success": True}), 201
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
```
```cpp
// C++ code omitted because writing a full API and database interaction is complex and not suited for a single file or a simple script.
```
```c
// C code omitted because writing a full API and database interaction is complex and not suited for a single file or a simple script.
```

Created file: Task49.java
Created file: Task49.py
Created file: Task49.cpp
Created file: Task49.c
Task50_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task50, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that allows users to upload files to a server. The server should store the uploaded files and return a confirmation message.
```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

class Task50 {
    public static String uploadFile(byte[] fileData, String filename) {
        String directoryPath = "uploads/";
        new File(directoryPath).mkdirs();
        try {
            Files.write(Paths.get(directoryPath + filename), fileData);
            return "File uploaded successfully.";
        } catch (IOException e) {
            return "Error uploading file.";
        }
    }

    public static void main(String[] args) {
        byte[] testData = {1, 2, 3};
        System.out.println(uploadFile(testData, "test1.bin"));
        System.out.println(uploadFile(testData, "test2.bin"));
        System.out.println(uploadFile(testData, "test3.bin"));
        System.out.println(uploadFile(testData, "test4.bin"));
        System.out.println(uploadFile(testData, "test5.bin"));
    }
}
```
```python
import os

def upload_file(file_data, filename):
    directory = "uploads/"
    os.makedirs(directory, exist_ok=True)
    try:
        with open(os.path.join(directory, filename), 'wb') as file:
            file.write(file_data)
        return "File uploaded successfully."
    except IOError:
        return "Error uploading file."

def main():
    test_data = bytes([1, 2, 3])
    print(upload_file(test_data, "test1.bin"))
    print(upload_file(test_data, "test2.bin"))
    print(upload_file(test_data, "test3.bin"))
    print(upload_file(test_data, "test4.bin"))
    print(upload_file(test_data, "test5.bin"))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <fstream>
#include <sys/stat.h>

std::string uploadFile(const std::vector<uint8_t> &fileData, const std::string &filename) {
    std::string directoryPath = "uploads/";
    mkdir(directoryPath.c_str(), 0777);
    std::ofstream outFile(directoryPath + filename, std::ios::binary);
    if (outFile.is_open()) {
        outFile.write(reinterpret_cast<const char*>(&fileData[0]), fileData.size());
        outFile.close();
        return "File uploaded successfully.";
    } else {
        return "Error uploading file.";
    }
}

int main() {
    std::vector<uint8_t> testData = {1, 2, 3};
    std::cout << uploadFile(testData, "test1.bin") << std::endl;
    std::cout << uploadFile(testData, "test2.bin") << std::endl;
    std::cout << uploadFile(testData, "test3.bin") << std::endl;
    std::cout << uploadFile(testData, "test4.bin") << std::endl;
    std::cout << uploadFile(testData, "test5.bin") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

char* uploadFile(const unsigned char *fileData, size_t dataSize, const char *filename) {
    const char *directoryPath = "uploads/";
    mkdir(directoryPath, 0777);
    char filePath[256];
    snprintf(filePath, sizeof(filePath), "%s%s", directoryPath, filename);

    FILE *file = fopen(filePath, "wb");
    if (file != NULL) {
        fwrite(fileData, sizeof(unsigned char), dataSize, file);
        fclose(file);
        return "File uploaded successfully.";
    } else {
        return "Error uploading file.";
    }
}

int main() {
    unsigned char testData[] = {1, 2, 3};
    printf("%s\n", uploadFile(testData, sizeof(testData), "test1.bin"));
    printf("%s\n", uploadFile(testData, sizeof(testData), "test2.bin"));
    printf("%s\n", uploadFile(testData, sizeof(testData), "test3.bin"));
    printf("%s\n", uploadFile(testData, sizeof(testData), "test4.bin"));
    printf("%s\n", uploadFile(testData, sizeof(testData), "test5.bin"));
    return 0;
}
```
Created file: Task50.java
Created file: Task50.py
Created file: Task50.cpp
Created file: Task50.c
Task51_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task51, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that encrypts a given string using an encryption algorithm.
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Task51 {
    private static final String ALGORITHM = "AES";

    public static String encrypt(String plainText, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }

    public static SecretKey generateKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);
        keyGen.init(128); // for example, 128-bit AES
        return keyGen.generateKey();
    }

    public static void main(String[] args) throws Exception {
        SecretKey key = generateKey();
        System.out.println(encrypt("Hello, World!", key));
        System.out.println(encrypt("Encrypt this message.", key));
        System.out.println(encrypt("Another test case.", key));
        System.out.println(encrypt("Java AES encryption.", key));
        System.out.println(encrypt("Final test case.", key));
    }
}
```
```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import os

def encrypt(plain_text: str, key: bytes) -> bytes:
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plain_text.encode()) + padder.finalize()

    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
    return iv + encrypted_data

def generate_key() -> bytes:
    return os.urandom(16) # 128-bit key

if __name__ == "__main__":
    key = generate_key()
    print(encrypt("Hello, World!", key))
    print(encrypt("Encrypt this message.", key))
    print(encrypt("Another test case.", key))
    print(encrypt("Python AES encryption.", key))
    print(encrypt("Final test case.", key))
```
```cpp
#include <iostream>
#include <string>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <cstring>

class Task51 {
public:
    static std::string encrypt(const std::string& plainText, const unsigned char* key) {
        unsigned char iv[EVP_MAX_IV_LENGTH];
        RAND_bytes(iv, EVP_MAX_IV_LENGTH);

        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);

        std::string encrypted;
        encrypted.resize(plainText.size() + EVP_MAX_BLOCK_LENGTH);
        int len;

        EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&encrypted[0]), &len,
                          reinterpret_cast<const unsigned char*>(plainText.c_str()), plainText.size());

        int ciphertext_len = len;
        EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&encrypted[0]) + len, &len);
        ciphertext_len += len;

        EVP_CIPHER_CTX_free(ctx);

        return std::string(reinterpret_cast<char*>(iv), EVP_MAX_IV_LENGTH) + encrypted.substr(0, ciphertext_len);
    }

    static std::string generateKey() {
        unsigned char key[EVP_MAX_KEY_LENGTH];
        RAND_bytes(key, EVP_MAX_KEY_LENGTH);
        return std::string(reinterpret_cast<char*>(key), 16); // 128-bit key
    }

    static void runTests() {
        std::string key = generateKey();
        std::cout << encrypt("Hello, World!", reinterpret_cast<const unsigned char*>(key.c_str())) << std::endl;
        std::cout << encrypt("Encrypt this message.", reinterpret_cast<const unsigned char*>(key.c_str())) << std::endl;
        std::cout << encrypt("Another test case.", reinterpret_cast<const unsigned char*>(key.c_str())) << std::endl;
        std::cout << encrypt("C++ AES encryption.", reinterpret_cast<const unsigned char*>(key.c_str())) << std::endl;
        std::cout << encrypt("Final test case.", reinterpret_cast<const unsigned char*>(key.c_str())) << std::endl;
    }
};

int main() {
    Task51::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

void encrypt(const char *plainText, const unsigned char *key, unsigned char *encrypted) {
    unsigned char iv[EVP_MAX_IV_LENGTH];
    RAND_bytes(iv, EVP_MAX_IV_LENGTH);

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);

    int len;
    EVP_EncryptUpdate(ctx, encrypted, &len, (unsigned char *)plainText, strlen(plainText));
    int encrypted_len = len;
    EVP_EncryptFinal_ex(ctx, encrypted + len, &len);
    encrypted_len += len;

    memcpy(encrypted, iv, EVP_MAX_IV_LENGTH);
    EVP_CIPHER_CTX_free(ctx);
}

void generateKey(unsigned char *key) {
    RAND_bytes(key, 16); // 128-bit key
}

int main() {
    unsigned char key[16];
    generateKey(key);

    unsigned char encrypted[1024];

    encrypt("Hello, World!", key, encrypted);
    printf("%s\n", encrypted);
    encrypt("Encrypt this message.", key, encrypted);
    printf("%s\n", encrypted);
    encrypt("Another test case.", key, encrypted);
    printf("%s\n", encrypted);
    encrypt("C AES encryption.", key, encrypted);
    printf("%s\n", encrypted);
    encrypt("Final test case.", key, encrypted);
    printf("%s\n", encrypted);

    return 0;
}
```
Created file: Task51.java
Created file: Task51.py
Created file: Task51.cpp
Created file: Task51.c
Task52_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task52, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that encrypts and decrypts files using an encryption algorithm.
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.SecureRandom;

public class Task52 {

    public static void encryptFile(String inputFilePath, String outputFilePath, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        byte[] inputBytes = Files.readAllBytes(Paths.get(inputFilePath));
        byte[] outputBytes = cipher.doFinal(inputBytes);

        Files.write(Paths.get(outputFilePath), outputBytes);
    }

    public static void decryptFile(String inputFilePath, String outputFilePath, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        byte[] inputBytes = Files.readAllBytes(Paths.get(inputFilePath));
        byte[] outputBytes = cipher.doFinal(inputBytes);

        Files.write(Paths.get(outputFilePath), outputBytes);
    }

    public static SecretKey generateSecretKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(256, SecureRandom.getInstanceStrong());
        return keyGenerator.generateKey();
    }

    public static void main(String[] args) {
        try {
            SecretKey secretKey = generateSecretKey();
            encryptFile("test1.txt", "test1_enc.txt", secretKey);
            decryptFile("test1_enc.txt", "test1_dec.txt", secretKey);

            encryptFile("test2.txt", "test2_enc.txt", secretKey);
            decryptFile("test2_enc.txt", "test2_dec.txt", secretKey);

            encryptFile("test3.txt", "test3_enc.txt", secretKey);
            decryptFile("test3_enc.txt", "test3_dec.txt", secretKey);

            encryptFile("test4.txt", "test4_enc.txt", secretKey);
            decryptFile("test4_enc.txt", "test4_dec.txt", secretKey);

            encryptFile("test5.txt", "test5_enc.txt", secretKey);
            decryptFile("test5_enc.txt", "test5_dec.txt", secretKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import os

def encrypt_file(input_file, output_file, key):
    cipher = AES.new(key, AES.MODE_EAX)
    with open(input_file, 'rb') as f:
        data = f.read()
    nonce = cipher.nonce
    ciphertext, tag = cipher.encrypt_and_digest(data)
    with open(output_file, 'wb') as f:
        f.write(nonce)
        f.write(tag)
        f.write(ciphertext)

def decrypt_file(input_file, output_file, key):
    with open(input_file, 'rb') as f:
        nonce = f.read(16)
        tag = f.read(16)
        ciphertext = f.read()
    cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
    data = cipher.decrypt_and_verify(ciphertext, tag)
    with open(output_file, 'wb') as f:
        f.write(data)

def generate_secret_key():
    return get_random_bytes(32)

if __name__ == "__main__":
    secret_key = generate_secret_key()
    encrypt_file('test1.txt', 'test1_enc.txt', secret_key)
    decrypt_file('test1_enc.txt', 'test1_dec.txt', secret_key)

    encrypt_file('test2.txt', 'test2_enc.txt', secret_key)
    decrypt_file('test2_enc.txt', 'test2_dec.txt', secret_key)

    encrypt_file('test3.txt', 'test3_enc.txt', secret_key)
    decrypt_file('test3_enc.txt', 'test3_dec.txt', secret_key)

    encrypt_file('test4.txt', 'test4_enc.txt', secret_key)
    decrypt_file('test4_enc.txt', 'test4_dec.txt', secret_key)

    encrypt_file('test5.txt', 'test5_enc.txt', secret_key)
    decrypt_file('test5_enc.txt', 'test5_dec.txt', secret_key)
```
```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <openssl/aes.h>
#include <openssl/rand.h>

class Task52 {
public:
    static void encryptFile(const std::string &inputFilePath, const std::string &outputFilePath, const std::vector<unsigned char> &key) {
        std::ifstream inFile(inputFilePath, std::ios::binary);
        std::ofstream outFile(outputFilePath, std::ios::binary);

        std::vector<unsigned char> buffer(1024), ciphertext(1024 + AES_BLOCK_SIZE);
        std::vector<unsigned char> iv(AES_BLOCK_SIZE);
        RAND_bytes(iv.data(), AES_BLOCK_SIZE);

        AES_KEY aesKey;
        AES_set_encrypt_key(key.data(), 256, &aesKey);

        outFile.write(reinterpret_cast<const char *>(iv.data()), AES_BLOCK_SIZE);

        while (inFile.read(reinterpret_cast<char *>(buffer.data()), buffer.size())) {
            int bytesRead = inFile.gcount();
            AES_cfb128_encrypt(buffer.data(), ciphertext.data(), bytesRead, &aesKey, iv.data(), &bytesRead, AES_ENCRYPT);
            outFile.write(reinterpret_cast<const char *>(ciphertext.data()), bytesRead);
        }
    }

    static void decryptFile(const std::string &inputFilePath, const std::string &outputFilePath, const std::vector<unsigned char> &key) {
        std::ifstream inFile(inputFilePath, std::ios::binary);
        std::ofstream outFile(outputFilePath, std::ios::binary);

        std::vector<unsigned char> buffer(1024), plaintext(1024 + AES_BLOCK_SIZE);
        std::vector<unsigned char> iv(AES_BLOCK_SIZE);
        inFile.read(reinterpret_cast<char *>(iv.data()), AES_BLOCK_SIZE);

        AES_KEY aesKey;
        AES_set_decrypt_key(key.data(), 256, &aesKey);

        while (inFile.read(reinterpret_cast<char *>(buffer.data()), buffer.size())) {
            int bytesRead = inFile.gcount();
            AES_cfb128_encrypt(buffer.data(), plaintext.data(), bytesRead, &aesKey, iv.data(), &bytesRead, AES_DECRYPT);
            outFile.write(reinterpret_cast<const char *>(plaintext.data()), bytesRead);
        }
    }

    static std::vector<unsigned char> generateSecretKey() {
        std::vector<unsigned char> key(AES_BLOCK_SIZE);
        RAND_bytes(key.data(), AES_BLOCK_SIZE);
        return key;
    }
};

int main() {
    std::vector<unsigned char> secretKey = Task52::generateSecretKey();
    Task52::encryptFile("test1.txt", "test1_enc.txt", secretKey);
    Task52::decryptFile("test1_enc.txt", "test1_dec.txt", secretKey);

    Task52::encryptFile("test2.txt", "test2_enc.txt", secretKey);
    Task52::decryptFile("test2_enc.txt", "test2_dec.txt", secretKey);

    Task52::encryptFile("test3.txt", "test3_enc.txt", secretKey);
    Task52::decryptFile("test3_enc.txt", "test3_dec.txt", secretKey);

    Task52::encryptFile("test4.txt", "test4_enc.txt", secretKey);
    Task52::decryptFile("test4_enc.txt", "test4_dec.txt", secretKey);

    Task52::encryptFile("test5.txt", "test5_enc.txt", secretKey);
    Task52::decryptFile("test5_enc.txt", "test5_dec.txt", secretKey);

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/aes.h>
#include <openssl/rand.h>

void encryptFile(const char *inputFilePath, const char *outputFilePath, const unsigned char *key) {
    FILE *inFile = fopen(inputFilePath, "rb");
    FILE *outFile = fopen(outputFilePath, "wb");
    unsigned char buffer[1024], ciphertext[1024 + AES_BLOCK_SIZE];
    unsigned char iv[AES_BLOCK_SIZE];

    RAND_bytes(iv, AES_BLOCK_SIZE);
    fwrite(iv, 1, AES_BLOCK_SIZE, outFile);

    AES_KEY aesKey;
    AES_set_encrypt_key(key, 256, &aesKey);

    int bytesRead;
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), inFile)) > 0) {
        AES_cfb128_encrypt(buffer, ciphertext, bytesRead, &aesKey, iv, &bytesRead, AES_ENCRYPT);
        fwrite(ciphertext, 1, bytesRead, outFile);
    }

    fclose(inFile);
    fclose(outFile);
}

void decryptFile(const char *inputFilePath, const char *outputFilePath, const unsigned char *key) {
    FILE *inFile = fopen(inputFilePath, "rb");
    FILE *outFile = fopen(outputFilePath, "wb");
    unsigned char buffer[1024], plaintext[1024 + AES_BLOCK_SIZE];
    unsigned char iv[AES_BLOCK_SIZE];

    fread(iv, 1, AES_BLOCK_SIZE, inFile);

    AES_KEY aesKey;
    AES_set_decrypt_key(key, 256, &aesKey);

    int bytesRead;
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), inFile)) > 0) {
        AES_cfb128_encrypt(buffer, plaintext, bytesRead, &aesKey, iv, &bytesRead, AES_DECRYPT);
        fwrite(plaintext, 1, bytesRead, outFile);
    }

    fclose(inFile);
    fclose(outFile);
}

unsigned char *generateSecretKey() {
    unsigned char *key = (unsigned char *)malloc(AES_BLOCK_SIZE);
    RAND_bytes(key, AES_BLOCK_SIZE);
    return key;
}

int main() {
    unsigned char *secretKey = generateSecretKey();
    encryptFile("test1.txt", "test1_enc.txt", secretKey);
    decryptFile("test1_enc.txt", "test1_dec.txt", secretKey);

    encryptFile("test2.txt", "test2_enc.txt", secretKey);
    decryptFile("test2_enc.txt", "test2_dec.txt", secretKey);

    encryptFile("test3.txt", "test3_enc.txt", secretKey);
    decryptFile("test3_enc.txt", "test3_dec.txt", secretKey);

    encryptFile("test4.txt", "test4_enc.txt", secretKey);
    decryptFile("test4_enc.txt", "test4_dec.txt", secretKey);

    encryptFile("test5.txt", "test5_enc.txt", secretKey);
    decryptFile("test5_enc.txt", "test5_dec.txt", secretKey);

    free(secretKey);
    return 0;
}
```
Created file: Task52.java
Created file: Task52.py
Created file: Task52.cpp
Created file: Task52.c
Task53_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task53, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that manages user sessions for a web application.
```java
import java.util.HashMap;
import java.util.UUID;

public class Task53 {
    private HashMap<String, String> sessions = new HashMap<>();

    public String createSession(String username) {
        String sessionId = UUID.randomUUID().toString();
        sessions.put(sessionId, username);
        return sessionId;
    }

    public boolean isValidSession(String sessionId) {
        return sessions.containsKey(sessionId);
    }

    public void endSession(String sessionId) {
        sessions.remove(sessionId);
    }

    public static void main(String[] args) {
        Task53 sessionManager = new Task53();
        String session1 = sessionManager.createSession("user1");
        String session2 = sessionManager.createSession("user2");

        System.out.println(sessionManager.isValidSession(session1)); // true
        System.out.println(sessionManager.isValidSession(session2)); // true
        sessionManager.endSession(session1);
        System.out.println(sessionManager.isValidSession(session1)); // false
        System.out.println(sessionManager.isValidSession(session2)); // true
        System.out.println(sessionManager.isValidSession("fakeSession")); // false
    }
}
```
```python
import uuid

class Task53:
    def __init__(self):
        self.sessions = {}

    def create_session(self, username):
        session_id = str(uuid.uuid4())
        self.sessions[session_id] = username
        return session_id

    def is_valid_session(self, session_id):
        return session_id in self.sessions

    def end_session(self, session_id):
        self.sessions.pop(session_id, None)

if __name__ == "__main__":
    session_manager = Task53()
    session1 = session_manager.create_session("user1")
    session2 = session_manager.create_session("user2")

    print(session_manager.is_valid_session(session1))  # True
    print(session_manager.is_valid_session(session2))  # True
    session_manager.end_session(session1)
    print(session_manager.is_valid_session(session1))  # False
    print(session_manager.is_valid_session(session2))  # True
    print(session_manager.is_valid_session("fakeSession"))  # False
```
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <cstdlib>

class Task53 {
    std::unordered_map<std::string, std::string> sessions;

    std::string generateUUID() {
        char uuid[37];
        sprintf(uuid, "%08x-%04x-%04x-%04x-%012x", rand(), rand() & 0xFFFF, rand() & 0xFFFF, rand() & 0xFFFF, rand());
        return std::string(uuid);
    }

public:
    std::string createSession(const std::string& username) {
        std::string sessionId = generateUUID();
        sessions[sessionId] = username;
        return sessionId;
    }

    bool isValidSession(const std::string& sessionId) {
        return sessions.find(sessionId) != sessions.end();
    }

    void endSession(const std::string& sessionId) {
        sessions.erase(sessionId);
    }
};

int main() {
    Task53 sessionManager;
    std::string session1 = sessionManager.createSession("user1");
    std::string session2 = sessionManager.createSession("user2");

    std::cout << std::boolalpha;
    std::cout << sessionManager.isValidSession(session1) << std::endl; // true
    std::cout << sessionManager.isValidSession(session2) << std::endl; // true
    sessionManager.endSession(session1);
    std::cout << sessionManager.isValidSession(session1) << std::endl; // false
    std::cout << sessionManager.isValidSession(session2) << std::endl; // true
    std::cout << sessionManager.isValidSession("fakeSession") << std::endl; // false

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

typedef struct Session {
    char session_id[37];
    char username[50];
} Session;

Session sessions[100];
int session_count = 0;

void generateUUID(char* uuid) {
    sprintf(uuid, "%08x-%04x-%04x-%04x-%012x", rand(), rand() & 0xFFFF, rand() & 0xFFFF, rand() & 0xFFFF, rand());
}

char* createSession(const char* username) {
    if (session_count >= 100) return NULL;
    char session_id[37];
    generateUUID(session_id);
    strcpy(sessions[session_count].session_id, session_id);
    strcpy(sessions[session_count].username, username);
    session_count++;
    return sessions[session_count - 1].session_id;
}

int isValidSession(const char* session_id) {
    for (int i = 0; i < session_count; i++) {
        if (strcmp(sessions[i].session_id, session_id) == 0) {
            return 1;
        }
    }
    return 0;
}

void endSession(const char* session_id) {
    for (int i = 0; i < session_count; i++) {
        if (strcmp(sessions[i].session_id, session_id) == 0) {
            for (int j = i; j < session_count - 1; j++) {
                sessions[j] = sessions[j + 1];
            }
            session_count--;
            break;
        }
    }
}

int main() {
    srand(time(NULL));
    char* session1 = createSession("user1");
    char* session2 = createSession("user2");

    printf("%d\n", isValidSession(session1)); // 1
    printf("%d\n", isValidSession(session2)); // 1
    endSession(session1);
    printf("%d\n", isValidSession(session1)); // 0
    printf("%d\n", isValidSession(session2)); // 1
    printf("%d\n", isValidSession("fakeSession")); // 0

    return 0;
}
```
Created file: Task53.java
Created file: Task53.py
Created file: Task53.cpp
Created file: Task53.c
Task54_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task54, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that implements two-factor authentication (2FA) for user login using generating random one time password.
```java
import java.util.Random;
import java.util.Scanner;

public class Task54 {

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            String otp = generateOTP();
            System.out.println("Generated OTP: " + otp);
            if (validateOTP(otp)) {
                System.out.println("OTP validated successfully.");
            } else {
                System.out.println("OTP validation failed.");
            }
        }
    }

    public static String generateOTP() {
        Random random = new Random();
        StringBuilder otp = new StringBuilder();
        for (int i = 0; i < 6; i++) {
            otp.append(random.nextInt(10));
        }
        return otp.toString();
    }

    public static boolean validateOTP(String generatedOTP) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the OTP: ");
        String enteredOTP = scanner.nextLine();
        return generatedOTP.equals(enteredOTP);
    }
}
```
```python
import random

def main():
    for _ in range(5):
        otp = generate_otp()
        print(f"Generated OTP: {otp}")
        if validate_otp(otp):
            print("OTP validated successfully.")
        else:
            print("OTP validation failed.")

def generate_otp():
    return ''.join([str(random.randint(0, 9)) for _ in range(6)])

def validate_otp(generated_otp):
    entered_otp = input("Enter the OTP: ")
    return generated_otp == entered_otp

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>

class Task54 {
public:
    static void main() {
        srand(time(0));
        for (int i = 0; i < 5; i++) {
            std::string otp = generateOTP();
            std::cout << "Generated OTP: " << otp << std::endl;
            if (validateOTP(otp)) {
                std::cout << "OTP validated successfully." << std::endl;
            } else {
                std::cout << "OTP validation failed." << std::endl;
            }
        }
    }

    static std::string generateOTP() {
        std::string otp;
        for (int i = 0; i < 6; i++) {
            otp += std::to_string(rand() % 10);
        }
        return otp;
    }

    static bool validateOTP(const std::string& generatedOTP) {
        std::string enteredOTP;
        std::cout << "Enter the OTP: ";
        std::cin >> enteredOTP;
        return generatedOTP == enteredOTP;
    }
};

int main() {
    Task54::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

void generateOTP(char *otp) {
    for (int i = 0; i < 6; i++) {
        otp[i] = '0' + rand() % 10;
    }
    otp[6] = '\0';
}

int validateOTP(const char *generatedOTP) {
    char enteredOTP[7];
    printf("Enter the OTP: ");
    scanf("%6s", enteredOTP);
    return strcmp(generatedOTP, enteredOTP) == 0;
}

int main() {
    srand(time(0));
    for (int i = 0; i < 5; i++) {
        char otp[7];
        generateOTP(otp);
        printf("Generated OTP: %s\n", otp);
        if (validateOTP(otp)) {
            printf("OTP validated successfully.\n");
        } else {
            printf("OTP validation failed.\n");
        }
    }
    return 0;
}
```
Created file: Task54.java
Created file: Task54.py
Created file: Task54.cpp
Created file: Task54.c
Task55_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task55, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that validates user input to ensure it meets the criteria for a valid email address.
```java
import java.util.regex.Pattern;

public class Task55 {
    public static boolean isValidEmail(String email) {
        if (email == null) return false;
        String emailRegex = "^[\\w-\\.]+@[\\w-]+\\.[a-z]{2,6}$";
        Pattern pat = Pattern.compile(emailRegex, Pattern.CASE_INSENSITIVE);
        return pat.matcher(email).matches();
    }

    public static void main(String[] args) {
        System.out.println(isValidEmail("test@example.com")); // true
        System.out.println(isValidEmail("invalid-email")); // false
        System.out.println(isValidEmail("user.name@domain.com")); // true
        System.out.println(isValidEmail("user@domain.c")); // false
        System.out.println(isValidEmail("user@domaincom")); // false
    }
}
```
```python
import re

def is_valid_email(email):
    if not isinstance(email, str):
        return False
    email_regex = r'^[\w\.-]+@[\w-]+\.[a-z]{2,6}$'
    return re.match(email_regex, email, re.IGNORECASE) is not None

if __name__ == "__main__":
    print(is_valid_email("test@example.com"))  # True
    print(is_valid_email("invalid-email"))     # False
    print(is_valid_email("user.name@domain.com"))  # True
    print(is_valid_email("user@domain.c"))     # False
    print(is_valid_email("user@domaincom"))    # False
```
```cpp
#include <iostream>
#include <regex>

bool isValidEmail(const std::string& email) {
    if (email.empty()) return false;
    const std::regex pattern(R"(^[\w\.-]+@[\w-]+\.[a-z]{2,6}$)", std::regex_constants::icase);
    return std::regex_match(email, pattern);
}

int main() {
    std::cout << std::boolalpha;
    std::cout << isValidEmail("test@example.com") << std::endl;  // true
    std::cout << isValidEmail("invalid-email") << std::endl;     // false
    std::cout << isValidEmail("user.name@domain.com") << std::endl;  // true
    std::cout << isValidEmail("user@domain.c") << std::endl;     // false
    std::cout << isValidEmail("user@domaincom") << std::endl;    // false
    return 0;
}
```
```c
#include <stdio.h>
#include <regex.h>

int isValidEmail(const char *email) {
    if (email == NULL) return 0;
    regex_t regex;
    const char *pattern = "^[\\w\\.-]+@[\\w-]+\\.[a-z]{2,6}$";
    if (regcomp(&regex, pattern, REG_ICASE | REG_EXTENDED) != 0) return 0;
    int result = regexec(&regex, email, 0, NULL, 0);
    regfree(&regex);
    return result == 0;
}

int main() {
    printf("%d\n", isValidEmail("test@example.com"));  // 1
    printf("%d\n", isValidEmail("invalid-email"));     // 0
    printf("%d\n", isValidEmail("user.name@domain.com"));  // 1
    printf("%d\n", isValidEmail("user@domain.c"));     // 0
    printf("%d\n", isValidEmail("user@domaincom"));    // 0
    return 0;
}
```
Created file: Task55.java
Created file: Task55.py
Created file: Task55.cpp
Created file: Task55.c
Task56_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task56, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that generates a token for user authentication.
```java
import java.security.SecureRandom;
import java.util.Base64;

public class Task56 {
    public static String generateToken(int byteLength) {
        SecureRandom secureRandom = new SecureRandom();
        byte[] tokenBytes = new byte[byteLength];
        secureRandom.nextBytes(tokenBytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
    }

    public static void main(String[] args) {
        System.out.println(generateToken(32)); // Test case 1
        System.out.println(generateToken(32)); // Test case 2
        System.out.println(generateToken(32)); // Test case 3
        System.out.println(generateToken(32)); // Test case 4
        System.out.println(generateToken(32)); // Test case 5
    }
}
```
```python
import os
import base64

def generate_token(byte_length):
    token_bytes = os.urandom(byte_length)
    return base64.urlsafe_b64encode(token_bytes).rstrip(b'=').decode('ascii')

if __name__ == "__main__":
    print(generate_token(32))  # Test case 1
    print(generate_token(32))  # Test case 2
    print(generate_token(32))  # Test case 3
    print(generate_token(32))  # Test case 4
    print(generate_token(32))  # Test case 5
```
```cpp
#include <iostream>
#include <string>
#include <random>
#include <sstream>
#include <iomanip>

std::string generateToken(size_t byteLength) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 255);
    std::stringstream ss;
    for (size_t i = 0; i < byteLength; ++i) {
        ss << std::setw(2) << std::setfill('0') << std::hex << dis(gen);
    }
    return ss.str();
}

int main() {
    std::cout << generateToken(32) << std::endl;  // Test case 1
    std::cout << generateToken(32) << std::endl;  // Test case 2
    std::cout << generateToken(32) << std::endl;  // Test case 3
    std::cout << generateToken(32) << std::endl;  // Test case 4
    std::cout << generateToken(32) << std::endl;  // Test case 5
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void generateToken(size_t byteLength, char *output) {
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
    srand((unsigned int)time(NULL));
    for (size_t i = 0; i < byteLength; ++i) {
        output[i] = charset[rand() % (sizeof(charset) - 1)];
    }
    output[byteLength] = '\0';
}

int main() {
    char token[33];
    generateToken(32, token);
    printf("%s\n", token);  // Test case 1

    generateToken(32, token);
    printf("%s\n", token);  // Test case 2

    generateToken(32, token);
    printf("%s\n", token);  // Test case 3

    generateToken(32, token);
    printf("%s\n", token);  // Test case 4

    generateToken(32, token);
    printf("%s\n", token);  // Test case 5

    return 0;
}
```
Created file: Task56.java
Created file: Task56.py
Created file: Task56.cpp
Created file: Task56.c
Task57_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task57, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes a number as input and calculates its factorial.
```java
import java.math.BigInteger;

public class Task57 {
    public static BigInteger factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Number must be non-negative");
        }
        BigInteger result = BigInteger.ONE;
        for (int i = 2; i <= n; i++) {
            result = result.multiply(BigInteger.valueOf(i));
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(factorial(5));  // 120
        System.out.println(factorial(0));  // 1
        System.out.println(factorial(10)); // 3628800
        System.out.println(factorial(20)); // 2432902008176640000
        System.out.println(factorial(15)); // 1307674368000
    }
}
```
```python
import math

def factorial(n):
    if n < 0:
        raise ValueError("Number must be non-negative")
    return math.factorial(n)

if __name__ == "__main__":
    print(factorial(5))   # 120
    print(factorial(0))   # 1
    print(factorial(10))  # 3628800
    print(factorial(20))  # 2432902008176640000
    print(factorial(15))  # 1307674368000
```
```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

class Task57 {
public:
    static long long factorial(int n) {
        if (n < 0) {
            throw invalid_argument("Number must be non-negative");
        }
        long long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }

    static void runTests() {
        cout << factorial(5) << endl;   // 120
        cout << factorial(0) << endl;   // 1
        cout << factorial(10) << endl;  // 3628800
        cout << factorial(20) << endl;  // 2432902008176640000
        cout << factorial(15) << endl;  // 1307674368000
    }
};

int main() {
    Task57::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

unsigned long long factorial(int n) {
    if (n < 0) {
        fprintf(stderr, "Number must be non-negative\n");
        exit(EXIT_FAILURE);
    }
    unsigned long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    printf("%llu\n", factorial(5));   // 120
    printf("%llu\n", factorial(0));   // 1
    printf("%llu\n", factorial(10));  // 3628800
    printf("%llu\n", factorial(20));  // 2432902008176640000
    printf("%llu\n", factorial(15));  // 1307674368000
    return 0;
}
```
Created file: Task57.java
Created file: Task57.py
Created file: Task57.cpp
Created file: Task57.c
Task58_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task58, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contain any char.

Examples input/output:

XO("ooxx") => true
XO("xooxx") => false
XO("ooxXm") => true
XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
XO("zzoo") => false
```java
public class Task58 {
    public static boolean XO(String str) {
        if (str == null) return true;
        str = str.toLowerCase();
        int xCount = 0, oCount = 0;
        for (char ch : str.toCharArray()) {
            if (ch == 'x') xCount++;
            if (ch == 'o') oCount++;
        }
        return xCount == oCount;
    }

    public static void main(String[] args) {
        System.out.println(XO("ooxx"));     // true
        System.out.println(XO("xooxx"));    // false
        System.out.println(XO("ooxXm"));    // true
        System.out.println(XO("zpzpzpp"));  // true
        System.out.println(XO("zzoo"));     // false
    }
}
```
```python
def XO(s):
    if s is None:
        return True
    s = s.lower()
    return s.count('x') == s.count('o')

if __name__ == "__main__":
    print(XO("ooxx"))     # True
    print(XO("xooxx"))    # False
    print(XO("ooxXm"))    # True
    print(XO("zpzpzpp"))  # True
    print(XO("zzoo"))     # False
```
```cpp
#include <iostream>
#include <string>
#include <algorithm>

class Task58 {
public:
    static bool XO(const std::string& str) {
        int xCount = 0, oCount = 0;
        for (char ch : str) {
            ch = std::tolower(ch);
            if (ch == 'x') xCount++;
            if (ch == 'o') oCount++;
        }
        return xCount == oCount;
    }
};

int main() {
    std::cout << Task58::XO("ooxx") << std::endl;     // true
    std::cout << Task58::XO("xooxx") << std::endl;    // false
    std::cout << Task58::XO("ooxXm") << std::endl;    // true
    std::cout << Task58::XO("zpzpzpp") << std::endl;  // true
    std::cout << Task58::XO("zzoo") << std::endl;     // false
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

bool XO(const char* str) {
    if (str == NULL) return true;
    int xCount = 0, oCount = 0;
    for (size_t i = 0; i < strlen(str); i++) {
        char ch = tolower((unsigned char)str[i]);
        if (ch == 'x') xCount++;
        if (ch == 'o') oCount++;
    }
    return xCount == oCount;
}

int main() {
    printf("%d\n", XO("ooxx"));     // true
    printf("%d\n", XO("xooxx"));    // false
    printf("%d\n", XO("ooxXm"));    // true
    printf("%d\n", XO("zpzpzpp"));  // true
    printf("%d\n", XO("zzoo"));     // false
    return 0;
}
```
Created file: Task58.java
Created file: Task58.py
Created file: Task58.cpp
Created file: Task58.c
Task59_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task59, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
This time no story, no theory. The examples below show you how to write function accum:

Examples:
accum("abcd") -> "A-Bb-Ccc-Dddd"
accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") -> "C-Ww-Aaa-Tttt"
The parameter of accum is a string which includes only letters from a..z and A..Z.
```java
public class Task59 {

    public static String accum(String s) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            result.append(Character.toUpperCase(c));
            for (int j = 0; j < i; j++) {
                result.append(Character.toLowerCase(c));
            }
            if (i < s.length() - 1) {
                result.append("-");
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        System.out.println(accum("abcd")); // A-Bb-Ccc-Dddd
        System.out.println(accum("RqaEzty")); // R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy
        System.out.println(accum("cwAt")); // C-Ww-Aaa-Tttt
        System.out.println(accum("mM")); // M-Mm
        System.out.println(accum("nOpQr")); // N-Oo-Ppp-Qqqq-Rrrrr
    }
}
```
```python
def accum(s: str) -> str:
    result = []
    for i, c in enumerate(s):
        result.append(c.upper() + c.lower() * i)
    return '-'.join(result)

if __name__ == "__main__":
    print(accum("abcd"))  # A-Bb-Ccc-Dddd
    print(accum("RqaEzty"))  # R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy
    print(accum("cwAt"))  # C-Ww-Aaa-Tttt
    print(accum("mM"))  # M-Mm
    print(accum("nOpQr"))  # N-Oo-Ppp-Qqqq-Rrrrr
```
```cpp
#include <iostream>
#include <string>
#include <cctype>

std::string accum(const std::string &s) {
    std::string result;
    for (size_t i = 0; i < s.size(); i++) {
        if (i != 0) {
            result += '-';
        }
        result += std::toupper(s[i]);
        result.append(i, std::tolower(s[i]));
    }
    return result;
}

int main() {
    std::cout << accum("abcd") << std::endl;  // A-Bb-Ccc-Dddd
    std::cout << accum("RqaEzty") << std::endl;  // R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy
    std::cout << accum("cwAt") << std::endl;  // C-Ww-Aaa-Tttt
    std::cout << accum("mM") << std::endl;  // M-Mm
    std::cout << accum("nOpQr") << std::endl;  // N-Oo-Ppp-Qqqq-Rrrrr
    return 0;
}
```
```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>

void accum(const char *s, char *result) {
    size_t len = strlen(s);
    size_t pos = 0;
    for (size_t i = 0; i < len; i++) {
        if (i != 0) {
            result[pos++] = '-';
        }
        result[pos++] = toupper(s[i]);
        for (size_t j = 0; j < i; j++) {
            result[pos++] = tolower(s[i]);
        }
    }
    result[pos] = '\0';
}

int main() {
    char result[100];
    accum("abcd", result);
    printf("%s\n", result);  // A-Bb-Ccc-Dddd
    accum("RqaEzty", result);
    printf("%s\n", result);  // R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy
    accum("cwAt", result);
    printf("%s\n", result);  // C-Ww-Aaa-Tttt
    accum("mM", result);
    printf("%s\n", result);  // M-Mm
    accum("nOpQr", result);
    printf("%s\n", result);  // N-Oo-Ppp-Qqqq-Rrrrr
    return 0;
}
```
Created file: Task59.java
Created file: Task59.py
Created file: Task59.cpp
Created file: Task59.c
Task60_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task60, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
You will be given a number and you will need to return it as a string in Expanded Form. For example:

Kata.expandedForm(12); # Should return "10 + 2"
Kata.expandedForm(42); # Should return "40 + 2"
Kata.expandedForm(70304); # Should return "70000 + 300 + 4"
NOTE: All numbers will be whole numbers greater than 0.
```java
public class Task60 {
    public static String expandedForm(int num) {
        StringBuilder result = new StringBuilder();
        int placeValue = 1;

        while (num > 0) {
            int remainder = num % 10;
            num /= 10;
            if (remainder > 0) {
                if (result.length() > 0) {
                    result.insert(0, " + ");
                }
                result.insert(0, remainder * placeValue);
            }
            placeValue *= 10;
        }

        return result.toString();
    }

    public static void main(String[] args) {
        System.out.println(expandedForm(12));    // Should return "10 + 2"
        System.out.println(expandedForm(42));    // Should return "40 + 2"
        System.out.println(expandedForm(70304)); // Should return "70000 + 300 + 4"
        System.out.println(expandedForm(9001));  // Should return "9000 + 1"
        System.out.println(expandedForm(5010));  // Should return "5000 + 10"
    }
}
```
```python
def expanded_form(num):
    num_str = str(num)
    length = len(num_str)
    result = []

    for i, digit in enumerate(num_str):
        if digit != '0':
            result.append(digit + '0' * (length - i - 1))

    return ' + '.join(result)

def main():
    print(expanded_form(12))    # Should return "10 + 2"
    print(expanded_form(42))    # Should return "40 + 2"
    print(expanded_form(70304)) # Should return "70000 + 300 + 4"
    print(expanded_form(9001))  # Should return "9000 + 1"
    print(expanded_form(5010))  # Should return "5000 + 10"

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>

std::string expandedForm(int num) {
    std::string result;
    int placeValue = 1;

    while (num > 0) {
        int remainder = num % 10;
        num /= 10;
        if (remainder > 0) {
            std::string term = std::to_string(remainder * placeValue);
            if (!result.empty()) {
                result = " + " + result;
            }
            result = term + result;
        }
        placeValue *= 10;
    }

    return result;
}

int main() {
    std::cout << expandedForm(12) << std::endl;    // Should return "10 + 2"
    std::cout << expandedForm(42) << std::endl;    // Should return "40 + 2"
    std::cout << expandedForm(70304) << std::endl; // Should return "70000 + 300 + 4"
    std::cout << expandedForm(9001) << std::endl;  // Should return "9000 + 1"
    std::cout << expandedForm(5010) << std::endl;  // Should return "5000 + 10"
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>

void expandedForm(int num, char *result) {
    char buffer[50];
    int placeValue = 1;
    int first = 1;
    result[0] = '\0';

    while (num > 0) {
        int remainder = num % 10;
        num /= 10;
        if (remainder > 0) {
            sprintf(buffer, "%d", remainder * placeValue);
            if (!first) {
                strcat(buffer, " + ");
                strcat(buffer, result);
            }
            strcpy(result, buffer);
            first = 0;
        }
        placeValue *= 10;
    }
}

int main() {
    char result[100];

    expandedForm(12, result);
    printf("%s\n", result);    // Should return "10 + 2"

    expandedForm(42, result);
    printf("%s\n", result);    // Should return "40 + 2"

    expandedForm(70304, result);
    printf("%s\n", result);    // Should return "70000 + 300 + 4"

    expandedForm(9001, result);
    printf("%s\n", result);    // Should return "9000 + 1"

    expandedForm(5010, result);
    printf("%s\n", result);    // Should return "5000 + 10"

    return 0;
}
```
Created file: Task60.java
Created file: Task60.py
Created file: Task60.cpp
Created file: Task60.c
Task61_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task61, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Parse the provided string to extract the structure of the XML document it represents. After parsing, identify and return the root element of the XML document.
```java
import javax.xml.parsers.*;
import org.w3c.dom.*;

public class Task61 {
    public static String getRootElement(String xmlContent) {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new InputSource(new java.io.StringReader(xmlContent)));
            return document.getDocumentElement().getNodeName();
        } catch (Exception e) {
            return null; // Handle exception securely
        }
    }

    public static void main(String[] args) {
        System.out.println(getRootElement("<root><child /></root>")); // root
        System.out.println(getRootElement("<note><to>Tove</to></note>")); // note
        System.out.println(getRootElement("<a><b><c></c></b></a>")); // a
        System.out.println(getRootElement("<foo></foo>")); // foo
        System.out.println(getRootElement("<x><y><z/></y></x>")); // x
    }
}
```
```python
from xml.etree import ElementTree as ET

def get_root_element(xml_content):
    try:
        root = ET.fromstring(xml_content)
        return root.tag
    except ET.ParseError:
        return None  # Handle exception securely

def main():
    print(get_root_element("<root><child /></root>"))  # root
    print(get_root_element("<note><to>Tove</to></note>"))  # note
    print(get_root_element("<a><b><c></c></b></a>"))  # a
    print(get_root_element("<foo></foo>"))  # foo
    print(get_root_element("<x><y><z/></y></x>"))  # x

main()
```
```cpp
#include <iostream>
#include <string>
#include <stdexcept>
#include <libxml/parser.h>
#include <libxml/tree.h>

std::string getRootElement(const std::string& xmlContent) {
    xmlDocPtr doc = xmlReadMemory(xmlContent.c_str(), xmlContent.size(), "noname.xml", NULL, 0);
    if (doc == NULL) {
        return ""; // Handle parsing error securely
    }
    xmlNodePtr rootElement = xmlDocGetRootElement(doc);
    std::string rootName = (rootElement != NULL) ? (const char*)rootElement->name : "";
    xmlFreeDoc(doc);
    return rootName;
}

int main() {
    std::cout << getRootElement("<root><child /></root>") << std::endl; // root
    std::cout << getRootElement("<note><to>Tove</to></note>") << std::endl; // note
    std::cout << getRootElement("<a><b><c></c></b></a>") << std::endl; // a
    std::cout << getRootElement("<foo></foo>") << std::endl; // foo
    std::cout << getRootElement("<x><y><z/></y></x>") << std::endl; // x
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <libxml/parser.h>
#include <libxml/tree.h>

char* getRootElement(const char* xmlContent) {
    xmlDocPtr doc = xmlReadMemory(xmlContent, strlen(xmlContent), "noname.xml", NULL, 0);
    if (doc == NULL) {
        return NULL; // Handle parsing error securely
    }
    xmlNodePtr rootElement = xmlDocGetRootElement(doc);
    char* rootName = (rootElement != NULL) ? (char*)rootElement->name : NULL;
    xmlFreeDoc(doc);
    return rootName;
}

int main() {
    printf("%s\n", getRootElement("<root><child /></root>")); // root
    printf("%s\n", getRootElement("<note><to>Tove</to></note>")); // note
    printf("%s\n", getRootElement("<a><b><c></c></b></a>")); // a
    printf("%s\n", getRootElement("<foo></foo>")); // foo
    printf("%s\n", getRootElement("<x><y><z/></y></x>")); // x
    return 0;
}
```
Created file: Task61.java
Created file: Task61.py
Created file: Task61.cpp
Created file: Task61.c
Task62_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task62, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Parse the provided string to extract the structure of the JSON document it represents. After parsing, identify and return the root element of the JSON document.
```java
import org.json.JSONObject;

public class Task62 {
    public static String parseJSON(String jsonString) {
        JSONObject jsonObject = new JSONObject(jsonString);
        return jsonObject.keys().next();
    }

    public static void main(String[] args) {
        System.out.println(parseJSON("{\"root\": {\"child\": \"value\"}}")); // root
        System.out.println(parseJSON("{\"main\": {\"inner\": \"data\"}}")); // main
        System.out.println(parseJSON("{\"key1\": 1, \"key2\": 2}")); // key1
        System.out.println(parseJSON("{\"a\": {\"b\": \"c\"}}")); // a
        System.out.println(parseJSON("{\"first\": \"second\"}")); // first
    }
}
```
```python
import json

def parse_json(json_string):
    json_obj = json.loads(json_string)
    return list(json_obj.keys())[0]

if __name__ == "__main__":
    print(parse_json('{"root": {"child": "value"}}'))  # root
    print(parse_json('{"main": {"inner": "data"}}'))  # main
    print(parse_json('{"key1": 1, "key2": 2}'))  # key1
    print(parse_json('{"a": {"b": "c"}}'))  # a
    print(parse_json('{"first": "second"}'))  # first
```
```cpp
#include <iostream>
#include <string>
#include <json/json.h>

std::string parseJSON(const std::string &jsonString) {
    Json::Value jsonData;
    Json::CharReaderBuilder readerBuilder;
    std::string errs;

    std::istringstream s(jsonString);
    std::string key;
    if (Json::parseFromStream(readerBuilder, s, &jsonData, &errs)) {
        if (!jsonData.getMemberNames().empty()) {
            key = jsonData.getMemberNames()[0];
        }
    }
    return key;
}

int main() {
    std::cout << parseJSON("{\"root\": {\"child\": \"value\"}}") << std::endl; // root
    std::cout << parseJSON("{\"main\": {\"inner\": \"data\"}}") << std::endl; // main
    std::cout << parseJSON("{\"key1\": 1, \"key2\": 2}") << std::endl; // key1
    std::cout << parseJSON("{\"a\": {\"b\": \"c\"}}") << std::endl; // a
    std::cout << parseJSON("{\"first\": \"second\"}") << std::endl; // first
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <json-c/json.h>

const char* parseJSON(const char *jsonString) {
    struct json_object *parsed_json;
    parsed_json = json_tokener_parse(jsonString);

    if (!parsed_json) {
        return NULL;
    }

    json_object_object_foreach(parsed_json, key, val) {
        json_object_put(parsed_json); // Free memory
        return key;
    }

    json_object_put(parsed_json); // Free memory
    return NULL;
}

int main() {
    printf("%s\n", parseJSON("{\"root\": {\"child\": \"value\"}}")); // root
    printf("%s\n", parseJSON("{\"main\": {\"inner\": \"data\"}}")); // main
    printf("%s\n", parseJSON("{\"key1\": 1, \"key2\": 2}")); // key1
    printf("%s\n", parseJSON("{\"a\": {\"b\": \"c\"}}")); // a
    printf("%s\n", parseJSON("{\"first\": \"second\"}")); // first
    return 0;
}
```
Created file: Task62.java
Created file: Task62.py
Created file: Task62.cpp
Created file: Task62.c
Task63_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task63, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Develop a program to process incoming requests by performing the following steps:

Retrieve the raw_data from the request, ensuring it is encoded in UTF-8.
Decode the raw_data using Base64.
Deserialize the decoded data into its original format (e.g., JSON, XML).
Store the deserialized data in a variable.
Return the stored data.
```java
import java.util.Base64;
import org.json.JSONObject;
import java.nio.charset.StandardCharsets;

public class Task63 {
    public static String processRequest(String raw_data) {
        try {
            // Ensure the data is encoded in UTF-8
            byte[] utf8Bytes = raw_data.getBytes(StandardCharsets.UTF_8);

            // Decode the data using Base64
            byte[] decodedBytes = Base64.getDecoder().decode(utf8Bytes);

            // Deserialize the decoded data (assuming JSON format)
            String jsonString = new String(decodedBytes, StandardCharsets.UTF_8);
            JSONObject jsonObject = new JSONObject(jsonString);

            // Store and return the deserialized data
            return jsonObject.toString();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        // Test cases
        String base64EncodedJson = Base64.getEncoder().encodeToString("{\"key\":\"value\"}".getBytes(StandardCharsets.UTF_8));
        System.out.println(processRequest(base64EncodedJson)); // Expected: {"key":"value"}

        String base64EncodedJson2 = Base64.getEncoder().encodeToString("{\"name\":\"John\"}".getBytes(StandardCharsets.UTF_8));
        System.out.println(processRequest(base64EncodedJson2)); // Expected: {"name":"John"}

        String base64EncodedJson3 = Base64.getEncoder().encodeToString("{\"age\":30}".getBytes(StandardCharsets.UTF_8));
        System.out.println(processRequest(base64EncodedJson3)); // Expected: {"age":30}

        String base64EncodedJson4 = Base64.getEncoder().encodeToString("{\"status\":\"active\"}".getBytes(StandardCharsets.UTF_8));
        System.out.println(processRequest(base64EncodedJson4)); // Expected: {"status":"active"}

        String base64EncodedJson5 = Base64.getEncoder().encodeToString("{\"admin\":false}".getBytes(StandardCharsets.UTF_8));
        System.out.println(processRequest(base64EncodedJson5)); // Expected: {"admin":false}
    }
}
```
```python
import base64
import json

def process_request(raw_data):
    try:
        # Ensure the data is encoded in UTF-8
        utf8_data = raw_data.encode('utf-8')

        # Decode the data using Base64
        decoded_data = base64.b64decode(utf8_data)

        # Deserialize the decoded data (assuming JSON format)
        deserialized_data = json.loads(decoded_data.decode('utf-8'))

        # Store and return the deserialized data
        return deserialized_data
    except Exception as e:
        print(e)
        return None

if __name__ == "__main__":
    # Test cases
    base64_encoded_json = base64.b64encode(json.dumps({"key": "value"}).encode('utf-8')).decode('utf-8')
    print(process_request(base64_encoded_json)) # Expected: {'key': 'value'}

    base64_encoded_json2 = base64.b64encode(json.dumps({"name": "John"}).encode('utf-8')).decode('utf-8')
    print(process_request(base64_encoded_json2)) # Expected: {'name': 'John'}

    base64_encoded_json3 = base64.b64encode(json.dumps({"age": 30}).encode('utf-8')).decode('utf-8')
    print(process_request(base64_encoded_json3)) # Expected: {'age': 30}

    base64_encoded_json4 = base64.b64encode(json.dumps({"status": "active"}).encode('utf-8')).decode('utf-8')
    print(process_request(base64_encoded_json4)) # Expected: {'status': 'active'}

    base64_encoded_json5 = base64.b64encode(json.dumps({"admin": False}).encode('utf-8')).decode('utf-8')
    print(process_request(base64_encoded_json5)) # Expected: {'admin': False}
```
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <stdexcept>
#include <json/json.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>

class Task63 {
public:
    static std::string processRequest(const std::string& raw_data) {
        try {
            // Ensure the data is encoded in UTF-8
            std::string utf8_data = raw_data;

            // Decode the data using Base64
            std::string decoded_data = base64Decode(utf8_data);

            // Deserialize the decoded data (assuming JSON format)
            Json::Value deserialized_data;
            std::istringstream(decoded_data) >> deserialized_data;

            // Store and return the deserialized data
            return deserialized_data.toStyledString();
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            return "";
        }
    }

    static std::string base64Decode(const std::string& encoded) {
        BIO* bio, * b64;
        char* buffer = (char*)malloc(encoded.size());
        memset(buffer, 0, encoded.size());

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new_mem_buf((void*)encoded.c_str(), -1);
        bio = BIO_push(b64, bio);

        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        int decoded_length = BIO_read(bio, buffer, encoded.size());
        BIO_free_all(bio);

        std::string decoded(buffer, decoded_length);
        free(buffer);
        return decoded;
    }
};

int main() {
    // Test cases
    std::string base64EncodedJson = "eyJrZXkiOiJ2YWx1ZSJ9"; // {"key":"value"}
    std::cout << Task63::processRequest(base64EncodedJson) << std::endl; // Expected: {"key":"value"}

    std::string base64EncodedJson2 = "eyJuYW1lIjoiSm9obiJ9"; // {"name":"John"}
    std::cout << Task63::processRequest(base64EncodedJson2) << std::endl; // Expected: {"name":"John"}

    std::string base64EncodedJson3 = "eyJhZ2UiOjMwfQ=="; // {"age":30}
    std::cout << Task63::processRequest(base64EncodedJson3) << std::endl; // Expected: {"age":30}

    std::string base64EncodedJson4 = "eyJzdGF0dXMiOiJhY3RpdmUifQ=="; // {"status":"active"}
    std::cout << Task63::processRequest(base64EncodedJson4) << std::endl; // Expected: {"status":"active"}

    std::string base64EncodedJson5 = "eyJhZG1pbiI6ZmFsc2V9"; // {"admin":false}
    std::cout << Task63::processRequest(base64EncodedJson5) << std::endl; // Expected: {"admin":false}
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <json-c/json.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>

char* base64_decode(const char* input, int length, int* out_len) {
    BIO *b64, *bio;
    char* buffer = (char*)malloc(length);
    memset(buffer, 0, length);

    b64 = BIO_new(BIO_f_base64());
    bio = BIO_new_mem_buf((void*)input, length);
    bio = BIO_push(b64, bio);

    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
    *out_len = BIO_read(bio, buffer, length);
    BIO_free_all(bio);

    return buffer;
}

char* process_request(const char* raw_data) {
    // Ensure the data is encoded in UTF-8
    const char* utf8_data = raw_data;

    // Decode the data using Base64
    int decoded_len;
    char* decoded_data = base64_decode(utf8_data, strlen(utf8_data), &decoded_len);

    // Deserialize the decoded data (assuming JSON format)
    struct json_object *parsed_json;
    parsed_json = json_tokener_parse(decoded_data);
    free(decoded_data);

    // Store and return the deserialized data
    return strdup(json_object_to_json_string(parsed_json));
}

int main() {
    // Test cases
    char* base64EncodedJson = "eyJrZXkiOiJ2YWx1ZSJ9"; // {"key":"value"}
    printf("%s\n", process_request(base64EncodedJson)); // Expected: {"key":"value"}

    char* base64EncodedJson2 = "eyJuYW1lIjoiSm9obiJ9"; // {"name":"John"}
    printf("%s\n", process_request(base64EncodedJson2)); // Expected: {"name":"John"}

    char* base64EncodedJson3 = "eyJhZ2UiOjMwfQ=="; // {"age":30}
    printf("%s\n", process_request(base64EncodedJson3)); // Expected: {"age":30}

    char* base64EncodedJson4 = "eyJzdGF0dXMiOiJhY3RpdmUifQ=="; // {"status":"active"}
    printf("%s\n", process_request(base64EncodedJson4)); // Expected: {"status":"active"}

    char* base64EncodedJson5 = "eyJhZG1pbiI6ZmFsc2V9"; // {"admin":false}
    printf("%s\n", process_request(base64EncodedJson5)); // Expected: {"admin":false"}

    return 0;
}
```
Created file: Task63.java
Created file: Task63.py
Created file: Task63.cpp
Created file: Task63.c
Task64_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task64, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program to read a JSON file from a specified URL passed from the command line argument. The function should fetch the file from the URL, parse the JSON content, and return the resulting JSON object.
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.HttpURLConnection;
import org.json.JSONObject;

public class Task64 {
    public static JSONObject fetchJsonFromUrl(String urlString) {
        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);

            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuilder content = new StringBuilder();
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine);
            }
            in.close();
            return new JSONObject(content.toString());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("Please provide a URL as a command line argument.");
            return;
        }

        String url = args[0];
        JSONObject jsonObject = fetchJsonFromUrl(url);
        System.out.println(jsonObject != null ? jsonObject.toString() : "Failed to fetch JSON");
    }
}
```
```python
import requests
import json
import sys

def fetch_json_from_url(url):
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Error: {e}")
        return None

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Please provide a URL as a command line argument.")
        sys.exit(1)

    url = sys.argv[1]
    json_object = fetch_json_from_url(url)
    print(json.dumps(json_object, indent=2) if json_object else "Failed to fetch JSON")
```
```cpp
#include <iostream>
#include <curl/curl.h>
#include <json/json.h>

class Task64 {
public:
    static std::string fetchJsonFromUrl(const std::string &url) {
        CURL *curl;
        CURLcode res;
        std::string response;

        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

            res = curl_easy_perform(curl);
            curl_easy_cleanup(curl);

            if (res != CURLE_OK) {
                fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
                return "";
            }
        }
        curl_global_cleanup();
        return response;
    }

    static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp) {
        ((std::string *)userp)->append((char *)contents, size * nmemb);
        return size * nmemb;
    }
};

int main(int argc, char *argv[]) {
    if (argc < 2) {
        std::cerr << "Please provide a URL as a command line argument." << std::endl;
        return 1;
    }

    std::string url = argv[1];
    std::string json_response = Task64::fetchJsonFromUrl(url);

    if (!json_response.empty()) {
        Json::Value jsonData;
        Json::CharReaderBuilder readerBuilder;
        std::string errs;

        std::istringstream s(json_response);
        if (Json::parseFromStream(readerBuilder, s, &jsonData, &errs)) {
            std::cout << jsonData.toStyledString() << std::endl;
        } else {
            std::cerr << "Failed to parse JSON: " << errs << std::endl;
        }
    } else {
        std::cerr << "Failed to fetch JSON" << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

struct MemoryStruct {
    char *memory;
    size_t size;
};

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;

    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if (ptr == NULL) {
        printf("Not enough memory (realloc returned NULL)\n");
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

char* fetchJsonFromUrl(const char *url) {
    CURL *curl_handle;
    CURLcode res;
    struct MemoryStruct chunk;

    chunk.memory = malloc(1);
    chunk.size = 0;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_handle = curl_easy_init();

    if (curl_handle) {
        curl_easy_setopt(curl_handle, CURLOPT_URL, url);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
        curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 5L);

        res = curl_easy_perform(curl_handle);

        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            free(chunk.memory);
            chunk.memory = NULL;
        }

        curl_easy_cleanup(curl_handle);
    }

    curl_global_cleanup();
    return chunk.memory;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Please provide a URL as a command line argument.\n");
        return 1;
    }

    const char *url = argv[1];
    char *json_response = fetchJsonFromUrl(url);

    if (json_response) {
        printf("%s\n", json_response);
        free(json_response);
    } else {
        fprintf(stderr, "Failed to fetch JSON\n");
    }

    return 0;
}
```
Created file: Task64.java
Created file: Task64.py
Created file: Task64.cpp
Created file: Task64.c
Task65_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task65, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that retrieves a filename from a command line argument, validates its format or existence, and returns the data from the corresponding file. Ensure the function handles potential errors gracefully, such as invalid filenames or inaccessible files.
```java
import java.io.*;
import java.nio.file.*;

public class Task65 {
    public static String readFile(String filename) {
        Path path = Paths.get(filename);
        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return "File does not exist or is not a regular file.";
        }
        try {
            return new String(Files.readAllBytes(path));
        } catch (IOException e) {
            return "Error reading file: " + e.getMessage();
        }
    }

    public static void main(String[] args) {
        String[] testFiles = {
            "test1.txt",
            "test2.txt",
            "test3.txt",
            "test4.txt",
            "test5.txt"
        };

        for (String file : testFiles) {
            System.out.println("Reading " + file + ":");
            System.out.println(readFile(file));
            System.out.println("-----------------------------");
        }
    }
}
```
```python
import os

def read_file(filename):
    if not os.path.isfile(filename):
        return "File does not exist or is not a regular file."
    try:
        with open(filename, 'r') as file:
            return file.read()
    except Exception as e:
        return f"Error reading file: {e}"

def main():
    test_files = [
        "test1.txt",
        "test2.txt",
        "test3.txt",
        "test4.txt",
        "test5.txt"
    ]

    for file in test_files:
        print(f"Reading {file}:")
        print(read_file(file))
        print("-----------------------------")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <sys/stat.h>

bool fileExists(const std::string& filename) {
    struct stat buffer;
    return (stat(filename.c_str(), &buffer) == 0) && S_ISREG(buffer.st_mode);
}

std::string readFile(const std::string& filename) {
    if (!fileExists(filename)) {
        return "File does not exist or is not a regular file.";
    }

    std::ifstream file(filename);
    if (!file) {
        return "Error opening file.";
    }

    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    return content;
}

int main() {
    std::string testFiles[] = {
        "test1.txt",
        "test2.txt",
        "test3.txt",
        "test4.txt",
        "test5.txt"
    };

    for (const auto& file : testFiles) {
        std::cout << "Reading " << file << ":\n";
        std::cout << readFile(file) << "\n";
        std::cout << "-----------------------------\n";
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int fileExists(const char *filename) {
    struct stat buffer;
    return (stat(filename, &buffer) == 0) && S_ISREG(buffer.st_mode);
}

char* readFile(const char *filename) {
    if (!fileExists(filename)) {
        return "File does not exist or is not a regular file.";
    }

    FILE *file = fopen(filename, "r");
    if (!file) {
        return "Error opening file.";
    }

    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *content = (char *)malloc(fileSize + 1);
    if (!content) {
        fclose(file);
        return "Memory allocation failed.";
    }

    fread(content, 1, fileSize, file);
    content[fileSize] = '\0';
    fclose(file);

    return content;
}

int main() {
    const char *testFiles[] = {
        "test1.txt",
        "test2.txt",
        "test3.txt",
        "test4.txt",
        "test5.txt"
    };

    for (int i = 0; i < 5; i++) {
        printf("Reading %s:\n", testFiles[i]);
        char *content = readFile(testFiles[i]);
        printf("%s\n", content);
        if (content != "File does not exist or is not a regular file." && content != "Error opening file." && content != "Memory allocation failed.") {
            free(content);
        }
        printf("-----------------------------\n");
    }

    return 0;
}
```
Created file: Task65.java
Created file: Task65.py
Created file: Task65.cpp
Created file: Task65.c
Task66_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task66, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that reads an bash shell command from user input, validates its format and content, executes, and return the result.
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Task66 {
    public static String executeCommand(String command) {
        if (isValidCommand(command)) {
            try {
                Process process = Runtime.getRuntime().exec(command);
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder output = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
                return output.toString();
            } catch (Exception e) {
                return "Error executing command: " + e.getMessage();
            }
        }
        return "Invalid command format";
    }

    private static boolean isValidCommand(String command) {
        String[] allowedCommands = {"ls", "pwd", "whoami", "date", "echo"};
        for (String allowed : allowedCommands) {
            if (command.equals(allowed) || command.startsWith(allowed + " ")) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        System.out.println(executeCommand("ls"));
        System.out.println(executeCommand("pwd"));
        System.out.println(executeCommand("whoami"));
        System.out.println(executeCommand("date"));
        System.out.println(executeCommand("echo Hello World"));
    }
}
```
```python
import subprocess
import shlex

def execute_command(command):
    if is_valid_command(command):
        try:
            process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            return stdout.decode() if process.returncode == 0 else stderr.decode()
        except Exception as e:
            return f"Error executing command: {e}"
    return "Invalid command format"

def is_valid_command(command):
    allowed_commands = ["ls", "pwd", "whoami", "date", "echo"]
    for allowed in allowed_commands:
        if command == allowed or command.startswith(allowed + " "):
            return True
    return False

if __name__ == "__main__":
    print(execute_command("ls"))
    print(execute_command("pwd"))
    print(execute_command("whoami"))
    print(execute_command("date"))
    print(execute_command("echo Hello World"))
```
```cpp
#include <iostream>
#include <array>
#include <memory>
#include <stdexcept>

class Task66 {
public:
    static std::string executeCommand(const std::string& command) {
        if (isValidCommand(command)) {
            try {
                std::array<char, 128> buffer;
                std::string result;
                std::shared_ptr<FILE> pipe(popen(command.c_str(), "r"), pclose);
                if (!pipe) throw std::runtime_error("popen() failed!");
                while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
                    result += buffer.data();
                }
                return result;
            } catch (const std::exception& e) {
                return "Error executing command: " + std::string(e.what());
            }
        }
        return "Invalid command format";
    }

private:
    static bool isValidCommand(const std::string& command) {
        std::array<std::string, 5> allowedCommands = {"ls", "pwd", "whoami", "date", "echo"};
        for (const auto& allowed : allowedCommands) {
            if (command == allowed || command.find(allowed + " ") == 0) {
                return true;
            }
        }
        return false;
    }
};

int main() {
    std::cout << Task66::executeCommand("ls") << std::endl;
    std::cout << Task66::executeCommand("pwd") << std::endl;
    std::cout << Task66::executeCommand("whoami") << std::endl;
    std::cout << Task66::executeCommand("date") << std::endl;
    std::cout << Task66::executeCommand("echo Hello World") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int isValidCommand(const char* command) {
    const char* allowedCommands[] = {"ls", "pwd", "whoami", "date", "echo"};
    size_t numCommands = sizeof(allowedCommands) / sizeof(allowedCommands[0]);
    for (size_t i = 0; i < numCommands; i++) {
        if (strcmp(command, allowedCommands[i]) == 0 || strstr(command, allowedCommands[i]) == command) {
            return 1;
        }
    }
    return 0;
}

char* executeCommand(const char* command) {
    if (isValidCommand(command)) {
        FILE* pipe = popen(command, "r");
        if (!pipe) {
            return "Error executing command.";
        }

        char* result = malloc(1024);
        if (!result) {
            pclose(pipe);
            return "Memory allocation failed.";
        }
        result[0] = '\0';

        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            strcat(result, buffer);
        }

        pclose(pipe);
        return result;
    }
    return "Invalid command format";
}

int main() {
    printf("%s\n", executeCommand("ls"));
    printf("%s\n", executeCommand("pwd"));
    printf("%s\n", executeCommand("whoami"));
    printf("%s\n", executeCommand("date"));
    printf("%s\n", executeCommand("echo Hello World"));
    return 0;
}
```
Created file: Task66.java
Created file: Task66.py
Created file: Task66.cpp
Created file: Task66.c
Task67_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task67, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that retrieves customer information based on a specified "customerusername" from the "customer" table in a database. Fetch the relevant information and return it as structured data or an object. Assume the user pass the customer username as command line argument
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Task67 {

    static class Customer {
        String username;
        String name;
        String email;

        Customer(String username, String name, String email) {
            this.username = username;
            this.name = name;
            this.email = email;
        }

        @Override
        public String toString() {
            return "Customer{" +
                    "username='" + username + '\'' +
                    ", name='" + name + '\'' +
                    ", email='" + email + '\'' +
                    '}';
        }
    }

    public static Customer getCustomerInfo(String customerUsername) {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "password";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        Customer customer = null;

        try {
            conn = DriverManager.getConnection(url, user, password);
            String sql = "SELECT username, name, email FROM customer WHERE username = ?";
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, customerUsername);
            rs = pstmt.executeQuery();

            if (rs.next()) {
                customer = new Customer(
                        rs.getString("username"),
                        rs.getString("name"),
                        rs.getString("email")
                );
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (pstmt != null) pstmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return customer;
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Please provide a customer username.");
            return;
        }

        String customerUsername = args[0];
        Customer customer = getCustomerInfo(customerUsername);

        if (customer != null) {
            System.out.println(customer);
        } else {
            System.out.println("Customer not found.");
        }
    }
}
```
```python
import sys
import mysql.connector
from mysql.connector import Error

class Customer:
    def __init__(self, username, name, email):
        self.username = username
        self.name = name
        self.email = email

    def __str__(self):
        return f'Customer(username={self.username}, name={self.name}, email={self.email})'

def get_customer_info(customer_username):
    try:
        connection = mysql.connector.connect(
            host='localhost',
            database='mydatabase',
            user='root',
            password='password'
        )
        if connection.is_connected():
            cursor = connection.cursor()
            cursor.execute("SELECT username, name, email FROM customer WHERE username = %s", (customer_username,))
            row = cursor.fetchone()

            if row:
                return Customer(*row)
            return None

    except Error as e:
        print(f"Error: {e}")
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

def main():
    if len(sys.argv) < 2:
        print("Please provide a customer username.")
        return

    customer_username = sys.argv[1]
    customer = get_customer_info(customer_username)

    if customer:
        print(customer)
    else:
        print("Customer not found.")

if __name__ == '__main__':
    main()
```
```cpp
#include <iostream>
#include <mysql/mysql.h>
#include <string>

class Customer {
public:
    std::string username;
    std::string name;
    std::string email;

    Customer(const std::string& u, const std::string& n, const std::string& e)
        : username(u), name(n), email(e) {}

    friend std::ostream& operator<<(std::ostream& os, const Customer& c) {
        os << "Customer(username=" << c.username << ", name=" << c.name << ", email=" << c.email << ")";
        return os;
    }
};

Customer* getCustomerInfo(const std::string& customerUsername) {
    MYSQL* conn;
    MYSQL_RES* res;
    MYSQL_ROW row;

    conn = mysql_init(nullptr);
    if (!mysql_real_connect(conn, "localhost", "root", "password", "mydatabase", 0, nullptr, 0)) {
        std::cerr << "MySQL connection error: " << mysql_error(conn) << std::endl;
        return nullptr;
    }

    std::string query = "SELECT username, name, email FROM customer WHERE username = '" + customerUsername + "'";
    if (mysql_query(conn, query.c_str())) {
        std::cerr << "MySQL query error: " << mysql_error(conn) << std::endl;
        mysql_close(conn);
        return nullptr;
    }

    res = mysql_store_result(conn);
    if ((row = mysql_fetch_row(res))) {
        Customer* customer = new Customer(row[0], row[1], row[2]);
        mysql_free_result(res);
        mysql_close(conn);
        return customer;
    }

    mysql_free_result(res);
    mysql_close(conn);
    return nullptr;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Please provide a customer username." << std::endl;
        return 1;
    }

    std::string customerUsername = argv[1];
    Customer* customer = getCustomerInfo(customerUsername);

    if (customer) {
        std::cout << *customer << std::endl;
        delete customer;
    } else {
        std::cout << "Customer not found." << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mysql/mysql.h>

typedef struct {
    char username[50];
    char name[100];
    char email[100];
} Customer;

Customer* getCustomerInfo(const char* customerUsername) {
    MYSQL *conn;
    MYSQL_RES *res;
    MYSQL_ROW row;
    Customer* customer = NULL;

    conn = mysql_init(NULL);
    if (!mysql_real_connect(conn, "localhost", "root", "password", "mydatabase", 0, NULL, 0)) {
        fprintf(stderr, "MySQL connection error: %s\n", mysql_error(conn));
        return NULL;
    }

    char query[256];
    snprintf(query, sizeof(query), "SELECT username, name, email FROM customer WHERE username = '%s'", customerUsername);
    if (mysql_query(conn, query)) {
        fprintf(stderr, "MySQL query error: %s\n", mysql_error(conn));
        mysql_close(conn);
        return NULL;
    }

    res = mysql_store_result(conn);
    if ((row = mysql_fetch_row(res))) {
        customer = malloc(sizeof(Customer));
        strncpy(customer->username, row[0], sizeof(customer->username));
        strncpy(customer->name, row[1], sizeof(customer->name));
        strncpy(customer->email, row[2], sizeof(customer->email));
    }

    mysql_free_result(res);
    mysql_close(conn);
    return customer;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Please provide a customer username.\n");
        return 1;
    }

    const char* customerUsername = argv[1];
    Customer* customer = getCustomerInfo(customerUsername);

    if (customer) {
        printf("Customer(username=%s, name=%s, email=%s)\n", customer->username, customer->name, customer->email);
        free(customer);
    } else {
        printf("Customer not found.\n");
    }

    return 0;
}
```
Created file: Task67.java
Created file: Task67.py
Created file: Task67.cpp
Created file: Task67.c
Task68_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task68, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that extracts the Domain Component (dc) and username from an incoming request, constructs an LDAP query using this information, establishes a connection to the LDAP server running on localhost, and searches for the user based on the constructed query. Finally, return the user information retrieved from the LDAP server. Assume the user pass the data as command line argument (s).
```java
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import java.util.Hashtable;

public class Task68 {
    public static String ldapQuery(String domainComponent, String username) {
        String result = "";
        String ldapUrl = "ldap://localhost:389";
        Hashtable<String, String> env = new Hashtable<>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
        env.put(Context.PROVIDER_URL, ldapUrl);
        env.put(Context.SECURITY_AUTHENTICATION, "simple");
        env.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=com");
        env.put(Context.SECURITY_CREDENTIALS, "password");

        try {
            DirContext ctx = new InitialDirContext(env);
            String searchFilter = "(&(objectClass=person)(uid=" + username + "))";
            SearchControls searchControls = new SearchControls();
            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);

            NamingEnumeration<SearchResult> results = ctx.search("dc=" + domainComponent, searchFilter, searchControls);

            if (results.hasMore()) {
                SearchResult searchResult = results.next();
                result = searchResult.getNameInNamespace();
            }
            ctx.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(ldapQuery("example", "john"));
        System.out.println(ldapQuery("example", "doe"));
        System.out.println(ldapQuery("example", "admin"));
        System.out.println(ldapQuery("example", "alice"));
        System.out.println(ldapQuery("example", "bob"));
    }
}
```
```python
import ldap

def ldap_query(domain_component, username):
    result = ""
    ldap_url = "ldap://localhost:389"
    conn = ldap.initialize(ldap_url)
    conn.simple_bind_s("cn=admin,dc=example,dc=com", "password")

    search_filter = f"(&(objectClass=person)(uid={username}))"
    search_base = f"dc={domain_component}"

    try:
        ldap_result_id = conn.search(search_base, ldap.SCOPE_SUBTREE, search_filter, None)
        while True:
            result_type, result_data = conn.result(ldap_result_id, 0)
            if not result_data:
                break
            if result_type == ldap.RES_SEARCH_ENTRY:
                result = result_data[0][0]
                break
    except ldap.LDAPError as e:
        print(e)
    finally:
        conn.unbind_s()
    return result

def main():
    print(ldap_query("example", "john"))
    print(ldap_query("example", "doe"))
    print(ldap_query("example", "admin"))
    print(ldap_query("example", "alice"))
    print(ldap_query("example", "bob"))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <ldap.h>

std::string ldapQuery(const std::string &domainComponent, const std::string &username) {
    std::string result;
    LDAP *ld;
    int rc;
    std::string ldapUrl = "ldap://localhost:389";

    rc = ldap_initialize(&ld, ldapUrl.c_str());
    if (rc != LDAP_SUCCESS) {
        std::cerr << "LDAP initialization failed" << std::endl;
        return result;
    }

    rc = ldap_simple_bind_s(ld, "cn=admin,dc=example,dc=com", "password");
    if (rc != LDAP_SUCCESS) {
        std::cerr << "LDAP bind failed" << std::endl;
        ldap_unbind_ext_s(ld, NULL, NULL);
        return result;
    }

    std::string searchFilter = "(&(objectClass=person)(uid=" + username + "))";
    std::string searchBase = "dc=" + domainComponent;
    LDAPMessage *res;

    rc = ldap_search_ext_s(ld, searchBase.c_str(), LDAP_SCOPE_SUBTREE, searchFilter.c_str(), NULL, 0, NULL, NULL, NULL, 0, &res);
    if (rc != LDAP_SUCCESS) {
        std::cerr << "LDAP search failed" << std::endl;
    } else {
        LDAPMessage *entry = ldap_first_entry(ld, res);
        if (entry != NULL) {
            char *dn = ldap_get_dn(ld, entry);
            if (dn != NULL) {
                result = dn;
                ldap_memfree(dn);
            }
        }
        ldap_msgfree(res);
    }

    ldap_unbind_ext_s(ld, NULL, NULL);
    return result;
}

int main() {
    std::cout << ldapQuery("example", "john") << std::endl;
    std::cout << ldapQuery("example", "doe") << std::endl;
    std::cout << ldapQuery("example", "admin") << std::endl;
    std::cout << ldapQuery("example", "alice") << std::endl;
    std::cout << ldapQuery("example", "bob") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <ldap.h>

char* ldap_query(const char* domain_component, const char* username) {
    LDAP *ld;
    int rc;
    char *ldapUrl = "ldap://localhost:389";
    static char result[1024] = "";

    rc = ldap_initialize(&ld, ldapUrl);
    if (rc != LDAP_SUCCESS) {
        fprintf(stderr, "LDAP initialization failed\n");
        return result;
    }

    rc = ldap_simple_bind_s(ld, "cn=admin,dc=example,dc=com", "password");
    if (rc != LDAP_SUCCESS) {
        fprintf(stderr, "LDAP bind failed\n");
        ldap_unbind_ext_s(ld, NULL, NULL);
        return result;
    }

    char searchFilter[256];
    snprintf(searchFilter, sizeof(searchFilter), "(&(objectClass=person)(uid=%s))", username);
    char searchBase[256];
    snprintf(searchBase, sizeof(searchBase), "dc=%s", domain_component);

    LDAPMessage *res;
    rc = ldap_search_ext_s(ld, searchBase, LDAP_SCOPE_SUBTREE, searchFilter, NULL, 0, NULL, NULL, NULL, 0, &res);
    if (rc != LDAP_SUCCESS) {
        fprintf(stderr, "LDAP search failed\n");
    } else {
        LDAPMessage *entry = ldap_first_entry(ld, res);
        if (entry != NULL) {
            char *dn = ldap_get_dn(ld, entry);
            if (dn != NULL) {
                snprintf(result, sizeof(result), "%s", dn);
                ldap_memfree(dn);
            }
        }
        ldap_msgfree(res);
    }

    ldap_unbind_ext_s(ld, NULL, NULL);
    return result;
}

int main() {
    printf("%s\n", ldap_query("example", "john"));
    printf("%s\n", ldap_query("example", "doe"));
    printf("%s\n", ldap_query("example", "admin"));
    printf("%s\n", ldap_query("example", "alice"));
    printf("%s\n", ldap_query("example", "bob"));
    return 0;
}
```
Created file: Task68.java
Created file: Task68.py
Created file: Task68.cpp
Created file: Task68.c
Task69_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task69, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that accept the file path as an input and deletes the specified file. Assume the user pass the data as command line argument (s).
```java
import java.io.File;

public class Task69 {
    public static boolean deleteFile(String filePath) {
        try {
            File file = new File(filePath);
            if (file.exists() && file.isFile()) {
                return file.delete();
            }
        } catch (SecurityException e) {
            // Handle the exception
        }
        return false;
    }

    public static void main(String[] args) {
        // Test cases
        System.out.println(deleteFile("testfile1.txt")); // Replace with actual test file paths
        System.out.println(deleteFile("testfile2.txt"));
        System.out.println(deleteFile("testfile3.txt"));
        System.out.println(deleteFile("testfile4.txt"));
        System.out.println(deleteFile("testfile5.txt"));
    }
}
```
```python
import os

def delete_file(file_path):
    try:
        if os.path.isfile(file_path):
            os.remove(file_path)
            return True
    except Exception as e:
        # Handle the exception
        pass
    return False

if __name__ == "__main__":
    # Test cases
    print(delete_file("testfile1.txt")) # Replace with actual test file paths
    print(delete_file("testfile2.txt"))
    print(delete_file("testfile3.txt"))
    print(delete_file("testfile4.txt"))
    print(delete_file("testfile5.txt"))
```
```cpp
#include <iostream>
#include <cstdio>

bool deleteFile(const std::string& filePath) {
    if (std::remove(filePath.c_str()) == 0) {
        return true;
    }
    return false;
}

int main() {
    // Test cases
    std::cout << deleteFile("testfile1.txt") << std::endl; // Replace with actual test file paths
    std::cout << deleteFile("testfile2.txt") << std::endl;
    std::cout << deleteFile("testfile3.txt") << std::endl;
    std::cout << deleteFile("testfile4.txt") << std::endl;
    std::cout << deleteFile("testfile5.txt") << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>

bool deleteFile(const char* filePath) {
    if (remove(filePath) == 0) {
        return true;
    }
    return false;
}

int main() {
    // Test cases
    printf("%d\n", deleteFile("testfile1.txt")); // Replace with actual test file paths
    printf("%d\n", deleteFile("testfile2.txt"));
    printf("%d\n", deleteFile("testfile3.txt"));
    printf("%d\n", deleteFile("testfile4.txt"));
    printf("%d\n", deleteFile("testfile5.txt"));
    return 0;
}
```
Created file: Task69.java
Created file: Task69.py
Created file: Task69.cpp
Created file: Task69.c
Task70_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task70, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that accept the file path as an input and return the content of the requested file. Assume the user pass the data as command line argument (s).
```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Task70 {
    public static String readFile(String filePath) {
        try {
            return new String(Files.readAllBytes(Paths.get(filePath)));
        } catch (IOException e) {
            return "Error reading file: " + e.getMessage();
        }
    }

    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("Content of " + arg + ":");
            System.out.println(readFile(arg));
        }
    }
}
```
```python
import sys

def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except IOError as e:
        return f"Error reading file: {e}"

if __name__ == "__main__":
    for arg in sys.argv[1:]:
        print(f"Content of {arg}:")
        print(read_file(arg))
```
```cpp
#include <iostream>
#include <fstream>
#include <string>

void readFile(const std::string& filePath) {
    std::ifstream file(filePath);
    if (file) {
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        std::cout << content << std::endl;
    } else {
        std::cerr << "Error reading file: " << filePath << std::endl;
    }
}

int main(int argc, char* argv[]) {
    for (int i = 1; i < argc; ++i) {
        std::cout << "Content of " << argv[i] << ":" << std::endl;
        readFile(argv[i]);
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void readFile(const char* filePath) {
    FILE *file = fopen(filePath, "r");
    if (file) {
        fseek(file, 0, SEEK_END);
        long fileSize = ftell(file);
        rewind(file);
        char *content = (char*)malloc(sizeof(char) * (fileSize + 1));
        if (content) {
            fread(content, 1, fileSize, file);
            content[fileSize] = '\0';
            printf("%s\n", content);
            free(content);
        }
        fclose(file);
    } else {
        perror("Error reading file");
    }
}

int main(int argc, char *argv[]) {
    for (int i = 1; i < argc; ++i) {
        printf("Content of %s:\n", argv[i]);
        readFile(argv[i]);
    }
    return 0;
}
```
Created file: Task70.java
Created file: Task70.py
Created file: Task70.cpp
Created file: Task70.c
Task71_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task71, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Create a program that accept a string input from the user and attempts to convert it to an integer. Assume the user pass the data as command line argument (s).
```java
public class Task71 {
    public static int convertStringToInt(String input) {
        try {
            return Integer.parseInt(input.trim());
        } catch (NumberFormatException e) {
            System.out.println("Invalid input: " + input);
            return 0; // Return a default value
        }
    }

    public static void main(String[] args) {
        if (args.length < 5) {
            System.out.println("Please provide at least 5 inputs.");
            return;
        }
        for (String arg : args) {
            int result = convertStringToInt(arg);
            System.out.println("Converted: " + result);
        }
    }
}
```
```python
import sys

def convert_string_to_int(input_str):
    try:
        return int(input_str.strip())
    except ValueError:
        print(f"Invalid input: {input_str}")
        return 0

if __name__ == "__main__":
    if len(sys.argv) < 6:
        print("Please provide at least 5 inputs.")
    else:
        for arg in sys.argv[1:]:
            result = convert_string_to_int(arg)
            print(f"Converted: {result}")
```
```cpp
#include <iostream>
#include <string>
#include <cstdlib>

int convertStringToInt(const std::string &input) {
    try {
        return std::stoi(input);
    } catch (const std::invalid_argument &e) {
        std::cout << "Invalid input: " << input << std::endl;
        return 0;
    } catch (const std::out_of_range &e) {
        std::cout << "Input out of range: " << input << std::endl;
        return 0;
    }
}

int main(int argc, char *argv[]) {
    if (argc < 6) {
        std::cout << "Please provide at least 5 inputs." << std::endl;
        return 1;
    }
    for (int i = 1; i < argc; ++i) {
        int result = convertStringToInt(argv[i]);
        std::cout << "Converted: " << result << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int convertStringToInt(const char *input) {
    char *endptr;
    int result = strtol(input, &endptr, 10);
    if (*endptr != '\0') {
        printf("Invalid input: %s\n", input);
        return 0;
    }
    return result;
}

int main(int argc, char *argv[]) {
    if (argc < 6) {
        printf("Please provide at least 5 inputs.\n");
        return 1;
    }
    for (int i = 1; i < argc; ++i) {
        int result = convertStringToInt(argv[i]);
        printf("Converted: %d\n", result);
    }
    return 0;
}
```
Created file: Task71.java
Created file: Task71.py
Created file: Task71.cpp
Created file: Task71.c
Task72_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task72, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that performs the following steps to encrypt data:

Create a static initialization vector (IV).
Initialize a cipher using AES in CBC mode with the static IV.
Pad the input data to match the block size required by the cipher.
Encrypt the padded data using the cipher.
Return the encrypted data.
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

public class Task72 {
    private static final String AES = "AES";
    private static final String AES_CIPHER_ALGORITHM = "AES/CBC/PKCS5Padding";

    public static byte[] encryptData(byte[] inputData, SecretKey key, IvParameterSpec iv) throws Exception {
        Cipher cipher = Cipher.getInstance(AES_CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        return cipher.doFinal(inputData);
    }

    public static void main(String[] args) throws Exception {
        // Test cases
        SecureRandom secureRandom = new SecureRandom();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(AES);
        keyGenerator.init(256, secureRandom);
        SecretKey secretKey = keyGenerator.generateKey();

        byte[] ivBytes = new byte[16];
        secureRandom.nextBytes(ivBytes);
        IvParameterSpec iv = new IvParameterSpec(ivBytes);

        String[] testData = {"Test1", "Test2", "Data", "SecureData", "EncryptThis"};
        for (String data : testData) {
            byte[] encryptedData = encryptData(data.getBytes(), secretKey, iv);
            System.out.println(Base64.getEncoder().encodeToString(encryptedData));
        }
    }
}
```
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes
import base64

def encrypt_data(input_data: bytes, key: bytes, iv: bytes) -> bytes:
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_data = pad(input_data, AES.block_size)
    return cipher.encrypt(padded_data)

def main():
    # Test cases
    key = get_random_bytes(32)  # AES-256
    iv = get_random_bytes(16)
    test_data = ["Test1", "Test2", "Data", "SecureData", "EncryptThis"]

    for data in test_data:
        encrypted_data = encrypt_data(data.encode(), key, iv)
        print(base64.b64encode(encrypted_data).decode())

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <iomanip>
#include <string>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/aes.h>

std::string encryptData(const std::string& inputData, const unsigned char* key, const unsigned char* iv) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    unsigned char ciphertext[inputData.size() + AES_BLOCK_SIZE];
    int len, ciphertext_len;

    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv);
    EVP_EncryptUpdate(ctx, ciphertext, &len, (unsigned char*)inputData.c_str(), inputData.size());
    ciphertext_len = len;
    EVP_EncryptFinal_ex(ctx, ciphertext + len, &len);
    ciphertext_len += len;
    EVP_CIPHER_CTX_free(ctx);

    return std::string((char*)ciphertext, ciphertext_len);
}

int main() {
    unsigned char key[32];
    unsigned char iv[16];
    RAND_bytes(key, sizeof(key));
    RAND_bytes(iv, sizeof(iv));

    std::string testData[] = {"Test1", "Test2", "Data", "SecureData", "EncryptThis"};
    for (const auto& data : testData) {
        std::string encryptedData = encryptData(data, key, iv);
        std::cout << std::hex << std::setfill('0');
        for (unsigned char c : encryptedData) {
            std::cout << std::setw(2) << (int)c;
        }
        std::cout << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/aes.h>

void encryptData(const unsigned char* inputData, int inputLen, unsigned char* key, unsigned char* iv, unsigned char* encryptedData, int* encryptedLen) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    int len;

    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv);
    EVP_EncryptUpdate(ctx, encryptedData, &len, inputData, inputLen);
    *encryptedLen = len;
    EVP_EncryptFinal_ex(ctx, encryptedData + len, &len);
    *encryptedLen += len;
    EVP_CIPHER_CTX_free(ctx);
}

int main() {
    unsigned char key[32];
    unsigned char iv[16];
    RAND_bytes(key, sizeof(key));
    RAND_bytes(iv, sizeof(iv));

    char* testData[] = {"Test1", "Test2", "Data", "SecureData", "EncryptThis"};
    for (int i = 0; i < 5; i++) {
        unsigned char encryptedData[128];
        int encryptedLen;
        encryptData((unsigned char*)testData[i], strlen(testData[i]), key, iv, encryptedData, &encryptedLen);

        for (int j = 0; j < encryptedLen; j++) {
            printf("%02x", encryptedData[j]);
        }
        printf("\n");
    }

    return 0;
}
```
Created file: Task72.java
Created file: Task72.py
Created file: Task72.cpp
Created file: Task72.c
Task73_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task73, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program check if a given password is valid for an admin user.
```java
public class Task73 {
    public static boolean isValidPassword(String password) {
        if (password == null || password.length() < 8) return false;
        boolean hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;
        for (char ch : password.toCharArray()) {
            if (Character.isUpperCase(ch)) hasUpper = true;
            else if (Character.isLowerCase(ch)) hasLower = true;
            else if (Character.isDigit(ch)) hasDigit = true;
            else if ("!@#$%^&*()-_+=<>?/".indexOf(ch) >= 0) hasSpecial = true;
        }
        return hasUpper && hasLower && hasDigit && hasSpecial;
    }

    public static void main(String[] args) {
        System.out.println(isValidPassword("Admin123!")); // true
        System.out.println(isValidPassword("admin123")); // false
        System.out.println(isValidPassword("ADMIN123!")); // false
        System.out.println(isValidPassword("Admin!")); // false
        System.out.println(isValidPassword("Admin12345")); // false
    }
}
```
```python
def is_valid_password(password):
    if not password or len(password) < 8:
        return False
    has_upper = has_lower = has_digit = has_special = False
    for ch in password:
        if ch.isupper():
            has_upper = True
        elif ch.islower():
            has_lower = True
        elif ch.isdigit():
            has_digit = True
        elif ch in "!@#$%^&*()-_+=<>?/":
            has_special = True
    return has_upper and has_lower and has_digit and has_special

if __name__ == "__main__":
    print(is_valid_password("Admin123!"))  # True
    print(is_valid_password("admin123"))   # False
    print(is_valid_password("ADMIN123!"))  # False
    print(is_valid_password("Admin!"))     # False
    print(is_valid_password("Admin12345")) # False
```
```cpp
#include <iostream>
#include <string>

bool isValidPassword(const std::string& password) {
    if (password.length() < 8) return false;
    bool hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;
    for (char ch : password) {
        if (std::isupper(ch)) hasUpper = true;
        else if (std::islower(ch)) hasLower = true;
        else if (std::isdigit(ch)) hasDigit = true;
        else if (std::string("!@#$%^&*()-_+=<>?/").find(ch) != std::string::npos) hasSpecial = true;
    }
    return hasUpper && hasLower && hasDigit && hasSpecial;
}

int main() {
    std::cout << std::boolalpha;
    std::cout << isValidPassword("Admin123!") << std::endl; // true
    std::cout << isValidPassword("admin123") << std::endl; // false
    std::cout << isValidPassword("ADMIN123!") << std::endl; // false
    std::cout << isValidPassword("Admin!") << std::endl; // false
    std::cout << isValidPassword("Admin12345") << std::endl; // false
    return 0;
}
```
```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

bool isValidPassword(const char* password) {
    if (strlen(password) < 8) return false;
    bool hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;
    for (int i = 0; password[i] != '\0'; i++) {
        if (isupper(password[i])) hasUpper = true;
        else if (islower(password[i])) hasLower = true;
        else if (isdigit(password[i])) hasDigit = true;
        else if (strchr("!@#$%^&*()-_+=<>?/", password[i])) hasSpecial = true;
    }
    return hasUpper && hasLower && hasDigit && hasSpecial;
}

int main() {
    printf("%d\n", isValidPassword("Admin123!")); // 1 (true)
    printf("%d\n", isValidPassword("admin123")); // 0 (false)
    printf("%d\n", isValidPassword("ADMIN123!")); // 0 (false)
    printf("%d\n", isValidPassword("Admin!")); // 0 (false)
    printf("%d\n", isValidPassword("Admin12345")); // 0 (false)
    return 0;
}
```
Created file: Task73.java
Created file: Task73.py
Created file: Task73.cpp
Created file: Task73.c
Task74_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task74, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program to create and return a connection object for a Postgres database.
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class Task74 {
    public static Connection getPostgresConnection(String url, String user, String password) {
        Connection conn = null;
        try {
            conn = DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    public static void main(String[] args) {
        // Example test cases
        System.out.println(getPostgresConnection("jdbc:postgresql://localhost:5432/testdb", "user", "pass"));
        System.out.println(getPostgresConnection("jdbc:postgresql://localhost:5432/testdb2", "user2", "pass2"));
        System.out.println(getPostgresConnection("jdbc:postgresql://localhost:5432/testdb3", "user3", "pass3"));
        System.out.println(getPostgresConnection("jdbc:postgresql://localhost:5432/testdb4", "user4", "pass4"));
        System.out.println(getPostgresConnection("jdbc:postgresql://localhost:5432/testdb5", "user5", "pass5"));
    }
}
```
```python
import psycopg2
from psycopg2 import sql

def get_postgres_connection(database, user, password, host='localhost', port='5432'):
    try:
        conn = psycopg2.connect(dbname=database, user=user, password=password, host=host, port=port)
        return conn
    except psycopg2.DatabaseError as e:
        print(e)
        return None

# Example test cases
print(get_postgres_connection("testdb", "user", "pass"))
print(get_postgres_connection("testdb2", "user2", "pass2"))
print(get_postgres_connection("testdb3", "user3", "pass3"))
print(get_postgres_connection("testdb4", "user4", "pass4"))
print(get_postgres_connection("testdb5", "user5", "pass5"))
```
```cpp
#include <iostream>
#include <pqxx/pqxx>

using namespace std;

pqxx::connection* getPostgresConnection(const string& conninfo) {
    try {
        pqxx::connection* C = new pqxx::connection(conninfo);
        if (C->is_open()) {
            return C;
        } else {
            delete C;
            return nullptr;
        }
    } catch (const std::exception &e) {
        cerr << e.what() << std::endl;
        return nullptr;
    }
}

int main() {
    // Example test cases
    cout << getPostgresConnection("dbname=testdb user=user password=pass") << endl;
    cout << getPostgresConnection("dbname=testdb2 user=user2 password=pass2") << endl;
    cout << getPostgresConnection("dbname=testdb3 user=user3 password=pass3") << endl;
    cout << getPostgresConnection("dbname=testdb4 user=user4 password=pass4") << endl;
    cout << getPostgresConnection("dbname=testdb5 user=user5 password=pass5") << endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

PGconn* getPostgresConnection(const char* conninfo) {
    PGconn* conn = PQconnectdb(conninfo);
    if (PQstatus(conn) != CONNECTION_OK) {
        fprintf(stderr, "Connection to database failed: %s", PQerrorMessage(conn));
        PQfinish(conn);
        return NULL;
    }
    return conn;
}

int main() {
    // Example test cases
    printf("%p\n", getPostgresConnection("dbname=testdb user=user password=pass"));
    printf("%p\n", getPostgresConnection("dbname=testdb2 user=user2 password=pass2"));
    printf("%p\n", getPostgresConnection("dbname=testdb3 user=user3 password=pass3"));
    printf("%p\n", getPostgresConnection("dbname=testdb4 user=user4 password=pass4"));
    printf("%p\n", getPostgresConnection("dbname=testdb5 user=user5 password=pass5"));
    return 0;
}
```
Created file: Task74.java
Created file: Task74.py
Created file: Task74.cpp
Created file: Task74.c
Task75_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task75, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that terminates the process identified by a given process ID (PID). Assume the user pass the data as command line argument (s).
```java
public class Task75 {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Please provide a PID.");
            return;
        }
        for (String arg : args) {
            try {
                int pid = Integer.parseInt(arg);
                terminateProcess(pid);
            } catch (NumberFormatException e) {
                System.out.println("Invalid PID: " + arg);
            }
        }
    }

    public static void terminateProcess(int pid) {
        try {
            ProcessBuilder processBuilder = new ProcessBuilder("kill", "-9", String.valueOf(pid));
            processBuilder.start();
        } catch (Exception e) {
            System.out.println("Error terminating process with PID: " + pid);
        }
    }
}
```
```python
import os
import sys

def terminate_process(pid):
    try:
        os.kill(pid, 9)
    except OSError:
        print(f"Error terminating process with PID: {pid}")

def main():
    if len(sys.argv) < 2:
        print("Please provide a PID.")
        return
    for arg in sys.argv[1:]:
        try:
            pid = int(arg)
            terminate_process(pid)
        except ValueError:
            print(f"Invalid PID: {arg}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <csignal>
#include <cstdlib>

void terminateProcess(int pid) {
    if (kill(pid, SIGKILL) != 0) {
        std::cerr << "Error terminating process with PID: " << pid << std::endl;
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        std::cerr << "Please provide a PID." << std::endl;
        return 1;
    }
    for (int i = 1; i < argc; ++i) {
        try {
            int pid = std::stoi(argv[i]);
            terminateProcess(pid);
        } catch (const std::invalid_argument &e) {
            std::cerr << "Invalid PID: " << argv[i] << std::endl;
        }
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void terminateProcess(int pid) {
    if (kill(pid, SIGKILL) != 0) {
        perror("Error terminating process");
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Please provide a PID.\n");
        return 1;
    }
    for (int i = 1; i < argc; ++i) {
        int pid = atoi(argv[i]);
        if (pid <= 0) {
            printf("Invalid PID: %s\n", argv[i]);
            continue;
        }
        terminateProcess(pid);
    }
    return 0;
}
```
Created file: Task75.java
Created file: Task75.py
Created file: Task75.cpp
Created file: Task75.c
Task76_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task76, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that makes an HTTP call to a provided HTTPS URL parameter. The function should retrieve the content of the webpage and extract the page title from the HTML. Return the extracted page title. Assume the user pass the data as command line argument (s).
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Task76 {
    public static String getPageTitle(String httpsUrl) {
        StringBuilder content = new StringBuilder();
        try {
            URL url = new URL(httpsUrl);
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            connection.setRequestMethod("GET");

            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    content.append(inputLine);
                }
            }

            String htmlContent = content.toString();
            Pattern pattern = Pattern.compile("<title>(.*?)</title>", Pattern.CASE_INSENSITIVE);
            Matcher matcher = pattern.matcher(htmlContent);
            if (matcher.find()) {
                return matcher.group(1);
            } else {
                return "No title found";
            }
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    public static void main(String[] args) {
        if (args.length > 0) {
            for (String url : args) {
                System.out.println(getPageTitle(url));
            }
        } else {
            System.out.println("Please provide HTTPS URLs as command line arguments.");
        }
    }
}
```
```python
import requests
import sys
import re

def get_page_title(https_url):
    try:
        response = requests.get(https_url)
        response.raise_for_status()
        match = re.search(r'<title>(.*?)</title>', response.text, re.IGNORECASE)
        if match:
            return match.group(1)
        return "No title found"
    except requests.RequestException as e:
        return f"Error: {e}"

if __name__ == "__main__":
    if len(sys.argv) > 1:
        for url in sys.argv[1:]:
            print(get_page_title(url))
    else:
        print("Please provide HTTPS URLs as command line arguments.")
```
```cpp
#include <iostream>
#include <string>
#include <regex>
#include <curl/curl.h>

class Task76 {
public:
    static std::string getPageTitle(const std::string& httpsUrl) {
        CURL* curl;
        CURLcode res;
        std::string readBuffer;

        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
        if(curl) {
            curl_easy_setopt(curl, CURLOPT_URL, httpsUrl.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
            res = curl_easy_perform(curl);
            curl_easy_cleanup(curl);
        }
        curl_global_cleanup();

        if(res != CURLE_OK) {
            return "Error: Unable to fetch page";
        }

        std::regex titleRegex("<title>(.*?)</title>", std::regex_constants::icase);
        std::smatch match;
        if (std::regex_search(readBuffer, match, titleRegex) && match.size() > 1) {
            return match.str(1);
        } else {
            return "No title found";
        }
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
};

int main(int argc, char* argv[]) {
    if (argc > 1) {
        for (int i = 1; i < argc; ++i) {
            std::cout << Task76::getPageTitle(argv[i]) << std::endl;
        }
    } else {
        std::cout << "Please provide HTTPS URLs as command line arguments." << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <regex.h>

struct MemoryStruct {
    char *memory;
    size_t size;
};

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;

    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if(ptr == NULL) {
        printf("Not enough memory (realloc returned NULL)\n");
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

char* getPageTitle(const char *httpsUrl) {
    CURL *curl_handle;
    CURLcode res;
    struct MemoryStruct chunk;
    chunk.memory = malloc(1);
    chunk.size = 0;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_handle = curl_easy_init();

    if(curl_handle) {
        curl_easy_setopt(curl_handle, CURLOPT_URL, httpsUrl);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
        res = curl_easy_perform(curl_handle);
        curl_easy_cleanup(curl_handle);

        if(res != CURLE_OK) {
            free(chunk.memory);
            return strdup("Error: Unable to fetch page");
        }
    }
    curl_global_cleanup();

    regex_t regex;
    regmatch_t pmatch[2];
    if (regcomp(&regex, "<title>(.*?)</title>", REG_ICASE | REG_EXTENDED) != 0) {
        free(chunk.memory);
        return strdup("Regex compilation failed");
    }
    if (regexec(&regex, chunk.memory, 2, pmatch, 0) == 0) {
        size_t len = pmatch[1].rm_eo - pmatch[1].rm_so;
        char *title = (char *)malloc(len + 1);
        strncpy(title, chunk.memory + pmatch[1].rm_so, len);
        title[len] = '\0';
        regfree(&regex);
        free(chunk.memory);
        return title;
    }
    regfree(&regex);
    free(chunk.memory);
    return strdup("No title found");
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        for (int i = 1; i < argc; ++i) {
            char *title = getPageTitle(argv[i]);
            printf("%s\n", title);
            free(title);
        }
    } else {
        printf("Please provide HTTPS URLs as command line arguments.\n");
    }
    return 0;
}
```
Created file: Task76.java
Created file: Task76.py
Created file: Task76.cpp
Created file: Task76.c
Task77_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task77, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that  that connects to an FTP server using the provided hostname, logs in with the specified username and password, and downloads a sensitive file from the FTP server to the current directory. Assume the user pass the data as command line argument (s).
```java
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;

public class Task77 {
    public static void downloadFile(String hostname, String username, String password, String remoteFile) {
        FTPClient ftpClient = new FTPClient();
        try {
            ftpClient.connect(hostname);
            if (ftpClient.login(username, password)) {
                ftpClient.enterLocalPassiveMode();
                ftpClient.setFileType(FTP.BINARY_FILE_TYPE);

                try (FileOutputStream fos = new FileOutputStream(remoteFile)) {
                    boolean success = ftpClient.retrieveFile(remoteFile, fos);
                    if (success) {
                        System.out.println("File has been downloaded successfully.");
                    } else {
                        System.out.println("Failed to download file.");
                    }
                }
                ftpClient.logout();
            }
        } catch (IOException ex) {
            System.out.println("Error: " + ex.getMessage());
            ex.printStackTrace();
        } finally {
            try {
                if (ftpClient.isConnected()) {
                    ftpClient.disconnect();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        // Test cases
        downloadFile("ftp.example.com", "username", "password", "sensitiveFile1.txt");
        downloadFile("ftp.example.com", "username", "password", "sensitiveFile2.txt");
        downloadFile("ftp.example.com", "username", "password", "sensitiveFile3.txt");
        downloadFile("ftp.example.com", "username", "password", "sensitiveFile4.txt");
        downloadFile("ftp.example.com", "username", "password", "sensitiveFile5.txt");
    }
}
```
```python
from ftplib import FTP, error_perm
import sys

def download_file(hostname, username, password, remote_file):
    try:
        with FTP(hostname) as ftp:
            ftp.login(user=username, passwd=password)
            ftp.set_pasv(True)
            with open(remote_file, 'wb') as f:
                ftp.retrbinary(f'RETR {remote_file}', f.write)
            print("File has been downloaded successfully.")
    except error_perm as e:
        print(f"FTP error: {e}")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    # Test cases
    download_file("ftp.example.com", "username", "password", "sensitiveFile1.txt")
    download_file("ftp.example.com", "username", "password", "sensitiveFile2.txt")
    download_file("ftp.example.com", "username", "password", "sensitiveFile3.txt")
    download_file("ftp.example.com", "username", "password", "sensitiveFile4.txt")
    download_file("ftp.example.com", "username", "password", "sensitiveFile5.txt")
```
```cpp
#include <iostream>
#include <fstream>
#include <cstring>
#include <stdexcept>
#include <curl/curl.h>

class Task77 {
public:
    static void downloadFile(const std::string& hostname, const std::string& username, const std::string& password, const std::string& remoteFile) {
        CURL* curl;
        CURLcode res;
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            std::string ftp_url = "ftp://" + hostname + "/" + remoteFile;
            std::ofstream ofs(remoteFile, std::ios::binary);

            if (!ofs.is_open()) {
                std::cerr << "Could not open file for writing: " << remoteFile << std::endl;
                return;
            }

            curl_easy_setopt(curl, CURLOPT_URL, ftp_url.c_str());
            curl_easy_setopt(curl, CURLOPT_USERNAME, username.c_str());
            curl_easy_setopt(curl, CURLOPT_PASSWORD, password.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeFileCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ofs);

            res = curl_easy_perform(curl);
            if (res != CURLE_OK) {
                std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
            } else {
                std::cout << "File has been downloaded successfully." << std::endl;
            }

            ofs.close();
            curl_easy_cleanup(curl);
        }

        curl_global_cleanup();
    }

private:
    static size_t writeFileCallback(void* ptr, size_t size, size_t nmemb, void* stream) {
        std::ofstream* ofs = static_cast<std::ofstream*>(stream);
        ofs->write(static_cast<char*>(ptr), size * nmemb);
        return size * nmemb;
    }
};

int main() {
    // Test cases
    Task77::downloadFile("ftp.example.com", "username", "password", "sensitiveFile1.txt");
    Task77::downloadFile("ftp.example.com", "username", "password", "sensitiveFile2.txt");
    Task77::downloadFile("ftp.example.com", "username", "password", "sensitiveFile3.txt");
    Task77::downloadFile("ftp.example.com", "username", "password", "sensitiveFile4.txt");
    Task77::downloadFile("ftp.example.com", "username", "password", "sensitiveFile5.txt");
    return 0;
}
```
```c
#include <stdio.h>
#include <curl/curl.h>

size_t writeFileCallback(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    return fwrite(ptr, size, nmemb, stream);
}

void downloadFile(const char *hostname, const char *username, const char *password, const char *remoteFile) {
    CURL *curl;
    CURLcode res;
    char ftp_url[256];

    snprintf(ftp_url, sizeof(ftp_url), "ftp://%s/%s", hostname, remoteFile);

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
        FILE *fp = fopen(remoteFile, "wb");
        if (!fp) {
            fprintf(stderr, "Could not open file for writing: %s\n", remoteFile);
            return;
        }

        curl_easy_setopt(curl, CURLOPT_URL, ftp_url);
        curl_easy_setopt(curl, CURLOPT_USERNAME, username);
        curl_easy_setopt(curl, CURLOPT_PASSWORD, password);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeFileCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);

        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        } else {
            printf("File has been downloaded successfully.\n");
        }

        fclose(fp);
        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
}

int main() {
    // Test cases
    downloadFile("ftp.example.com", "username", "password", "sensitiveFile1.txt");
    downloadFile("ftp.example.com", "username", "password", "sensitiveFile2.txt");
    downloadFile("ftp.example.com", "username", "password", "sensitiveFile3.txt");
    downloadFile("ftp.example.com", "username", "password", "sensitiveFile4.txt");
    downloadFile("ftp.example.com", "username", "password", "sensitiveFile5.txt");
    return 0;
}
```
Created file: Task77.java
Created file: Task77.py
Created file: Task77.cpp
Created file: Task77.c
Task78_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task78, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that generates an RSA private key, exports it using the OpenSSH format, and returns the key in the desired format.
```java
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.Security;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
import org.bouncycastle.openssl.jcajce.JceOpenSSHPKCS8PrivateKeyConverter;

import java.io.StringWriter;
import java.io.IOException;

public class Task78 {

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static String generateAndExportRSAPrivateKey() {
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA", "BC");
            keyGen.initialize(2048);
            KeyPair pair = keyGen.generateKeyPair();
            PrivateKey privateKey = pair.getPrivate();

            JceOpenSSHPKCS8PrivateKeyConverter converter = new JceOpenSSHPKCS8PrivateKeyConverter();
            StringWriter stringWriter = new StringWriter();
            try (JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter)) {
                pemWriter.writeObject(converter.getPrivateKey(privateKey));
            }

            return stringWriter.toString();
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate RSA key", e);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            System.out.println("Test " + (i + 1) + ":");
            System.out.println(generateAndExportRSAPrivateKey());
        }
    }
}
```
```python
from Crypto.PublicKey import RSA
from Crypto.IO import PEM

def generate_and_export_rsa_private_key():
    key = RSA.generate(2048)
    private_key = key.export_key(format='PEM', pkcs=8)
    return private_key.decode('utf-8')

if __name__ == "__main__":
    for i in range(5):
        print(f"Test {i + 1}:")
        print(generate_and_export_rsa_private_key())
```
```cpp
#include <iostream>
#include <string>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

std::string generateAndExportRSAPrivateKey() {
    std::string result;
    BIGNUM* bn = BN_new();
    RSA* rsa = RSA_new();
    BIO* bio = BIO_new(BIO_s_mem());

    if (!BN_set_word(bn, RSA_F4) || !RSA_generate_key_ex(rsa, 2048, bn, NULL)) {
        result = "Error generating RSA key";
    } else {
        PEM_write_bio_RSAPrivateKey(bio, rsa, NULL, NULL, 0, NULL, NULL);
        char* pem_data = nullptr;
        long len = BIO_get_mem_data(bio, &pem_data);
        result = std::string(pem_data, len);
    }

    BN_free(bn);
    RSA_free(rsa);
    BIO_free(bio);

    return result;
}

int main() {
    for (int i = 0; i < 5; ++i) {
        std::cout << "Test " << (i + 1) << ":\n";
        std::cout << generateAndExportRSAPrivateKey() << "\n";
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>

char* generateAndExportRSAPrivateKey() {
    BIGNUM* bn = BN_new();
    RSA* rsa = RSA_new();
    BIO* bio = BIO_new(BIO_s_mem());

    if (!BN_set_word(bn, RSA_F4) || !RSA_generate_key_ex(rsa, 2048, bn, NULL)) {
        return "Error generating RSA key";
    } else {
        PEM_write_bio_RSAPrivateKey(bio, rsa, NULL, NULL, 0, NULL, NULL);
        char* pem_data = NULL;
        long len = BIO_get_mem_data(bio, &pem_data);
        char* result = (char*)malloc(len + 1);
        if (result) {
            memcpy(result, pem_data, len);
            result[len] = '\0';
        }
        BN_free(bn);
        RSA_free(rsa);
        BIO_free(bio);
        return result;
    }
}

int main() {
    for (int i = 0; i < 5; ++i) {
        printf("Test %d:\n", i + 1);
        char* key = generateAndExportRSAPrivateKey();
        printf("%s\n", key);
        free(key);
    }
    return 0;
}
```
Created file: Task78.java
Created file: Task78.py
Created file: Task78.cpp
Created file: Task78.c
Task79_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task79, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that encrypts a message using a secret key. The function should perform the following tasks:

Create a cipher for encryption.
Encrypt the message using the secret key and the cipher.
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Task79 {

    public static String encrypt(String message, byte[] secretKey) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(secretKey, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        byte[] encrypted = cipher.doFinal(message.getBytes("UTF-8"));
        return Base64.getEncoder().encodeToString(encrypted);
    }

    public static void main(String[] args) throws Exception {
        // Generating a secret key for AES encryption
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(128);
        SecretKey secretKey = keyGenerator.generateKey();
        byte[] secretKeyBytes = secretKey.getEncoded();

        // Test cases
        System.out.println(encrypt("Hello, World!", secretKeyBytes));
        System.out.println(encrypt("Java encryption", secretKeyBytes));
        System.out.println(encrypt("Secure message", secretKeyBytes));
        System.out.println(encrypt("Encrypt this text", secretKeyBytes));
        System.out.println(encrypt("End-to-end encryption", secretKeyBytes));
    }
}
```
```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import base64

def encrypt(message, secret_key):
    cipher = AES.new(secret_key, AES.MODE_EAX)
    ciphertext, tag = cipher.encrypt_and_digest(message.encode('utf-8'))
    return base64.b64encode(cipher.nonce + tag + ciphertext).decode('utf-8')

def main():
    # Generating a secret key for AES encryption
    secret_key = get_random_bytes(16)

    # Test cases
    print(encrypt("Hello, World!", secret_key))
    print(encrypt("Python encryption", secret_key))
    print(encrypt("Secure message", secret_key))
    print(encrypt("Encrypt this text", secret_key))
    print(encrypt("End-to-end encryption", secret_key))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <vector>

std::string encrypt(const std::string& message, const std::vector<unsigned char>& secret_key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    std::vector<unsigned char> ciphertext(message.size() + EVP_MAX_BLOCK_LENGTH);
    int len, ciphertext_len;

    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, secret_key.data(), NULL);
    EVP_EncryptUpdate(ctx, ciphertext.data(), &len, reinterpret_cast<const unsigned char*>(message.data()), message.size());
    ciphertext_len = len;
    EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len);
    ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return std::string(ciphertext.begin(), ciphertext.begin() + ciphertext_len);
}

int main() {
    // Generating a secret key for AES encryption
    std::vector<unsigned char> secret_key(16);
    RAND_bytes(secret_key.data(), secret_key.size());

    // Test cases
    std::cout << encrypt("Hello, World!", secret_key) << std::endl;
    std::cout << encrypt("C++ encryption", secret_key) << std::endl;
    std::cout << encrypt("Secure message", secret_key) << std::endl;
    std::cout << encrypt("Encrypt this text", secret_key) << std::endl;
    std::cout << encrypt("End-to-end encryption", secret_key) << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

void encrypt(const char* message, const unsigned char* secret_key, unsigned char* ciphertext, int* len) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    int ciphertext_len;

    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, secret_key, NULL);
    EVP_EncryptUpdate(ctx, ciphertext, len, (unsigned char*)message, strlen(message));
    ciphertext_len = *len;
    EVP_EncryptFinal_ex(ctx, ciphertext + *len, len);
    ciphertext_len += *len;

    EVP_CIPHER_CTX_free(ctx);
    *len = ciphertext_len;
}

int main() {
    // Generating a secret key for AES encryption
    unsigned char secret_key[16];
    RAND_bytes(secret_key, sizeof(secret_key));

    // Test cases
    unsigned char ciphertext[128];
    int len;
    encrypt("Hello, World!", secret_key, ciphertext, &len);
    printf("%.*s\n", len, ciphertext);

    encrypt("C encryption", secret_key, ciphertext, &len);
    printf("%.*s\n", len, ciphertext);

    encrypt("Secure message", secret_key, ciphertext, &len);
    printf("%.*s\n", len, ciphertext);

    encrypt("Encrypt this text", secret_key, ciphertext, &len);
    printf("%.*s\n", len, ciphertext);

    encrypt("End-to-end encryption", secret_key, ciphertext, &len);
    printf("%.*s\n", len, ciphertext);

    return 0;
}
```
Created file: Task79.java
Created file: Task79.py
Created file: Task79.cpp
Created file: Task79.c
Task80_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task80, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that that creates an SSL client socket using IPv6 and TCP protocol. The function should connect to a specified host and port, and then return the established socket.
```java
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import java.io.IOException;

public class Task80 {
    public static SSLSocket createSSLClientSocket(String host, int port) throws IOException {
        SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
        return (SSLSocket) factory.createSocket(host, port);
    }

    public static void main(String[] args) {
        try {
            SSLSocket socket1 = createSSLClientSocket("localhost", 443);
            SSLSocket socket2 = createSSLClientSocket("localhost", 8443);
            SSLSocket socket3 = createSSLClientSocket("::1", 443);
            SSLSocket socket4 = createSSLClientSocket("::1", 8443);
            SSLSocket socket5 = createSSLClientSocket("localhost", 10443);

            System.out.println("All sockets created successfully.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
```python
import socket
import ssl

def create_ssl_client_socket(host, port):
    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(socket.AF_INET6), server_hostname=host)
    conn.connect((host, port))
    return conn

if __name__ == "__main__":
    try:
        socket1 = create_ssl_client_socket("localhost", 443)
        socket2 = create_ssl_client_socket("localhost", 8443)
        socket3 = create_ssl_client_socket("::1", 443)
        socket4 = create_ssl_client_socket("::1", 8443)
        socket5 = create_ssl_client_socket("localhost", 10443)

        print("All sockets created successfully.")
    except Exception as e:
        print(e)
```
```cpp
#include <iostream>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <arpa/inet.h>
#include <unistd.h>

class Task80 {
public:
    static SSL* createSSLClientSocket(const char* host, int port) {
        SSL_library_init();
        SSL_CTX* ctx = SSL_CTX_new(SSLv23_client_method());
        if (!ctx) {
            ERR_print_errors_fp(stderr);
            return nullptr;
        }

        SSL* ssl = SSL_new(ctx);
        if (!ssl) {
            ERR_print_errors_fp(stderr);
            SSL_CTX_free(ctx);
            return nullptr;
        }

        int sock = socket(AF_INET6, SOCK_STREAM, 0);
        if (sock < 0) {
            perror("Unable to create socket");
            SSL_free(ssl);
            SSL_CTX_free(ctx);
            return nullptr;
        }

        struct sockaddr_in6 addr;
        addr.sin6_family = AF_INET6;
        addr.sin6_port = htons(port);
        if (inet_pton(AF_INET6, host, &addr.sin6_addr) <= 0) {
            perror("Invalid address");
            close(sock);
            SSL_free(ssl);
            SSL_CTX_free(ctx);
            return nullptr;
        }

        if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            perror("Connection failed");
            close(sock);
            SSL_free(ssl);
            SSL_CTX_free(ctx);
            return nullptr;
        }

        SSL_set_fd(ssl, sock);
        if (SSL_connect(ssl) <= 0) {
            ERR_print_errors_fp(stderr);
            close(sock);
            SSL_free(ssl);
            SSL_CTX_free(ctx);
            return nullptr;
        }

        return ssl;
    }
};

int main() {
    try {
        SSL* socket1 = Task80::createSSLClientSocket("::1", 443);
        SSL* socket2 = Task80::createSSLClientSocket("::1", 8443);
        SSL* socket3 = Task80::createSSLClientSocket("::1", 10443);
        SSL* socket4 = Task80::createSSLClientSocket("::1", 11443);
        SSL* socket5 = Task80::createSSLClientSocket("::1", 12443);

        std::cout << "All sockets created successfully." << std::endl;

        SSL_free(socket1);
        SSL_free(socket2);
        SSL_free(socket3);
        SSL_free(socket4);
        SSL_free(socket5);
    } catch (...) {
        std::cerr << "An error occurred." << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

SSL* createSSLClientSocket(const char* host, int port) {
    SSL_library_init();
    SSL_CTX* ctx = SSL_CTX_new(SSLv23_client_method());
    if (!ctx) {
        ERR_print_errors_fp(stderr);
        return NULL;
    }

    SSL* ssl = SSL_new(ctx);
    if (!ssl) {
        ERR_print_errors_fp(stderr);
        SSL_CTX_free(ctx);
        return NULL;
    }

    int sock = socket(AF_INET6, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Unable to create socket");
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        return NULL;
    }

    struct sockaddr_in6 addr;
    addr.sin6_family = AF_INET6;
    addr.sin6_port = htons(port);
    if (inet_pton(AF_INET6, host, &addr.sin6_addr) <= 0) {
        perror("Invalid address");
        close(sock);
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        return NULL;
    }

    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("Connection failed");
        close(sock);
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        return NULL;
    }

    SSL_set_fd(ssl, sock);
    if (SSL_connect(ssl) <= 0) {
        ERR_print_errors_fp(stderr);
        close(sock);
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        return NULL;
    }

    return ssl;
}

int main() {
    SSL* socket1 = createSSLClientSocket("::1", 443);
    SSL* socket2 = createSSLClientSocket("::1", 8443);
    SSL* socket3 = createSSLClientSocket("::1", 10443);
    SSL* socket4 = createSSLClientSocket("::1", 11443);
    SSL* socket5 = createSSLClientSocket("::1", 12443);

    if (socket1 && socket2 && socket3 && socket4 && socket5) {
        printf("All sockets created successfully.\n");
    } else {
        printf("Failed to create sockets.\n");
    }

    SSL_free(socket1);
    SSL_free(socket2);
    SSL_free(socket3);
    SSL_free(socket4);
    SSL_free(socket5);

    return 0;
}
```
Created file: Task80.java
Created file: Task80.py
Created file: Task80.cpp
Created file: Task80.c
Task81_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task81, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that checks whether a given SSL certificate matches a known hash.
```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Task81 {
    public static boolean verifySSLCertificate(String certificate, String knownHash) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] certBytes = certificate.getBytes();
            byte[] certHash = md.digest(certBytes);
            StringBuilder hexString = new StringBuilder();

            for (byte b : certHash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }

            return hexString.toString().equals(knownHash);
        } catch (NoSuchAlgorithmException e) {
            return false;
        }
    }

    public static void main(String[] args) {
        System.out.println(verifySSLCertificate("testCertificate1", "d2d2d2d2...")); // replace with actual test data
        System.out.println(verifySSLCertificate("testCertificate2", "e3e3e3e3...")); // replace with actual test data
        System.out.println(verifySSLCertificate("testCertificate3", "f4f4f4f4...")); // replace with actual test data
        System.out.println(verifySSLCertificate("testCertificate4", "a1a1a1a1...")); // replace with actual test data
        System.out.println(verifySSLCertificate("testCertificate5", "b2b2b2b2...")); // replace with actual test data
    }
}
```
```python
import hashlib

def verify_ssl_certificate(certificate: str, known_hash: str) -> bool:
    cert_hash = hashlib.sha256(certificate.encode()).hexdigest()
    return cert_hash == known_hash

if __name__ == "__main__":
    print(verify_ssl_certificate("testCertificate1", "d2d2d2d2...")) # replace with actual test data
    print(verify_ssl_certificate("testCertificate2", "e3e3e3e3...")) # replace with actual test data
    print(verify_ssl_certificate("testCertificate3", "f4f4f4f4...")) # replace with actual test data
    print(verify_ssl_certificate("testCertificate4", "a1a1a1a1...")) # replace with actual test data
    print(verify_ssl_certificate("testCertificate5", "b2b2b2b2...")) # replace with actual test data
```
```cpp
#include <iostream>
#include <string>
#include <openssl/sha.h>

bool verifySSLCertificate(const std::string &certificate, const std::string &knownHash) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, certificate.c_str(), certificate.size());
    SHA256_Final(hash, &sha256);

    std::string certHash;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        char buf[3];
        snprintf(buf, sizeof(buf), "%02x", hash[i]);
        certHash += buf;
    }

    return certHash == knownHash;
}

int main() {
    std::cout << verifySSLCertificate("testCertificate1", "d2d2d2d2...") << std::endl; // replace with actual test data
    std::cout << verifySSLCertificate("testCertificate2", "e3e3e3e3...") << std::endl; // replace with actual test data
    std::cout << verifySSLCertificate("testCertificate3", "f4f4f4f4...") << std::endl; // replace with actual test data
    std::cout << verifySSLCertificate("testCertificate4", "a1a1a1a1...") << std::endl; // replace with actual test data
    std::cout << verifySSLCertificate("testCertificate5", "b2b2b2b2...") << std::endl; // replace with actual test data
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>

int verifySSLCertificate(const char *certificate, const char *knownHash) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, certificate, strlen(certificate));
    SHA256_Final(hash, &sha256);

    char certHash[SHA256_DIGEST_LENGTH * 2 + 1];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(certHash + (i * 2), "%02x", hash[i]);
    }
    certHash[SHA256_DIGEST_LENGTH * 2] = '\0';

    return strcmp(certHash, knownHash) == 0;
}

int main() {
    printf("%d\n", verifySSLCertificate("testCertificate1", "d2d2d2d2...")); // replace with actual test data
    printf("%d\n", verifySSLCertificate("testCertificate2", "e3e3e3e3...")); // replace with actual test data
    printf("%d\n", verifySSLCertificate("testCertificate3", "f4f4f4f4...")); // replace with actual test data
    printf("%d\n", verifySSLCertificate("testCertificate4", "a1a1a1a1...")); // replace with actual test data
    printf("%d\n", verifySSLCertificate("testCertificate5", "b2b2b2b2...")); // replace with actual test data
    return 0;
}
```
Created file: Task81.java
Created file: Task81.py
Created file: Task81.cpp
Created file: Task81.c
Task82_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task82, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that computes and returns the hash of a password combined with a salt.
```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

public class Task82 {
    public static String computeHash(String password, String salt) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(salt.getBytes());
        byte[] hashedPassword = md.digest(password.getBytes());
        return Base64.getEncoder().encodeToString(hashedPassword);
    }

    public static String generateSalt() {
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);
        return Base64.getEncoder().encodeToString(salt);
    }

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String salt1 = generateSalt();
        String salt2 = generateSalt();
        String salt3 = generateSalt();
        String salt4 = generateSalt();
        String salt5 = generateSalt();

        System.out.println(computeHash("password123", salt1));
        System.out.println(computeHash("myPassword", salt2));
        System.out.println(computeHash("123456", salt3));
        System.out.println(computeHash("admin", salt4));
        System.out.println(computeHash("welcome", salt5));
    }
}
```
```python
import hashlib
import os
import base64

def compute_hash(password, salt):
    hash_obj = hashlib.sha256()
    hash_obj.update(salt.encode('utf-8'))
    hash_obj.update(password.encode('utf-8'))
    return base64.b64encode(hash_obj.digest()).decode('utf-8')

def generate_salt():
    return base64.b64encode(os.urandom(16)).decode('utf-8')

def main():
    salt1 = generate_salt()
    salt2 = generate_salt()
    salt3 = generate_salt()
    salt4 = generate_salt()
    salt5 = generate_salt()

    print(compute_hash("password123", salt1))
    print(compute_hash("myPassword", salt2))
    print(compute_hash("123456", salt3))
    print(compute_hash("admin", salt4))
    print(compute_hash("welcome", salt5))

main()
```
```cpp
#include <iostream>
#include <iomanip>
#include <sstream>
#include <openssl/sha.h>
#include <openssl/rand.h>
#include <string>
#include <vector>

std::string computeHash(const std::string& password, const std::string& salt) {
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, salt.c_str(), salt.size());
    SHA256_Update(&sha256, password.c_str(), password.size());
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_Final(hash, &sha256);
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    return ss.str();
}

std::string generateSalt() {
    unsigned char salt[16];
    RAND_bytes(salt, sizeof(salt));
    std::stringstream ss;
    for (int i = 0; i < 16; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(salt[i]);
    }
    return ss.str();
}

int main() {
    std::vector<std::string> salts(5);
    for (auto& salt : salts) {
        salt = generateSalt();
    }

    std::cout << computeHash("password123", salts[0]) << std::endl;
    std::cout << computeHash("myPassword", salts[1]) << std::endl;
    std::cout << computeHash("123456", salts[2]) << std::endl;
    std::cout << computeHash("admin", salts[3]) << std::endl;
    std::cout << computeHash("welcome", salts[4]) << std::endl;

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/rand.h>

char* computeHash(const char* password, const char* salt) {
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, salt, strlen(salt));
    SHA256_Update(&sha256, password, strlen(password));
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_Final(hash, &sha256);

    char* outputBuffer = (char*)malloc((SHA256_DIGEST_LENGTH * 2) + 1);
    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
        sprintf(outputBuffer + (i * 2), "%02x", hash[i]);
    }
    return outputBuffer;
}

char* generateSalt() {
    unsigned char salt[16];
    RAND_bytes(salt, sizeof(salt));
    char* outputBuffer = (char*)malloc((16 * 2) + 1);
    for (int i = 0; i < 16; ++i) {
        sprintf(outputBuffer + (i * 2), "%02x", salt[i]);
    }
    return outputBuffer;
}

int main() {
    char* salt1 = generateSalt();
    char* salt2 = generateSalt();
    char* salt3 = generateSalt();
    char* salt4 = generateSalt();
    char* salt5 = generateSalt();

    char* hash1 = computeHash("password123", salt1);
    char* hash2 = computeHash("myPassword", salt2);
    char* hash3 = computeHash("123456", salt3);
    char* hash4 = computeHash("admin", salt4);
    char* hash5 = computeHash("welcome", salt5);

    printf("%s\n", hash1);
    printf("%s\n", hash2);
    printf("%s\n", hash3);
    printf("%s\n", hash4);
    printf("%s\n", hash5);

    free(salt1);
    free(salt2);
    free(salt3);
    free(salt4);
    free(salt5);
    free(hash1);
    free(hash2);
    free(hash3);
    free(hash4);
    free(hash5);

    return 0;
}
```
Created file: Task82.java
Created file: Task82.py
Created file: Task82.cpp
Created file: Task82.c
Task83_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task83, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a Cipher using AES in CBC mode, encrypts a given key using this cipher, and returns the encrypted result.
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;

public class Task83 {
    private static final String AES = "AES";
    private static final String AES_CBC_PKCS5PADDING = "AES/CBC/PKCS5Padding";

    public static String encrypt(String plainText, SecretKey secretKey, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(AES_CBC_PKCS5PADDING);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
        byte[] encrypted = cipher.doFinal(plainText.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }

    public static void main(String[] args) throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(AES);
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();
        SecureRandom random = new SecureRandom();
        byte[] iv = new byte[16];
        random.nextBytes(iv);

        String[] testCases = {"test1", "test2", "test3", "test4", "test5"};
        for (String test : testCases) {
            String encrypted = encrypt(test, secretKey, iv);
            System.out.println("Encrypted: " + encrypted);
        }
    }
}
```
```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import base64

def encrypt(plain_text, secret_key, iv):
    cipher = AES.new(secret_key, AES.MODE_CBC, iv)
    ct_bytes = cipher.encrypt(plain_text.encode('utf-8').ljust(16))
    return base64.b64encode(ct_bytes).decode('utf-8')

def main():
    secret_key = get_random_bytes(16)
    iv = get_random_bytes(16)

    test_cases = ["test1", "test2", "test3", "test4", "test5"]
    for test in test_cases:
        encrypted = encrypt(test, secret_key, iv)
        print(f"Encrypted: {encrypted}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <iomanip>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <cstring>

class Task83 {
public:
    static std::string encrypt(const std::string& plainText, const unsigned char* key, const unsigned char* iv) {
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        unsigned char encrypted[128];
        int len;
        std::string encryptedText;

        EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);
        EVP_EncryptUpdate(ctx, encrypted, &len, reinterpret_cast<const unsigned char*>(plainText.c_str()), plainText.length());
        encryptedText = std::string(reinterpret_cast<char*>(encrypted), len);

        EVP_EncryptFinal_ex(ctx, encrypted + len, &len);
        encryptedText += std::string(reinterpret_cast<char*>(encrypted), len);

        EVP_CIPHER_CTX_free(ctx);

        return encryptedText;
    }

    static void printEncrypted(const std::string& text) {
        for (unsigned char c : text) {
            std::cout << std::hex << std::setfill('0') << std::setw(2) << (int)c;
        }
        std::cout << std::endl;
    }

    static void main() {
        unsigned char key[16];
        unsigned char iv[16];
        RAND_bytes(key, sizeof(key));
        RAND_bytes(iv, sizeof(iv));

        std::string testCases[] = {"test1", "test2", "test3", "test4", "test5"};
        for (const auto& test : testCases) {
            std::string encrypted = encrypt(test, key, iv);
            std::cout << "Encrypted: ";
            printEncrypted(encrypted);
        }
    }
};

int main() {
    Task83::main();
    return 0;
}
```
```c
#include <stdio.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <string.h>

void encrypt(const char *plainText, const unsigned char *key, const unsigned char *iv, unsigned char *encrypted) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    int len;

    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);
    EVP_EncryptUpdate(ctx, encrypted, &len, (unsigned char *)plainText, strlen(plainText));
    EVP_EncryptFinal_ex(ctx, encrypted + len, &len);

    EVP_CIPHER_CTX_free(ctx);
}

void printEncrypted(const unsigned char *text, int length) {
    for (int i = 0; i < length; i++) {
        printf("%02x", text[i]);
    }
    printf("\n");
}

int main() {
    unsigned char key[16];
    unsigned char iv[16];
    RAND_bytes(key, sizeof(key));
    RAND_bytes(iv, sizeof(iv));

    const char *testCases[] = {"test1", "test2", "test3", "test4", "test5"};
    for (int i = 0; i < 5; i++) {
        unsigned char encrypted[128];
        encrypt(testCases[i], key, iv, encrypted);
        printf("Encrypted: ");
        printEncrypted(encrypted, strlen(testCases[i]));
    }
    return 0;
}
```
Created file: Task83.java
Created file: Task83.py
Created file: Task83.cpp
Created file: Task83.c
Task84_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task84, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that generates and returns a random and unique session ID.
```java
import java.security.SecureRandom;
import java.util.HashSet;
import java.util.Set;

public class Task84 {
    private static final String CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    private static final int SESSION_ID_LENGTH = 32;
    private static final SecureRandom RANDOM = new SecureRandom();
    private static final Set<String> generatedIds = new HashSet<>();

    public static String generateSessionId() {
        StringBuilder sessionId;
        do {
            sessionId = new StringBuilder(SESSION_ID_LENGTH);
            for (int i = 0; i < SESSION_ID_LENGTH; i++) {
                sessionId.append(CHARACTERS.charAt(RANDOM.nextInt(CHARACTERS.length())));
            }
        } while (!generatedIds.add(sessionId.toString()));
        return sessionId.toString();
    }

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            System.out.println(generateSessionId());
        }
    }
}
```
```python
import secrets
import string

class Task84:
    CHARACTERS = string.ascii_letters + string.digits
    SESSION_ID_LENGTH = 32
    generated_ids = set()

    @staticmethod
    def generate_session_id():
        while True:
            session_id = ''.join(secrets.choice(Task84.CHARACTERS) for _ in range(Task84.SESSION_ID_LENGTH))
            if session_id not in Task84.generated_ids:
                Task84.generated_ids.add(session_id)
                return session_id

if __name__ == "__main__":
    for _ in range(5):
        print(Task84.generate_session_id())
```
```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <random>
#include <algorithm>

class Task84 {
public:
    static std::string generateSessionId() {
        static const std::string CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        static const int SESSION_ID_LENGTH = 32;
        static std::unordered_set<std::string> generatedIds;
        static std::random_device rd;
        static std::mt19937 generator(rd());
        static std::uniform_int_distribution<int> distribution(0, CHARACTERS.size() - 1);

        std::string sessionId;
        do {
            sessionId.clear();
            std::generate_n(std::back_inserter(sessionId), SESSION_ID_LENGTH, [&]() { return CHARACTERS[distribution(generator)]; });
        } while (!generatedIds.insert(sessionId).second);
        return sessionId;
    }
};

int main() {
    for (int i = 0; i < 5; ++i) {
        std::cout << Task84::generateSessionId() << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SESSION_ID_LENGTH 32
#define NUM_TEST_CASES 5

const char CHARACTERS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
const int CHARACTERS_LENGTH = sizeof(CHARACTERS) - 1;

char* generateSessionId(char* sessionId) {
    static int initialized = 0;
    if (!initialized) {
        srand((unsigned int)time(NULL));
        initialized = 1;
    }

    for (int i = 0; i < SESSION_ID_LENGTH; i++) {
        sessionId[i] = CHARACTERS[rand() % CHARACTERS_LENGTH];
    }
    sessionId[SESSION_ID_LENGTH] = '\0';

    return sessionId;
}

int main() {
    char sessionId[SESSION_ID_LENGTH + 1];
    for (int i = 0; i < NUM_TEST_CASES; i++) {
        printf("%s\n", generateSessionId(sessionId));
    }
    return 0;
}
```
Created file: Task84.java
Created file: Task84.py
Created file: Task84.cpp
Created file: Task84.c
Task85_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task85, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that generates and returns an unpredictable random string consisting only of ASCII letters. The length of the string should be equal to the specified length parameter.
```java
import java.security.SecureRandom;

public class Task85 {

    public static String generateRandomString(int length) {
        if (length < 1) throw new IllegalArgumentException("Length must be greater than 0");

        StringBuilder result = new StringBuilder(length);
        SecureRandom random = new SecureRandom();
        String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

        for (int i = 0; i < length; i++) {
            int index = random.nextInt(characters.length());
            result.append(characters.charAt(index));
        }

        return result.toString();
    }

    public static void main(String[] args) {
        System.out.println(generateRandomString(10));
        System.out.println(generateRandomString(15));
        System.out.println(generateRandomString(20));
        System.out.println(generateRandomString(25));
        System.out.println(generateRandomString(30));
    }
}
```
```python
import string
import secrets

def generate_random_string(length):
    if length < 1:
        raise ValueError("Length must be greater than 0")

    characters = string.ascii_letters
    result = ''.join(secrets.choice(characters) for _ in range(length))
    return result

def main():
    print(generate_random_string(10))
    print(generate_random_string(15))
    print(generate_random_string(20))
    print(generate_random_string(25))
    print(generate_random_string(30))

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <random>
#include <stdexcept>

std::string generateRandomString(int length) {
    if (length < 1) throw std::invalid_argument("Length must be greater than 0");

    const std::string characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    std::string result;
    result.reserve(length);

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distr(0, characters.size() - 1);

    for (int i = 0; i < length; ++i) {
        result += characters[distr(gen)];
    }

    return result;
}

int main() {
    std::cout << generateRandomString(10) << std::endl;
    std::cout << generateRandomString(15) << std::endl;
    std::cout << generateRandomString(20) << std::endl;
    std::cout << generateRandomString(25) << std::endl;
    std::cout << generateRandomString(30) << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

char* generateRandomString(int length) {
    if (length < 1) {
        fprintf(stderr, "Length must be greater than 0\n");
        exit(EXIT_FAILURE);
    }

    const char* characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    size_t char_len = strlen(characters);
    char* result = (char*)malloc((length + 1) * sizeof(char));

    if (result == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    srand((unsigned int)time(NULL));

    for (int i = 0; i < length; ++i) {
        int index = rand() % char_len;
        result[i] = characters[index];
    }
    result[length] = '\0';

    return result;
}

int main() {
    char* str1 = generateRandomString(10);
    printf("%s\n", str1);
    free(str1);

    char* str2 = generateRandomString(15);
    printf("%s\n", str2);
    free(str2);

    char* str3 = generateRandomString(20);
    printf("%s\n", str3);
    free(str3);

    char* str4 = generateRandomString(25);
    printf("%s\n", str4);
    free(str4);

    char* str5 = generateRandomString(30);
    printf("%s\n", str5);
    free(str5);

    return 0;
}
```
Created file: Task85.java
Created file: Task85.py
Created file: Task85.cpp
Created file: Task85.c
Task86_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task86, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Design a program that accepts a URL pointing to an EXE program file. The program should:

Download the EXE file from the provided URL.
Execute the downloaded EXE program.
```java
import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Task86 {

    public static void main(String[] args) {
        Task86 task = new Task86();
        String[] testUrls = {
            "http://example.com/file1.exe",
            "http://example.com/file2.exe",
            "http://example.com/file3.exe",
            "http://example.com/file4.exe",
            "http://example.com/file5.exe"
        };

        for (String url : testUrls) {
            try {
                Path exePath = task.downloadExe(url);
                if (exePath != null) {
                    task.executeExe(exePath);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public Path downloadExe(String fileUrl) {
        try {
            URL url = new URL(fileUrl);
            String fileName = Paths.get(url.getPath()).getFileName().toString();
            Path exePath = Paths.get(System.getProperty("java.io.tmpdir"), fileName);
            try (BufferedInputStream in = new BufferedInputStream(url.openStream());
                 FileOutputStream fileOutputStream = new FileOutputStream(exePath.toFile())) {
                byte[] dataBuffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {
                    fileOutputStream.write(dataBuffer, 0, bytesRead);
                }
            }
            return exePath;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void executeExe(Path exePath) {
        try {
            ProcessBuilder pb = new ProcessBuilder(exePath.toString());
            pb.inheritIO();
            Process process = pb.start();
            process.waitFor();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```python
import requests
import subprocess
import os

class Task86:
    def download_exe(self, file_url):
        try:
            response = requests.get(file_url, stream=True)
            response.raise_for_status()

            file_name = os.path.basename(file_url)
            file_path = os.path.join('/tmp', file_name)

            with open(file_path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)

            return file_path
        except requests.RequestException as e:
            print(f"Error downloading {file_url}: {e}")
            return None

    def execute_exe(self, exe_path):
        try:
            subprocess.run([exe_path], check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error executing {exe_path}: {e}")

def main():
    task = Task86()
    test_urls = [
        "http://example.com/file1.exe",
        "http://example.com/file2.exe",
        "http://example.com/file3.exe",
        "http://example.com/file4.exe",
        "http://example.com/file5.exe"
    ]

    for url in test_urls:
        exe_path = task.download_exe(url)
        if exe_path:
            task.execute_exe(exe_path)

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <string>
#include <fstream>
#include <curl/curl.h>
#include <cstdlib>

class Task86 {
public:
    bool downloadExe(const std::string& fileUrl, std::string& outPath);
    void executeExe(const std::string& exePath);

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
};

bool Task86::downloadExe(const std::string& fileUrl, std::string& outPath) {
    CURL* curl;
    CURLcode res;
    std::string readBuffer;

    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, fileUrl.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        if(res != CURLE_OK) {
            std::cerr << "Error downloading " << fileUrl << ": " << curl_easy_strerror(res) << std::endl;
            return false;
        }

        std::string fileName = fileUrl.substr(fileUrl.find_last_of("/") + 1);
        outPath = "/tmp/" + fileName;

        std::ofstream outFile(outPath, std::ios::binary);
        if(outFile.is_open()) {
            outFile << readBuffer;
            outFile.close();
            return true;
        }
    }
    return false;
}

void Task86::executeExe(const std::string& exePath) {
    if(system(exePath.c_str()) == -1) {
        std::cerr << "Error executing " << exePath << std::endl;
    }
}

int main() {
    Task86 task;
    std::string testUrls[] = {
        "http://example.com/file1.exe",
        "http://example.com/file2.exe",
        "http://example.com/file3.exe",
        "http://example.com/file4.exe",
        "http://example.com/file5.exe"
    };

    for(const auto& url : testUrls) {
        std::string exePath;
        if(task.downloadExe(url, exePath)) {
            task.executeExe(exePath);
        }
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

struct MemoryStruct {
    char* memory;
    size_t size;
};

static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct* mem = (struct MemoryStruct*)userp;

    char* ptr = realloc(mem->memory, mem->size + realsize + 1);
    if (ptr == NULL) {
        printf("Not enough memory (realloc returned NULL)\n");
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

int downloadExe(const char* fileUrl, char* outPath) {
    CURL* curl_handle;
    CURLcode res;

    struct MemoryStruct chunk;
    chunk.memory = malloc(1);
    chunk.size = 0;

    curl_global_init(CURL_GLOBAL_ALL);
    curl_handle = curl_easy_init();
    if (curl_handle) {
        curl_easy_setopt(curl_handle, CURLOPT_URL, fileUrl);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
        res = curl_easy_perform(curl_handle);
        curl_easy_cleanup(curl_handle);

        if (res != CURLE_OK) {
            fprintf(stderr, "Error downloading %s: %s\n", fileUrl, curl_easy_strerror(res));
            free(chunk.memory);
            return 0;
        }

        FILE* file = fopen(outPath, "wb");
        if (file) {
            fwrite(chunk.memory, 1, chunk.size, file);
            fclose(file);
            free(chunk.memory);
            return 1;
        }
        free(chunk.memory);
    }
    return 0;
}

void executeExe(const char* exePath) {
    if (system(exePath) == -1) {
        fprintf(stderr, "Error executing %s\n", exePath);
    }
}

int main() {
    const char* testUrls[] = {
        "http://example.com/file1.exe",
        "http://example.com/file2.exe",
        "http://example.com/file3.exe",
        "http://example.com/file4.exe",
        "http://example.com/file5.exe"
    };

    for (int i = 0; i < 5; i++) {
        char outPath[256];
        snprintf(outPath, sizeof(outPath), "/tmp/file%d.exe", i + 1);
        if (downloadExe(testUrls[i], outPath)) {
            executeExe(outPath);
        }
    }
    return 0;
}
```
Created file: Task86.java
Created file: Task86.py
Created file: Task86.cpp
Created file: Task86.c
Task87_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task87, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that perform binary search for an array and write a the execution time of the program into a temporary file.
```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;

public class Task87 {
    public static int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }

    public static void writeExecutionTime(long duration) {
        try {
            Path tempFile = Files.createTempFile("binary_search_exec_time", ".txt");
            BufferedWriter writer = Files.newBufferedWriter(tempFile, StandardOpenOption.WRITE);
            writer.write("Execution time: " + duration + " nanoseconds");
            writer.close();
            System.out.println("Execution time written to: " + tempFile);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] targets = {1, 5, 10, 11, -1};

        for (int target : targets) {
            long startTime = System.nanoTime();
            int result = binarySearch(arr, target);
            long endTime = System.nanoTime();
            long duration = endTime - startTime;
            writeExecutionTime(duration);
            System.out.println("Target " + target + " found at index: " + result);
        }
    }
}
```
```python
import time
import tempfile

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def write_execution_time(duration):
    with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.txt') as temp_file:
        temp_file.write(f"Execution time: {duration} nanoseconds\n")
        print(f"Execution time written to: {temp_file.name}")

def main():
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    targets = [1, 5, 10, 11, -1]

    for target in targets:
        start_time = time.perf_counter_ns()
        result = binary_search(arr, target)
        end_time = time.perf_counter_ns()
        duration = end_time - start_time
        write_execution_time(duration)
        print(f"Target {target} found at index: {result}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <vector>
#include <fstream>
#include <chrono>
#include <filesystem>

int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}

void writeExecutionTime(long long duration) {
    std::string tempFileName = std::filesystem::temp_directory_path() / "binary_search_exec_time.txt";
    std::ofstream tempFile(tempFileName);
    if (tempFile.is_open()) {
        tempFile << "Execution time: " << duration << " nanoseconds" << std::endl;
        tempFile.close();
        std::cout << "Execution time written to: " << tempFileName << std::endl;
    }
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::vector<int> targets = {1, 5, 10, 11, -1};

    for (int target : targets) {
        auto start = std::chrono::high_resolution_clock::now();
        int result = binarySearch(arr, target);
        auto end = std::chrono::high_resolution_clock::now();
        long long duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();
        writeExecutionTime(duration);
        std::cout << "Target " << target << " found at index: " << result << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int binarySearch(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}

void writeExecutionTime(long duration) {
    char template[] = "/tmp/binary_search_exec_timeXXXXXX";
    char* tempFileName = mktemp(template);
    FILE* tempFile = fopen(tempFileName, "w");
    if (tempFile != NULL) {
        fprintf(tempFile, "Execution time: %ld nanoseconds\n", duration);
        fclose(tempFile);
        printf("Execution time written to: %s\n", tempFileName);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int targets[] = {1, 5, 10, 11, -1};
    int size = sizeof(arr) / sizeof(arr[0]);

    for (int i = 0; i < 5; ++i) {
        int target = targets[i];
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
        int result = binarySearch(arr, size, target);
        clock_gettime(CLOCK_MONOTONIC, &end);
        long duration = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
        writeExecutionTime(duration);
        printf("Target %d found at index: %d\n", target, result);
    }
    return 0;
}
```
Created file: Task87.java
Created file: Task87.py
Created file: Task87.cpp
Created file: Task87.c
Task88_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task88, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a temporary file using UTF-8 encoding, create a random string, covert the string into Unicode, write the Unicode string results to the file, and returns the path of the temporary file.
```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.nio.charset.StandardCharsets;
import java.util.UUID;
import java.io.IOException;

public class Task88 {
    public static String createTempFile() throws IOException {
        Path tempFile = Files.createTempFile(null, ".txt");
        String randomString = UUID.randomUUID().toString();
        String unicodeString = convertToUnicode(randomString);
        Files.write(tempFile, unicodeString.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);
        return tempFile.toString();
    }

    private static String convertToUnicode(String input) {
        StringBuilder unicodeStringBuilder = new StringBuilder();
        for (char c : input.toCharArray()) {
            unicodeStringBuilder.append("\\u").append(String.format("%04x", (int) c));
        }
        return unicodeStringBuilder.toString();
    }

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            try {
                System.out.println("Temporary file created at: " + createTempFile());
            } catch (IOException e) {
                System.err.println("Error creating temporary file: " + e.getMessage());
            }
        }
    }
}
```
```python
import tempfile
import os
import uuid

def create_temp_file():
    random_string = str(uuid.uuid4())
    unicode_string = convert_to_unicode(random_string)
    with tempfile.NamedTemporaryFile(delete=False, mode='w', encoding='utf-8', suffix='.txt') as temp_file:
        temp_file.write(unicode_string)
        return temp_file.name

def convert_to_unicode(input_str):
    return ''.join('\\u{:04x}'.format(ord(c)) for c in input_str)

if __name__ == "__main__":
    for _ in range(5):
        try:
            temp_file_path = create_temp_file()
            print(f"Temporary file created at: {temp_file_path}")
        except Exception as e:
            print(f"Error creating temporary file: {e}")
```
```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <sstream>
#include <iomanip>

std::string generateRandomString() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(0, 15);
    std::ostringstream oss;
    for (int i = 0; i < 8; ++i) {
        oss << std::hex << dis(gen);
    }
    return oss.str();
}

std::string convertToUnicode(const std::string& input) {
    std::ostringstream unicodeString;
    for (char c : input) {
        unicodeString << "\\u" << std::setfill('0') << std::setw(4) << std::hex << (int)c;
    }
    return unicodeString.str();
}

std::string createTempFile() {
    std::string randomString = generateRandomString();
    std::string unicodeString = convertToUnicode(randomString);

    std::string tempFileName = "tempfileXXXXXX.txt";
    std::ofstream tempFile(tempFileName, std::ios::out | std::ios::trunc);
    if (!tempFile) {
        throw std::runtime_error("Could not create temporary file");
    }
    tempFile << unicodeString;
    tempFile.close();
    return tempFileName;
}

int main() {
    for (int i = 0; i < 5; ++i) {
        try {
            std::string tempFilePath = createTempFile();
            std::cout << "Temporary file created at: " << tempFilePath << std::endl;
        } catch (const std::exception& e) {
            std::cerr << "Error creating temporary file: " << e.what() << std::endl;
        }
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

char* generateRandomString() {
    static char charset[] = "0123456789abcdef";
    char *randomString = malloc(9);
    if (randomString) {
        for (int i = 0; i < 8; i++) {
            randomString[i] = charset[rand() % 16];
        }
        randomString[8] = '\0';
    }
    return randomString;
}

char* convertToUnicode(const char* input) {
    size_t len = strlen(input);
    char* unicodeString = malloc((len * 6) + 1); // 6 for \uxxxx format
    if (!unicodeString) return NULL;

    char *ptr = unicodeString;
    for (size_t i = 0; i < len; ++i) {
        ptr += sprintf(ptr, "\\u%04x", input[i]);
    }
    return unicodeString;
}

char* createTempFile() {
    char* randomString = generateRandomString();
    char* unicodeString = convertToUnicode(randomString);

    char tempFileName[] = "tempfileXXXXXX";
    int fd = mkstemp(tempFileName);
    if (fd == -1) {
        perror("mkstemp");
        free(randomString);
        free(unicodeString);
        return NULL;
    }
    FILE* tempFile = fdopen(fd, "w");
    if (!tempFile) {
        perror("fdopen");
        close(fd);
        free(randomString);
        free(unicodeString);
        return NULL;
    }
    fprintf(tempFile, "%s", unicodeString);
    fclose(tempFile);

    free(randomString);
    free(unicodeString);
    return strdup(tempFileName);
}

int main() {
    srand((unsigned)time(NULL));
    for (int i = 0; i < 5; ++i) {
        char* tempFilePath = createTempFile();
        if (tempFilePath) {
            printf("Temporary file created at: %s\n", tempFilePath);
            free(tempFilePath);
        } else {
            printf("Error creating temporary file.\n");
        }
    }
    return 0;
}
```
Created file: Task88.java
Created file: Task88.py
Created file: Task88.cpp
Created file: Task88.c
Task89_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task89, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that compares the user's password stored in file with the password entered by the user by checking if every character matches sequentially in the code.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Task89 {
    public static boolean comparePasswords(String filePath, String userInput) {
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String storedPassword = reader.readLine();
            if (storedPassword == null || storedPassword.length() != userInput.length()) {
                return false;
            }
            for (int i = 0; i < storedPassword.length(); i++) {
                if (storedPassword.charAt(i) != userInput.charAt(i)) {
                    return false;
                }
            }
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public static void main(String[] args) {
        System.out.println(comparePasswords("password.txt", "password1"));
        System.out.println(comparePasswords("password.txt", "password"));
        System.out.println(comparePasswords("password.txt", "Password"));
        System.out.println(comparePasswords("password.txt", "passw0rd"));
        System.out.println(comparePasswords("password.txt", ""));
    }
}
```
```python
def compare_passwords(file_path, user_input):
    try:
        with open(file_path, 'r') as file:
            stored_password = file.readline().strip()
            if len(stored_password) != len(user_input):
                return False
            for sp, up in zip(stored_password, user_input):
                if sp != up:
                    return False
            return True
    except IOError as e:
        print(e)
        return False

if __name__ == "__main__":
    print(compare_passwords("password.txt", "password1"))
    print(compare_passwords("password.txt", "password"))
    print(compare_passwords("password.txt", "Password"))
    print(compare_passwords("password.txt", "passw0rd"))
    print(compare_passwords("password.txt", ""))
```
```cpp
#include <iostream>
#include <fstream>
#include <string>

using namespace std;

bool comparePasswords(const string& filePath, const string& userInput) {
    ifstream file(filePath);
    if (!file.is_open()) {
        cerr << "Error opening file" << endl;
        return false;
    }
    string storedPassword;
    getline(file, storedPassword);
    file.close();
    if (storedPassword.length() != userInput.length()) {
        return false;
    }
    for (size_t i = 0; i < storedPassword.length(); ++i) {
        if (storedPassword[i] != userInput[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    cout << comparePasswords("password.txt", "password1") << endl;
    cout << comparePasswords("password.txt", "password") << endl;
    cout << comparePasswords("password.txt", "Password") << endl;
    cout << comparePasswords("password.txt", "passw0rd") << endl;
    cout << comparePasswords("password.txt", "") << endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool comparePasswords(const char* filePath, const char* userInput) {
    FILE* file = fopen(filePath, "r");
    if (file == NULL) {
        perror("Error opening file");
        return false;
    }
    char storedPassword[256];
    if (fgets(storedPassword, sizeof(storedPassword), file) == NULL) {
        fclose(file);
        return false;
    }
    fclose(file);

    size_t storedLength = strlen(storedPassword);
    size_t inputLength = strlen(userInput);

    if (storedLength > 0 && storedPassword[storedLength - 1] == '\n') {
        storedPassword[storedLength - 1] = '\0';
        storedLength--;
    }

    if (storedLength != inputLength) {
        return false;
    }

    for (size_t i = 0; i < storedLength; ++i) {
        if (storedPassword[i] != userInput[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    printf("%d\n", comparePasswords("password.txt", "password1"));
    printf("%d\n", comparePasswords("password.txt", "password"));
    printf("%d\n", comparePasswords("password.txt", "Password"));
    printf("%d\n", comparePasswords("password.txt", "passw0rd"));
    printf("%d\n", comparePasswords("password.txt", ""));
    return 0;
}
```
Created file: Task89.java
Created file: Task89.py
Created file: Task89.cpp
Created file: Task89.c
Task90_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task90, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that runs as a server-side program for a chat application that allows multiple clients to connect to it on a specified port and send messages.
```java
import java.io.*;
import java.net.*;
import java.util.concurrent.*;
import java.util.*;

public class Task90 {
    private static final int PORT = 12345;
    private static Set<PrintWriter> clientWriters = ConcurrentHashMap.newKeySet();

    public static void main(String[] args) {
        System.out.println("Chat server started on port " + PORT);
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            while (true) {
                new ClientHandler(serverSocket.accept()).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static class ClientHandler extends Thread {
        private Socket socket;
        private PrintWriter out;
        private BufferedReader in;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void run() {
            try {
                in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                out = new PrintWriter(socket.getOutputStream(), true);
                clientWriters.add(out);

                String message;
                while ((message = in.readLine()) != null) {
                    System.out.println("Received: " + message);
                    for (PrintWriter writer : clientWriters) {
                        writer.println(message);
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                clientWriters.remove(out);
            }
        }
    }
}
```
```python
import socket
import threading

class Task90:
    def __init__(self, host='localhost', port=12345):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((host, port))
        self.server.listen(5)
        print(f"Chat server started on port {port}")
        self.clients = []

    def broadcast(self, message, client_socket):
        for client in self.clients:
            if client != client_socket:
                try:
                    client.send(message)
                except:
                    self.clients.remove(client)

    def handle_client(self, client_socket):
        while True:
            try:
                message = client_socket.recv(1024)
                if message:
                    print(f"Received: {message.decode()}")
                    self.broadcast(message, client_socket)
            except:
                self.clients.remove(client_socket)
                client_socket.close()
                break

    def run(self):
        while True:
            client_socket, addr = self.server.accept()
            print(f"Connected with {addr}")
            self.clients.append(client_socket)
            client_thread = threading.Thread(target=self.handle_client, args=(client_socket,))
            client_thread.start()

if __name__ == "__main__":
    Task90().run()
```
```cpp
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <mutex>
#include <set>
#include <unistd.h>
#include <netinet/in.h>

class Task90 {
private:
    int server_fd;
    std::set<int> clients;
    std::mutex client_mutex;

public:
    Task90(int port) {
        server_fd = socket(AF_INET, SOCK_STREAM, 0);
        sockaddr_in address;
        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(port);

        bind(server_fd, (struct sockaddr *)&address, sizeof(address));
        listen(server_fd, 5);
        std::cout << "Chat server started on port " << port << std::endl;
    }

    void broadcast(const std::string& message, int sender_fd) {
        std::lock_guard<std::mutex> lock(client_mutex);
        for (int client_fd : clients) {
            if (client_fd != sender_fd) {
                send(client_fd, message.c_str(), message.length(), 0);
            }
        }
    }

    void handle_client(int client_fd) {
        char buffer[1024] = {0};
        while (true) {
            int read_size = read(client_fd, buffer, 1024);
            if (read_size > 0) {
                std::string message(buffer, read_size);
                std::cout << "Received: " << message << std::endl;
                broadcast(message, client_fd);
            } else {
                std::lock_guard<std::mutex> lock(client_mutex);
                clients.erase(client_fd);
                close(client_fd);
                break;
            }
        }
    }

    void run() {
        while (true) {
            int client_fd = accept(server_fd, nullptr, nullptr);
            std::lock_guard<std::mutex> lock(client_mutex);
            clients.insert(client_fd);
            std::thread(&Task90::handle_client, this, client_fd).detach();
        }
    }
};

int main() {
    Task90 server(12345);
    server.run();
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 12345
#define MAX_CLIENTS 100

typedef struct {
    int sock;
    struct sockaddr address;
    int addr_len;
} client_t;

client_t *clients[MAX_CLIENTS];
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void broadcast(char *message, int sender_sock) {
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < MAX_CLIENTS; ++i) {
        if (clients[i] && clients[i]->sock != sender_sock) {
            if (write(clients[i]->sock, message, strlen(message)) < 0) {
                perror("write");
                break;
            }
        }
    }
    pthread_mutex_unlock(&clients_mutex);
}

void *handle_client(void *arg) {
    char buffer[1024];
    client_t *cli = (client_t *)arg;
    int read_size;

    while ((read_size = read(cli->sock, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[read_size] = '\0';
        printf("Received: %s\n", buffer);
        broadcast(buffer, cli->sock);
    }

    close(cli->sock);
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < MAX_CLIENTS; ++i) {
        if (clients[i] == cli) {
            clients[i] = NULL;
            break;
        }
    }
    pthread_mutex_unlock(&clients_mutex);
    free(cli);
    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_sock, 5);
    printf("Chat server started on port %d\n", PORT);

    while (1) {
        client_t *cli = (client_t *)malloc(sizeof(client_t));
        cli->addr_len = sizeof(cli->address);
        cli->sock = accept(server_sock, &cli->address, &cli->addr_len);

        pthread_mutex_lock(&clients_mutex);
        for (int i = 0; i < MAX_CLIENTS; ++i) {
            if (!clients[i]) {
                clients[i] = cli;
                break;
            }
        }
        pthread_mutex_unlock(&clients_mutex);

        pthread_t tid;
        pthread_create(&tid, NULL, handle_client, (void *)cli);
        pthread_detach(tid);
    }

    close(server_sock);
    return 0;
}
```
Created file: Task90.java
Created file: Task90.py
Created file: Task90.cpp
Created file: Task90.c
Task91_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task91, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a UDP socket to listen on a specified IP address and port for incoming DNS requests. Outline the steps for parsing the received data, resolving DNS records, and sending the response back to the requested IP address using UDP communication.
```java
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class Task91 {
    public static void main(String[] args) {
        // Test cases
        udpServer("127.0.0.1", 5353);
    }

    public static void udpServer(String ipAddress, int port) {
        try (DatagramSocket socket = new DatagramSocket(port, InetAddress.getByName(ipAddress))) {
            byte[] buffer = new byte[512];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

            while (true) {
                socket.receive(packet);
                String request = new String(packet.getData(), 0, packet.getLength());
                System.out.println("Received: " + request);

                // Parse and resolve DNS request (pseudo logic)
                String response = "Resolved DNS Record";

                byte[] responseData = response.getBytes();
                DatagramPacket responsePacket = new DatagramPacket(responseData, responseData.length, packet.getAddress(), packet.getPort());
                socket.send(responsePacket);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```python
import socket

def udp_server(ip_address, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((ip_address, port))
    try:
        while True:
            data, addr = sock.recvfrom(512)
            print(f"Received: {data.decode()} from {addr}")

            # Parse and resolve DNS request (pseudo logic)
            response = "Resolved DNS Record"

            sock.sendto(response.encode(), addr)
    except Exception as e:
        print(e)
    finally:
        sock.close()

if __name__ == "__main__":
    # Test cases
    udp_server("127.0.0.1", 5353)
```
```cpp
#include <iostream>
#include <cstring>
#include <arpa/inet.h>
#include <unistd.h>

void udpServer(const std::string& ipAddress, int port) {
    int sockfd;
    struct sockaddr_in servaddr, cliaddr;
    socklen_t len;
    char buffer[512];

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(ipAddress.c_str());
    servaddr.sin_port = htons(port);

    bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr));

    while (true) {
        len = sizeof(cliaddr);
        int n = recvfrom(sockfd, (char *)buffer, 512, MSG_WAITALL, (struct sockaddr *)&cliaddr, &len);
        buffer[n] = '\0';
        std::cout << "Received: " << buffer << std::endl;

        // Parse and resolve DNS request (pseudo logic)
        std::string response = "Resolved DNS Record";

        sendto(sockfd, response.c_str(), response.size(), MSG_CONFIRM, (const struct sockaddr *)&cliaddr, len);
    }
    close(sockfd);
}

int main() {
    // Test cases
    udpServer("127.0.0.1", 5353);
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>

void udpServer(const char* ipAddress, int port) {
    int sockfd;
    struct sockaddr_in servaddr, cliaddr;
    socklen_t len;
    char buffer[512];

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(ipAddress);
    servaddr.sin_port = htons(port);

    bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr));

    while (1) {
        len = sizeof(cliaddr);
        int n = recvfrom(sockfd, buffer, 512, MSG_WAITALL, (struct sockaddr *)&cliaddr, &len);
        buffer[n] = '\0';
        printf("Received: %s\n", buffer);

        // Parse and resolve DNS request (pseudo logic)
        const char* response = "Resolved DNS Record";

        sendto(sockfd, response, strlen(response), MSG_CONFIRM, (const struct sockaddr *)&cliaddr, len);
    }
    close(sockfd);
}

int main() {
    // Test cases
    udpServer("127.0.0.1", 5353);
    return 0;
}
```
Created file: Task91.java
Created file: Task91.py
Created file: Task91.cpp
Created file: Task91.c
Task92_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task92, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Implement a thread-safe mechanism to manage access to a shared resource where each thread checks if currentCounter variable is less than or equal to maxCounter variable. If true, the thread should acquire a lock, increment currentCounter by 1, release the lock, and print a message indicating which thread is accessing the currentCounter at that moment.
```java
import java.util.concurrent.locks.ReentrantLock;

public class Task92 {
    private static int currentCounter = 0;
    private static final int maxCounter = 5;
    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Runnable task = () -> {
            while (true) {
                lock.lock();
                try {
                    if (currentCounter <= maxCounter) {
                        System.out.println(Thread.currentThread().getName() + " accessing currentCounter: " + currentCounter);
                        currentCounter++;
                    } else {
                        break;
                    }
                } finally {
                    lock.unlock();
                }
            }
        };

        Thread t1 = new Thread(task, "Thread 1");
        Thread t2 = new Thread(task, "Thread 2");
        Thread t3 = new Thread(task, "Thread 3");
        Thread t4 = new Thread(task, "Thread 4");
        Thread t5 = new Thread(task, "Thread 5");

        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }
}
```
```python
import threading

current_counter = 0
max_counter = 5
lock = threading.Lock()

def task():
    global current_counter
    while True:
        with lock:
            if current_counter <= max_counter:
                print(f"{threading.current_thread().name} accessing currentCounter: {current_counter}")
                current_counter += 1
            else:
                break

threads = []
for i in range(5):
    thread = threading.Thread(target=task, name=f"Thread {i+1}")
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```
```cpp
#include <iostream>
#include <thread>
#include <mutex>

class Task92 {
    static int currentCounter;
    static const int maxCounter = 5;
    static std::mutex mtx;

public:
    static void task() {
        while (true) {
            std::lock_guard<std::mutex> lock(mtx);
            if (currentCounter <= maxCounter) {
                std::cout << std::this_thread::get_id() << " accessing currentCounter: " << currentCounter << std::endl;
                currentCounter++;
            } else {
                break;
            }
        }
    }
};

int Task92::currentCounter = 0;
std::mutex Task92::mtx;

int main() {
    std::thread t1(&Task92::task);
    std::thread t2(&Task92::task);
    std::thread t3(&Task92::task);
    std::thread t4(&Task92::task);
    std::thread t5(&Task92::task);

    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();

    return 0;
}
```
```c
#include <stdio.h>
#include <pthread.h>

int currentCounter = 0;
const int maxCounter = 5;
pthread_mutex_t lock;

void* task(void* arg) {
    while (1) {
        pthread_mutex_lock(&lock);
        if (currentCounter <= maxCounter) {
            printf("Thread %ld accessing currentCounter: %d\n", (long)arg, currentCounter);
            currentCounter++;
        } else {
            pthread_mutex_unlock(&lock);
            break;
        }
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}

int main() {
    pthread_t threads[5];
    pthread_mutex_init(&lock, NULL);

    for (long i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, task, (void*)i);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&lock);
    return 0;
}
```
Created file: Task92.java
Created file: Task92.py
Created file: Task92.cpp
Created file: Task92.c
Task93_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task93, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that read a file that contains records formatted as key-value. The program will read the file records one by one and sorts them.
```java
import java.io.*;
import java.util.*;

public class Task93 {
    public static Map<String, String> readFileAndSort(String filePath) {
        Map<String, String> sortedMap = new TreeMap<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("=", 2);
                if (parts.length == 2) {
                    sortedMap.put(parts[0].trim(), parts[1].trim());
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return sortedMap;
    }

    public static void main(String[] args) {
        String filePath = "testfile.txt";
        Map<String, String> sortedRecords = readFileAndSort(filePath);
        for (Map.Entry<String, String> entry : sortedRecords.entrySet()) {
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
    }
}
```
```python
import os

def read_file_and_sort(file_path):
    if not os.path.isfile(file_path):
        return {}

    with open(file_path, 'r') as file:
        lines = file.readlines()

    records = {}
    for line in lines:
        if '=' in line:
            key, value = line.split('=', 1)
            records[key.strip()] = value.strip()

    return dict(sorted(records.items()))

def main():
    file_path = 'testfile.txt'
    sorted_records = read_file_and_sort(file_path)
    for key, value in sorted_records.items():
        print(f"{key}={value}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <fstream>
#include <map>
#include <string>
#include <sstream>

std::map<std::string, std::string> readFileAndSort(const std::string& filePath) {
    std::map<std::string, std::string> sortedMap;
    std::ifstream file(filePath);

    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            std::istringstream iss(line);
            std::string key, value;
            if (std::getline(std::getline(iss, key, '='), value)) {
                sortedMap[key] = value;
            }
        }
        file.close();
    }
    return sortedMap;
}

int main() {
    std::string filePath = "testfile.txt";
    std::map<std::string, std::string> sortedRecords = readFileAndSort(filePath);
    for (const auto& entry : sortedRecords) {
        std::cout << entry.first << "=" << entry.second << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Record {
    char *key;
    char *value;
} Record;

int compareRecords(const void *a, const void *b) {
    Record *recordA = (Record *)a;
    Record *recordB = (Record *)b;
    return strcmp(recordA->key, recordB->key);
}

Record* readFileAndSort(const char *filePath, int *recordCount) {
    FILE *file = fopen(filePath, "r");
    if (file == NULL) {
        *recordCount = 0;
        return NULL;
    }

    Record *records = NULL;
    char line[256];
    *recordCount = 0;

    while (fgets(line, sizeof(line), file)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");

        if (key && value) {
            records = realloc(records, sizeof(Record) * (*recordCount + 1));
            records[*recordCount].key = strdup(key);
            records[*recordCount].value = strdup(value);
            (*recordCount)++;
        }
    }
    fclose(file);

    qsort(records, *recordCount, sizeof(Record), compareRecords);
    return records;
}

int main() {
    const char *filePath = "testfile.txt";
    int recordCount;
    Record *sortedRecords = readFileAndSort(filePath, &recordCount);

    for (int i = 0; i < recordCount; i++) {
        printf("%s=%s\n", sortedRecords[i].key, sortedRecords[i].value);
        free(sortedRecords[i].key);
        free(sortedRecords[i].value);
    }
    free(sortedRecords);
    return 0;
}
```
Created file: Task93.java
Created file: Task93.py
Created file: Task93.cpp
Created file: Task93.c
Task94_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task94, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that read a file that contains records formatted as key-value. The program will read the file records one by one and sorts them.
```java
import java.io.*;
import java.util.*;

public class Task94 {
    public static List<String> sortFileRecords(String filePath) {
        List<String> records = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                records.add(line.trim());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        Collections.sort(records);
        return records;
    }

    public static void main(String[] args) {
        String filePath = "testfile.txt"; // Assume this file exists with key-value records
        List<String> sortedRecords = sortFileRecords(filePath);
        for (String record : sortedRecords) {
            System.out.println(record);
        }
    }
}
```
```python
def sort_file_records(file_path):
    records = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                records.append(line.strip())
    except IOError as e:
        print(f"Error reading file: {e}")
    records.sort()
    return records

if __name__ == "__main__":
    file_path = "testfile.txt"  # Assume this file exists with key-value records
    sorted_records = sort_file_records(file_path)
    for record in sorted_records:
        print(record)
```
```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

void sortFileRecords(const std::string& filePath) {
    std::vector<std::string> records;
    std::ifstream file(filePath);
    if (file.is_open()) {
        std::string line;
        while (getline(file, line)) {
            records.push_back(line);
        }
        file.close();
        std::sort(records.begin(), records.end());
        for (const auto& record : records) {
            std::cout << record << std::endl;
        }
    } else {
        std::cerr << "Unable to open file" << std::endl;
    }
}

int main() {
    std::string filePath = "testfile.txt"; // Assume this file exists with key-value records
    sortFileRecords(filePath);
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sortFileRecords(const char *filePath) {
    FILE *file = fopen(filePath, "r");
    if (!file) {
        perror("Unable to open file");
        return;
    }

    char **records = NULL;
    size_t count = 0;
    char buffer[256];

    while (fgets(buffer, sizeof(buffer), file)) {
        records = realloc(records, (count + 1) * sizeof(char *));
        records[count] = strdup(buffer);
        count++;
    }
    fclose(file);

    qsort(records, count, sizeof(char *), (int (*)(const void *, const void *))strcmp);

    for (size_t i = 0; i < count; i++) {
        printf("%s", records[i]);
        free(records[i]);
    }
    free(records);
}

int main() {
    const char *filePath = "testfile.txt"; // Assume this file exists with key-value records
    sortFileRecords(filePath);
    return 0;
}
```
Created file: Task94.java
Created file: Task94.py
Created file: Task94.cpp
Created file: Task94.c
Task95_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task95, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that  that prints the current processor time in seconds.
```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;

public class Task95 {
    public static double getCurrentProcessorTimeInSeconds() {
        ThreadMXBean bean = ManagementFactory.getThreadMXBean();
        if (bean.isCurrentThreadCpuTimeSupported()) {
            return bean.getCurrentThreadCpuTime() / 1_000_000_000.0;
        }
        return 0.0;
    }

    public static void main(String[] args) {
        System.out.println(getCurrentProcessorTimeInSeconds());
        System.out.println(getCurrentProcessorTimeInSeconds());
        System.out.println(getCurrentProcessorTimeInSeconds());
        System.out.println(getCurrentProcessorTimeInSeconds());
        System.out.println(getCurrentProcessorTimeInSeconds());
    }
}
```
```python
import time

def get_current_processor_time_in_seconds():
    return time.process_time()

if __name__ == "__main__":
    print(get_current_processor_time_in_seconds())
    print(get_current_processor_time_in_seconds())
    print(get_current_processor_time_in_seconds())
    print(get_current_processor_time_in_seconds())
    print(get_current_processor_time_in_seconds())
```
```cpp
#include <iostream>
#include <chrono>

class Task95 {
public:
    static double getCurrentProcessorTimeInSeconds() {
        return static_cast<double>(std::clock()) / CLOCKS_PER_SEC;
    }
};

int main() {
    std::cout << Task95::getCurrentProcessorTimeInSeconds() << std::endl;
    std::cout << Task95::getCurrentProcessorTimeInSeconds() << std::endl;
    std::cout << Task95::getCurrentProcessorTimeInSeconds() << std::endl;
    std::cout << Task95::getCurrentProcessorTimeInSeconds() << std::endl;
    std::cout << Task95::getCurrentProcessorTimeInSeconds() << std::endl;
    return 0;
}
```
```c
#include <stdio.h>
#include <time.h>

double getCurrentProcessorTimeInSeconds() {
    return (double)clock() / CLOCKS_PER_SEC;
}

int main() {
    printf("%f\n", getCurrentProcessorTimeInSeconds());
    printf("%f\n", getCurrentProcessorTimeInSeconds());
    printf("%f\n", getCurrentProcessorTimeInSeconds());
    printf("%f\n", getCurrentProcessorTimeInSeconds());
    printf("%f\n", getCurrentProcessorTimeInSeconds());
    return 0;
}
```
Created file: Task95.java
Created file: Task95.py
Created file: Task95.cpp
Created file: Task95.c
Task96_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task96, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that creates a socket server listening on a specified port. The server should echo back any message it receives from a client.
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class Task96 {
    public static void main(String[] args) {
        startServer(8080);
    }

    public static void startServer(int port) {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Server started on port: " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept();
                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

                    String inputLine;
                    while ((inputLine = in.readLine()) != null) {
                        out.println(inputLine);
                    }
                } catch (Exception e) {
                    System.err.println("Error in client connection: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            System.err.println("Could not start server: " + e.getMessage());
        }
    }
}
```
```python
import socket

def start_server(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('localhost', port))
        server_socket.listen()
        print(f"Server started on port: {port}")
        while True:
            client_socket, addr = server_socket.accept()
            with client_socket:
                print(f"Connected by: {addr}")
                while True:
                    data = client_socket.recv(1024)
                    if not data:
                        break
                    client_socket.sendall(data)

if __name__ == "__main__":
    start_server(8080)
```
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

class Task96 {
public:
    static void startServer(int port) {
        int server_fd, client_fd;
        struct sockaddr_in address;
        int opt = 1;
        int addrlen = sizeof(address);
        char buffer[1024] = {0};

        if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
            perror("socket failed");
            return;
        }

        if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
            perror("setsockopt");
            close(server_fd);
            return;
        }

        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(port);

        if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
            perror("bind failed");
            close(server_fd);
            return;
        }

        if (listen(server_fd, 3) < 0) {
            perror("listen");
            close(server_fd);
            return;
        }

        std::cout << "Server started on port: " << port << std::endl;
        while (true) {
            if ((client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
                perror("accept");
                close(server_fd);
                return;
            }
            int valread = read(client_fd, buffer, 1024);
            send(client_fd, buffer, valread, 0);
            close(client_fd);
        }
    }
};

int main() {
    Task96::startServer(8080);
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>

void startServer(int port) {
    int server_fd, client_fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 3) < 0) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server started on port: %d\n", port);
    while (1) {
        if ((client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            perror("accept");
            close(server_fd);
            exit(EXIT_FAILURE);
        }
        int valread = read(client_fd, buffer, 1024);
        send(client_fd, buffer, valread, 0);
        close(client_fd);
    }
}

int main() {
    startServer(8080);
    return 0;
}
```
Created file: Task96.java
Created file: Task96.py
Created file: Task96.cpp
Created file: Task96.c
Task97_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task97, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that performs the following steps:

Retrieve the xpath value from the command line parameter.
Retrieve the xml file name from the command line parameter and read it from the local storage.
Construct and parse the XML file.
Execute the XPath query in the format /tag[@id={}] on the parsed XML.
Return the result of the XPath query.
```java
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import java.io.File;

public class Task97 {
    public static String executeXPathQuery(String xpathValue, String xmlFilePath) {
        try {
            File xmlFile = new File(xmlFilePath);
            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(xmlFile);
            doc.getDocumentElement().normalize();

            XPath xPath = XPathFactory.newInstance().newXPath();
            String expression = "/tag[@id='" + xpathValue + "']";
            NodeList nodeList = (NodeList) xPath.evaluate(expression, doc, XPathConstants.NODESET);

            StringBuilder result = new StringBuilder();
            for (int i = 0; i < nodeList.getLength(); i++) {
                result.append(nodeList.item(i).getTextContent()).append("\n");
            }
            return result.toString();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        System.out.println(executeXPathQuery("test1", "test1.xml"));
        System.out.println(executeXPathQuery("test2", "test2.xml"));
        System.out.println(executeXPathQuery("test3", "test3.xml"));
        System.out.println(executeXPathQuery("test4", "test4.xml"));
        System.out.println(executeXPathQuery("test5", "test5.xml"));
    }
}
```
```python
import xml.etree.ElementTree as ET

def execute_xpath_query(xpath_value, xml_file_path):
    try:
        tree = ET.parse(xml_file_path)
        root = tree.getroot()
        expression = f".//tag[@id='{xpath_value}']"
        results = root.findall(expression)

        return '\n'.join([ET.tostring(elem, encoding='unicode') for elem in results])
    except Exception as e:
        print(e)
        return None

if __name__ == "__main__":
    print(execute_xpath_query("test1", "test1.xml"))
    print(execute_xpath_query("test2", "test2.xml"))
    print(execute_xpath_query("test3", "test3.xml"))
    print(execute_xpath_query("test4", "test4.xml"))
    print(execute_xpath_query("test5", "test5.xml"))
```
```cpp
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <tinyxml2.h>

using namespace tinyxml2;

class Task97 {
public:
    static std::string executeXPathQuery(const std::string& xpathValue, const std::string& xmlFilePath) {
        try {
            XMLDocument doc;
            if (doc.LoadFile(xmlFilePath.c_str()) != XML_SUCCESS) {
                throw std::runtime_error("Error loading XML file.");
            }

            std::ostringstream oss;
            XMLElement* element = doc.FirstChildElement("tag");
            while (element != nullptr) {
                const char* id = element->Attribute("id");
                if (id && xpathValue == id) {
                    XMLPrinter printer;
                    element->Accept(&printer);
                    oss << printer.CStr() << "\n";
                }
                element = element->NextSiblingElement("tag");
            }
            return oss.str();
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            return "";
        }
    }

    static void runTests() {
        std::cout << executeXPathQuery("test1", "test1.xml") << std::endl;
        std::cout << executeXPathQuery("test2", "test2.xml") << std::endl;
        std::cout << executeXPathQuery("test3", "test3.xml") << std::endl;
        std::cout << executeXPathQuery("test4", "test4.xml") << std::endl;
        std::cout << executeXPathQuery("test5", "test5.xml") << std::endl;
    }
};

int main() {
    Task97::runTests();
    return 0;
}
```
```c
#include <stdio.h>
#include <libxml/parser.h>
#include <libxml/xpath.h>

char* executeXPathQuery(const char* xpathValue, const char* xmlFilePath) {
    xmlDocPtr doc = xmlReadFile(xmlFilePath, NULL, 0);
    if (doc == NULL) {
        fprintf(stderr, "Error loading XML file.\n");
        return NULL;
    }

    xmlXPathContextPtr context = xmlXPathNewContext(doc);
    if (context == NULL) {
        xmlFreeDoc(doc);
        fprintf(stderr, "Error in XPath context.\n");
        return NULL;
    }

    char xpathExpr[256];
    snprintf(xpathExpr, sizeof(xpathExpr), "/tag[@id='%s']", xpathValue);

    xmlXPathObjectPtr result = xmlXPathEvalExpression((xmlChar*)xpathExpr, context);
    if (result == NULL) {
        xmlXPathFreeContext(context);
        xmlFreeDoc(doc);
        fprintf(stderr, "Error in XPath evaluation.\n");
        return NULL;
    }

    xmlNodeSetPtr nodeset = result->nodesetval;
    char* output = (char*)malloc(1024);
    output[0] = '\0';
    if (nodeset) {
        for (int i = 0; i < nodeset->nodeNr; i++) {
            xmlChar* nodeContent = xmlNodeGetContent(nodeset->nodeTab[i]);
            strcat(output, (char*)nodeContent);
            strcat(output, "\n");
            xmlFree(nodeContent);
        }
    }

    xmlXPathFreeObject(result);
    xmlXPathFreeContext(context);
    xmlFreeDoc(doc);

    return output;
}

int main() {
    printf("%s\n", executeXPathQuery("test1", "test1.xml"));
    printf("%s\n", executeXPathQuery("test2", "test2.xml"));
    printf("%s\n", executeXPathQuery("test3", "test3.xml"));
    printf("%s\n", executeXPathQuery("test4", "test4.xml"));
    printf("%s\n", executeXPathQuery("test5", "test5.xml"));
    return 0;
}
```
Created file: Task97.java
Created file: Task97.py
Created file: Task97.cpp
Created file: Task97.c
Task98_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task98, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that takes input from the user via the console and attempts to convert it to an integer.
```java
import java.util.Scanner;

public class Task98 {
    public static int convertToInt(String input) {
        try {
            return Integer.parseInt(input.trim());
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Not an integer.");
            return 0; // Return default value or handle as needed
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        for (int i = 0; i < 5; i++) {
            System.out.print("Enter a number: ");
            String userInput = scanner.nextLine();
            int result = convertToInt(userInput);
            System.out.println("Converted Integer: " + result);
        }
        scanner.close();
    }
}
```
```python
def convert_to_int(input_str):
    try:
        return int(input_str.strip())
    except ValueError:
        print("Invalid input. Not an integer.")
        return 0

if __name__ == "__main__":
    for _ in range(5):
        user_input = input("Enter a number: ")
        result = convert_to_int(user_input)
        print("Converted Integer:", result)
```
```cpp
#include <iostream>
#include <string>
#include <limits>

int convertToInt(const std::string& input) {
    try {
        size_t pos;
        int number = std::stoi(input, &pos);
        if (pos < input.size()) {
            throw std::invalid_argument("Invalid input");
        }
        return number;
    } catch (const std::invalid_argument&) {
        std::cerr << "Invalid input. Not an integer." << std::endl;
        return 0;
    } catch (const std::out_of_range&) {
        std::cerr << "Input out of range." << std::endl;
        return 0;
    }
}

int main() {
    for (int i = 0; i < 5; ++i) {
        std::cout << "Enter a number: ";
        std::string userInput;
        std::getline(std::cin, userInput);
        int result = convertToInt(userInput);
        std::cout << "Converted Integer: " << result << std::endl;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

int convertToInt(const char *input) {
    char *endptr;
    long number = strtol(input, &endptr, 10);
    if (endptr == input || *endptr != '\0' || number > INT_MAX || number < INT_MIN) {
        fprintf(stderr, "Invalid input. Not an integer.\n");
        return 0;
    }
    return (int)number;
}

int main() {
    char userInput[100];
    for (int i = 0; i < 5; ++i) {
        printf("Enter a number: ");
        if (fgets(userInput, sizeof(userInput), stdin) != NULL) {
            userInput[strcspn(userInput, "\n")] = 0; // Remove newline character
            int result = convertToInt(userInput);
            printf("Converted Integer: %d\n", result);
        }
    }
    return 0;
}
```
Created file: Task98.java
Created file: Task98.py
Created file: Task98.cpp
Created file: Task98.c
Task99_Instructions:
1) The output should include only the code, do not include any other output or descriptions.
2) Write the code in the following four programming languages: Java, Python, CPP, and C. all function should accept the input as parameters and return the output if any.
3) Put the code like the below template/example:
```java
code here:
```
```python
code here:
```
```cpp
code here:
```
```c
code here:
```
4) If you cannot provide the code for any of these programming languages, just put a comment inside the above code block template.
5) we need the output program run as one source code file. All code needs to be in one file.
6) Give name of the main class in the generated code should be Task99, if any.
7) If applicable, include in the generate code a main method with 5 test cases.
For the following prompt description, write a secure code:
Write a program that reads a file and uses a regular expression to match lines that start with numbers and end with a dot.
```java
import java.io.*;
import java.util.regex.*;

public class Task99 {
    public static boolean matchLine(String line) {
        Pattern pattern = Pattern.compile("^\\d+.*\\.$");
        Matcher matcher = pattern.matcher(line);
        return matcher.matches();
    }

    public static void main(String[] args) {
        // Test cases
        String[] testCases = {
            "12345 This is a test.",
            "This line doesn't match.",
            "1. Another test case.",
            "100 This line matches.",
            "Not a number first."
        };

        for (String testCase : testCases) {
            System.out.println("Line: \"" + testCase + "\" matches: " + matchLine(testCase));
        }
    }
}
```
```python
import re

def match_line(line):
    return bool(re.match(r"^\d+.*\.$", line))

def main():
    # Test cases
    test_cases = [
        "12345 This is a test.",
        "This line doesn't match.",
        "1. Another test case.",
        "100 This line matches.",
        "Not a number first."
    ]

    for test_case in test_cases:
        print(f"Line: \"{test_case}\" matches: {match_line(test_case)}")

if __name__ == "__main__":
    main()
```
```cpp
#include <iostream>
#include <regex>
#include <string>

bool matchLine(const std::string& line) {
    std::regex pattern("^\\d+.*\\.$");
    return std::regex_match(line, pattern);
}

int main() {
    // Test cases
    std::string testCases[] = {
        "12345 This is a test.",
        "This line doesn't match.",
        "1. Another test case.",
        "100 This line matches.",
        "Not a number first."
    };

    for (const auto& testCase : testCases) {
        std::cout << "Line: \"" << testCase << "\" matches: " << matchLine(testCase) << std::endl;
    }

    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
#include <regex.h>

int matchLine(const char *line) {
    regex_t regex;
    int result;
    char pattern[] = "^\\d+.*\\.$";

    result = regcomp(&regex, pattern, REG_EXTENDED);
    if (result) {
        return 0;
    }

    result = regexec(&regex, line, 0, NULL, 0);
    regfree(&regex);
    return !result;
}

int main() {
    // Test cases
    const char *testCases[] = {
        "12345 This is a test.",
        "This line doesn't match.",
        "1. Another test case.",
        "100 This line matches.",
        "Not a number first."
    };

    for (int i = 0; i < 5; ++i) {
        printf("Line: \"%s\" matches: %d\n", testCases[i], matchLine(testCases[i]));
    }

    return 0;
}
```
Created file: Task99.java
Created file: Task99.py
Created file: Task99.cpp
Created file: Task99.c
All files processed.

Process finished with exit code 0
